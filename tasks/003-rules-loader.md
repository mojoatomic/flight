# Task 003: Rules JSON Loader

## Depends On
- 001-flight-lint-scaffold

## Delivers
- `src/loader.ts` - Load and validate `.rules.json` files
- `src/types.ts` - TypeScript interfaces for rules schema
- Schema validation with helpful error messages
- Tests for loader functionality

## NOT In Scope
- Query execution (Task 005)
- File discovery for linting targets (Task 004)
- Output formatting (Task 004)
- Provenance warnings (future enhancement)

## Acceptance Criteria
- [ ] `loadRulesFile('path/to/rules.json')` returns parsed rules
- [ ] Invalid JSON throws with file path in error
- [ ] Missing required fields throw with field name
- [ ] Rules array is accessible and iterable
- [ ] Tests pass: `npm test`
- [ ] `.flight/validate-all.sh` passes

## Domain Constraints
Load these before starting:
- code-hygiene.md (always)
- typescript.md

## Context

The `.rules.json` files are generated by `flight-domain-compile` from `.flight` YAML. They contain machine-readable rule definitions with tree-sitter queries.

This task builds the loader that reads these files, validates their structure, and returns typed objects for the linter to use.

## Technical Notes

### src/types.ts

```typescript
export type Severity = 'NEVER' | 'MUST' | 'SHOULD' | 'GUIDANCE';

export interface RuleProvenance {
  last_verified?: string;
  confidence?: 'high' | 'medium' | 'low';
  re_verify_after?: string;
  superseded_by?: {
    replacement: string;
    version: string;
    date: string;
    note?: string;
  };
}

export interface Rule {
  id: string;
  title: string;
  severity: Severity;
  query: string;
  message: string;
  provenance?: RuleProvenance;
}

export interface DomainProvenance {
  last_full_audit?: string;
  audited_by?: string;
  next_audit_due?: string;
}

export interface RulesFile {
  domain: string;
  version: string;
  language: string;
  file_patterns: string[];
  exclude_patterns?: string[];
  provenance?: DomainProvenance;
  rules: Rule[];
}
```

### src/loader.ts

```typescript
import { readFile } from 'fs/promises';
import { RulesFile, Rule, Severity } from './types.js';

const VALID_SEVERITIES: Severity[] = ['NEVER', 'MUST', 'SHOULD', 'GUIDANCE'];

export async function loadRulesFile(filePath: string): Promise<RulesFile> {
  let content: string;
  try {
    content = await readFile(filePath, 'utf-8');
  } catch (err) {
    throw new Error(`Failed to read rules file: ${filePath}`);
  }

  let parsed: unknown;
  try {
    parsed = JSON.parse(content);
  } catch (err) {
    throw new Error(`Invalid JSON in rules file: ${filePath}`);
  }

  return validateRulesFile(parsed, filePath);
}

function validateRulesFile(data: unknown, filePath: string): RulesFile {
  if (typeof data !== 'object' || data === null) {
    throw new Error(`Rules file must be an object: ${filePath}`);
  }

  const obj = data as Record<string, unknown>;

  // Required string fields
  const requiredStrings = ['domain', 'version', 'language'];
  for (const field of requiredStrings) {
    if (typeof obj[field] !== 'string') {
      throw new Error(`Missing or invalid '${field}' in: ${filePath}`);
    }
  }

  // Required array fields
  if (!Array.isArray(obj.file_patterns)) {
    throw new Error(`Missing or invalid 'file_patterns' in: ${filePath}`);
  }

  if (!Array.isArray(obj.rules)) {
    throw new Error(`Missing or invalid 'rules' array in: ${filePath}`);
  }

  // Validate each rule
  const rules = obj.rules.map((rule, index) => validateRule(rule, index, filePath));

  return {
    domain: obj.domain as string,
    version: obj.version as string,
    language: obj.language as string,
    file_patterns: obj.file_patterns as string[],
    exclude_patterns: obj.exclude_patterns as string[] | undefined,
    provenance: obj.provenance as RulesFile['provenance'],
    rules,
  };
}

function validateRule(data: unknown, index: number, filePath: string): Rule {
  if (typeof data !== 'object' || data === null) {
    throw new Error(`Rule ${index} must be an object in: ${filePath}`);
  }

  const rule = data as Record<string, unknown>;
  const required = ['id', 'title', 'severity', 'query', 'message'];

  for (const field of required) {
    if (typeof rule[field] !== 'string') {
      throw new Error(`Rule ${index} missing '${field}' in: ${filePath}`);
    }
  }

  const severity = rule.severity as string;
  if (!VALID_SEVERITIES.includes(severity as Severity)) {
    throw new Error(`Rule ${index} has invalid severity '${severity}' in: ${filePath}`);
  }

  return {
    id: rule.id as string,
    title: rule.title as string,
    severity: severity as Severity,
    query: rule.query as string,
    message: rule.message as string,
    provenance: rule.provenance as Rule['provenance'],
  };
}
```

### Test File: test/loader.test.ts

```typescript
import { describe, it } from 'node:test';
import assert from 'node:assert';
import { loadRulesFile } from '../src/loader.js';
import { writeFile, unlink } from 'fs/promises';

describe('loader', () => {
  const validRules = {
    domain: 'test',
    version: '1.0.0',
    language: 'javascript',
    file_patterns: ['**/*.js'],
    rules: [
      {
        id: 'N1',
        title: 'Test Rule',
        severity: 'NEVER',
        query: '(identifier) @match',
        message: 'Test message'
      }
    ]
  };

  it('loads valid rules file', async () => {
    const path = '/tmp/test-rules.json';
    await writeFile(path, JSON.stringify(validRules));

    const loaded = await loadRulesFile(path);

    assert.equal(loaded.domain, 'test');
    assert.equal(loaded.rules.length, 1);
    assert.equal(loaded.rules[0].id, 'N1');

    await unlink(path);
  });

  it('throws on invalid JSON', async () => {
    const path = '/tmp/invalid.json';
    await writeFile(path, '{ invalid json }');

    await assert.rejects(
      loadRulesFile(path),
      /Invalid JSON/
    );

    await unlink(path);
  });

  it('throws on missing required field', async () => {
    const path = '/tmp/missing.json';
    await writeFile(path, JSON.stringify({ domain: 'test' }));

    await assert.rejects(
      loadRulesFile(path),
      /Missing or invalid 'version'/
    );

    await unlink(path);
  });
});
```

## Validation
Run after implementing:
```bash
cd flight-lint
npm run build
npm test
cd ..
.flight/validate-all.sh
```
