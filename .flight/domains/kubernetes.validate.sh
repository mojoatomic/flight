#!/bin/bash
# kubernetes.validate.sh - Kubernetes YAML manifest best practices
# Generated by flight-domain-compile from kubernetes.flight
set -euo pipefail

# Script location for sourcing helpers
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Default: common file patterns
DEFAULT_PATTERNS="**/*.yaml **/*.yml"
PASS=0
FAIL=0
WARN=0

red() { printf '\033[31m%s\033[0m\n' "$1"; }
green() { printf '\033[32m%s\033[0m\n' "$1"; }
yellow() { printf '\033[33m%s\033[0m\n' "$1"; }

check() {
    local name="$1"
    shift
    local result
    result=$("$@" 2>/dev/null) || true
    if [[ -z "$result" ]]; then
        green "✅ $name"
        ((PASS++)) || true
    else
        red "❌ $name"
        printf '%s\n' "$result" | head -10 | sed 's/^/   /'
        ((FAIL++)) || true
    fi
}

warn() {
    local name="$1"
    shift
    local result
    result=$("$@" 2>/dev/null) || true
    if [[ -z "$result" ]]; then
        green "✅ $name"
        ((PASS++)) || true
    else
        yellow "⚠️  $name"
        printf '%s\n' "$result" | head -5 | sed 's/^/   /'
        ((WARN++)) || true
    fi
}

printf '%s\n' "═══════════════════════════════════════════"
printf '%s\n' "  KUBERNETES Domain Validation"
printf '%s\n' "═══════════════════════════════════════════"
printf '\n'

# Source exclusions helper if available
if [[ -f "$SCRIPT_DIR/../exclusions.sh" ]]; then
    source "$SCRIPT_DIR/../exclusions.sh"
    FLIGHT_HAS_EXCLUSIONS=true
else
    FLIGHT_HAS_EXCLUSIONS=false
fi

# Handle arguments or use defaults
if [[ $# -gt 0 ]]; then
    FILES=("$@")
elif [[ "$FLIGHT_HAS_EXCLUSIONS" == true ]]; then
    # Use exclusions-aware file discovery
    mapfile -t FILES < <(flight_get_files "*.yaml" "*.yml")
else
    # Fallback: use find (works on bash 3.2+, no globstar needed)
    mapfile -t FILES < <(find . -type f \( -name "*.yaml" -o -name "*.yml" \) -not -path "*/node_modules/*" -not -path "*/.git/*" -not -path "*/dist/*" -not -path "*/build/*" 2>/dev/null | sort)
fi

if [[ ${#FILES[@]} -eq 0 ]]; then
    yellow "No files found matching default patterns"
    printf '%s\n' "  Patterns: **/*.yaml **/*.yml..."
    printf '\n'
    green "  RESULT: SKIP (no files)"
    exit 0
fi

printf 'Files: %d\n\n' "${#FILES[@]}"

printf '\n%s\n' "## NEVER Rules"

# N1: Privileged Containers
check "N1: Privileged Containers" \
    bash -c 'grep -Ein "privileged:\\s*true" "$@" | grep -v "flight:ok"' _ "${FILES[@]}"

# N2: Host Namespace Sharing
check "N2: Host Namespace Sharing" \
    bash -c 'grep -Ein "host(PID|IPC|Network):\\s*true" "$@" | grep -v "flight:ok"' _ "${FILES[@]}"

# N3: Dangerous Capabilities
check "N3: Dangerous Capabilities" \
    bash -c 'grep -Eiz "capabilities:[\\s\\S]*?add:[\\s\\S]*?(SYS_ADMIN|NET_ADMIN|SYS_PTRACE|NET_RAW|SYS_MODULE|DAC_READ_SEARCH|ALL)\\b" "$@" | grep -v "flight:ok"' _ "${FILES[@]}"

# N4: HostPath Volume Mounts
check "N4: HostPath Volume Mounts" \
    bash -c 'grep -Ein "hostPath:" "$@" | grep -v "flight:ok"' _ "${FILES[@]}"

# N5: Privilege Escalation Allowed
check "N5: Privilege Escalation Allowed" \
    bash -c 'for f in "$@"; do
  # Check for explicit true setting
  if grep -qE '"'"'allowPrivilegeEscalation:\s*true'"'"' "$f" 2>/dev/null; then
    grep -HnE '"'"'allowPrivilegeEscalation:\s*true'"'"' "$f" | grep -v '"'"'flight:ok'"'"'
  fi
done' _ "${FILES[@]}"

# N6: Running as Root User
check "N6: Running as Root User" \
    bash -c 'grep -En "runAsUser:\\s*0\\s*\$" "$@" | grep -v "flight:ok"' _ "${FILES[@]}"

# N7: Secrets in Environment Variables
check "N7: Secrets in Environment Variables" \
    bash -c 'grep -Eiz "name:\\s*(PASSWORD|SECRET|API_KEY|TOKEN|PRIVATE_KEY|CREDENTIAL|AUTH_TOKEN)\\s*\\n\\s*value:\\s*[\"\\x27]?[^\"\\x27\\n]+" "$@" | grep -v "flight:ok"' _ "${FILES[@]}"

# N8: Default ServiceAccount
check "N8: Default ServiceAccount" \
    bash -c 'for f in "$@"; do
  if grep -qE '"'"'kind:\s*(Deployment|StatefulSet|DaemonSet|Job|CronJob|Pod)'"'"' "$f" 2>/dev/null; then
    if grep -qE '"'"'serviceAccountName:\s*default\s*$'"'"' "$f" 2>/dev/null; then
      grep -HnE '"'"'serviceAccountName:\s*default\s*$'"'"' "$f" | grep -v '"'"'flight:ok'"'"'
    fi
  fi
done' _ "${FILES[@]}"

printf '\n%s\n' "## MUST Rules"

# M1: Container Image Tag Required
check "M1: Container Image Tag Required" \
    bash -c 'for f in "$@"; do
  # Match image: without tag or with :latest
  grep -HnE '"'"'image:\s*["\x27]?[a-zA-Z0-9._/-]+(:latest)?\s*["\x27]?\s*$'"'"' "$f" 2>/dev/null | \
    grep -v '"'"':[0-9]'"'"' | \
    grep -v '"'"'@sha256:'"'"' | \
    grep -v '"'"'flight:ok'"'"'
done' _ "${FILES[@]}"

# M2: Resource Requests Required
check "M2: Resource Requests Required" \
    bash -c 'for f in "$@"; do
  if grep -qE '"'"'kind:\s*(Deployment|StatefulSet|DaemonSet|Job|Pod)'"'"' "$f" 2>/dev/null; then
    if grep -qE '"'"'containers:'"'"' "$f" 2>/dev/null; then
      if ! grep -qE '"'"'requests:'"'"' "$f" 2>/dev/null; then
        echo "$f: containers found but no resource requests defined"
      fi
    fi
  fi
done | grep -v '"'"'flight:ok'"'"'' _ "${FILES[@]}"

# M3: Resource Limits Required
check "M3: Resource Limits Required" \
    bash -c 'for f in "$@"; do
  if grep -qE '"'"'kind:\s*(Deployment|StatefulSet|DaemonSet|Job|Pod)'"'"' "$f" 2>/dev/null; then
    if grep -qE '"'"'containers:'"'"' "$f" 2>/dev/null; then
      if ! grep -qE '"'"'limits:'"'"' "$f" 2>/dev/null; then
        echo "$f: containers found but no memory limits defined"
      fi
    fi
  fi
done | grep -v '"'"'flight:ok'"'"'' _ "${FILES[@]}"

# M4: Liveness Probe Required
check "M4: Liveness Probe Required" \
    bash -c 'for f in "$@"; do
  if grep -qE '"'"'kind:\s*(Deployment|StatefulSet|DaemonSet)'"'"' "$f" 2>/dev/null; then
    if grep -qE '"'"'containers:'"'"' "$f" 2>/dev/null; then
      if ! grep -qE '"'"'livenessProbe:'"'"' "$f" 2>/dev/null; then
        echo "$f: long-running workload without livenessProbe"
      fi
    fi
  fi
done | grep -v '"'"'flight:ok'"'"'' _ "${FILES[@]}"

# M5: Readiness Probe Required
check "M5: Readiness Probe Required" \
    bash -c 'for f in "$@"; do
  if grep -qE '"'"'kind:\s*(Deployment|StatefulSet|DaemonSet)'"'"' "$f" 2>/dev/null; then
    if grep -qE '"'"'containers:'"'"' "$f" 2>/dev/null; then
      if ! grep -qE '"'"'readinessProbe:'"'"' "$f" 2>/dev/null; then
        echo "$f: workload without readinessProbe"
      fi
    fi
  fi
done | grep -v '"'"'flight:ok'"'"'' _ "${FILES[@]}"

# M6: Deployment Replicas
check "M6: Deployment Replicas" \
    bash -c 'for f in "$@"; do
  if grep -qE '"'"'kind:\s*Deployment'"'"' "$f" 2>/dev/null; then
    if grep -qE '"'"'replicas:\s*1\s*$'"'"' "$f" 2>/dev/null; then
      grep -HnE '"'"'replicas:\s*1\s*$'"'"' "$f" | grep -v '"'"'flight:ok'"'"'
    fi
  fi
done' _ "${FILES[@]}"

# M7: Labels Required
check "M7: Labels Required" \
    bash -c 'for f in "$@"; do
  if grep -qE '"'"'kind:\s*(Deployment|StatefulSet|DaemonSet|Pod)'"'"' "$f" 2>/dev/null; then
    if ! grep -qE '"'"'labels:'"'"' "$f" 2>/dev/null; then
      echo "$f: workload without labels defined"
    fi
  fi
done | grep -v '"'"'flight:ok'"'"'' _ "${FILES[@]}"

# M8: Namespace Required
check "M8: Namespace Required" \
    bash -c 'for f in "$@"; do
  if grep -qE '"'"'kind:\s*(Deployment|StatefulSet|DaemonSet|Service|ConfigMap|Secret|Pod)'"'"' "$f" 2>/dev/null; then
    if ! grep -qE '"'"'namespace:'"'"' "$f" 2>/dev/null; then
      echo "$f: resource without explicit namespace"
    elif grep -qE '"'"'namespace:\s*default\s*$'"'"' "$f" 2>/dev/null; then
      grep -HnE '"'"'namespace:\s*default\s*$'"'"' "$f" | grep -v '"'"'flight:ok'"'"'
    fi
  fi
done' _ "${FILES[@]}"

printf '\n%s\n' "## SHOULD Rules"

# S1: Run as Non-Root
warn "S1: Run as Non-Root" \
    bash -c 'for f in "$@"; do
  if grep -qE '"'"'kind:\s*(Deployment|StatefulSet|DaemonSet|Pod)'"'"' "$f" 2>/dev/null; then
    if ! grep -qE '"'"'runAsNonRoot:\s*true'"'"' "$f" 2>/dev/null; then
      echo "$f: securityContext.runAsNonRoot not set to true"
    fi
  fi
done | grep -v '"'"'flight:ok'"'"'' _ "${FILES[@]}"

# S2: Read-Only Root Filesystem
warn "S2: Read-Only Root Filesystem" \
    bash -c 'for f in "$@"; do
  if grep -qE '"'"'kind:\s*(Deployment|StatefulSet|DaemonSet|Pod)'"'"' "$f" 2>/dev/null; then
    if grep -qE '"'"'containers:'"'"' "$f" 2>/dev/null; then
      if ! grep -qE '"'"'readOnlyRootFilesystem:\s*true'"'"' "$f" 2>/dev/null; then
        echo "$f: securityContext.readOnlyRootFilesystem not set to true"
      fi
    fi
  fi
done | grep -v '"'"'flight:ok'"'"'' _ "${FILES[@]}"

# S3: Drop All Capabilities
warn "S3: Drop All Capabilities" \
    bash -c 'for f in "$@"; do
  if grep -qE '"'"'kind:\s*(Deployment|StatefulSet|DaemonSet|Pod)'"'"' "$f" 2>/dev/null; then
    if grep -qE '"'"'containers:'"'"' "$f" 2>/dev/null; then
      # Check for drop: ["ALL"] or drop: - ALL patterns
      if ! grep -qE '"'"'drop:'"'"' "$f" 2>/dev/null || ! grep -qE '"'"'(- ALL|\["ALL"\]|"ALL")'"'"' "$f" 2>/dev/null; then
        echo "$f: capabilities.drop does not include ALL"
      fi
    fi
  fi
done | grep -v '"'"'flight:ok'"'"'' _ "${FILES[@]}"

# S4: PodDisruptionBudget Required
warn "S4: PodDisruptionBudget Required" \
    bash -c 'for f in "$@"; do
  if grep -qE '"'"'kind:\s*(Deployment|StatefulSet)'"'"' "$f" 2>/dev/null; then
    name=$(grep -A1 '"'"'metadata:'"'"' "$f" 2>/dev/null | grep '"'"'name:'"'"' | head -1 | sed '"'"'s/.*name:\s*//'"'"' | tr -d '"'"'"\x27 '"'"')
    if [ -n "$name" ]; then
      # Check if PDB exists in same file or directory
      dir=$(dirname "$f")
      if ! grep -rqE "kind:\s*PodDisruptionBudget" "$dir" 2>/dev/null; then
        echo "$f: Deployment/StatefulSet '"'"'$name'"'"' has no PodDisruptionBudget"
      fi
    fi
  fi
done | grep -v '"'"'flight:ok'"'"'' _ "${FILES[@]}"

# S5: Pod Anti-Affinity
warn "S5: Pod Anti-Affinity" \
    bash -c 'for f in "$@"; do
  if grep -qE '"'"'kind:\s*(Deployment|StatefulSet)'"'"' "$f" 2>/dev/null; then
    if grep -qE '"'"'replicas:\s*[2-9]'"'"' "$f" 2>/dev/null; then
      if ! grep -qE '"'"'podAntiAffinity:'"'"' "$f" 2>/dev/null; then
        echo "$f: multi-replica workload without podAntiAffinity"
      fi
    fi
  fi
done | grep -v '"'"'flight:ok'"'"'' _ "${FILES[@]}"

# S6: Image Pull Policy Always
warn "S6: Image Pull Policy Always" \
    bash -c 'for f in "$@"; do
  if grep -qE '"'"'kind:\s*(Deployment|StatefulSet|DaemonSet|Pod)'"'"' "$f" 2>/dev/null; then
    if grep -qE '"'"'imagePullPolicy:\s*(Never|IfNotPresent)'"'"' "$f" 2>/dev/null; then
      grep -HnE '"'"'imagePullPolicy:\s*(Never|IfNotPresent)'"'"' "$f" | grep -v '"'"'flight:ok'"'"'
    fi
  fi
done' _ "${FILES[@]}"

# S7: Seccomp Profile
warn "S7: Seccomp Profile" \
    bash -c 'for f in "$@"; do
  if grep -qE '"'"'kind:\s*(Deployment|StatefulSet|DaemonSet|Pod)'"'"' "$f" 2>/dev/null; then
    if ! grep -qE '"'"'seccompProfile:'"'"' "$f" 2>/dev/null; then
      echo "$f: no seccompProfile configured"
    fi
  fi
done | grep -v '"'"'flight:ok'"'"'' _ "${FILES[@]}"

# S8: Service Account Token Automount
warn "S8: Service Account Token Automount" \
    bash -c 'for f in "$@"; do
  if grep -qE '"'"'kind:\s*(Deployment|StatefulSet|DaemonSet|Pod)'"'"' "$f" 2>/dev/null; then
    # Only warn if automountServiceAccountToken is not explicitly set
    if ! grep -qE '"'"'automountServiceAccountToken:'"'"' "$f" 2>/dev/null; then
      echo "$f: automountServiceAccountToken not explicitly configured"
    fi
  fi
done | grep -v '"'"'flight:ok'"'"'' _ "${FILES[@]}"

# S9: Network Policy
warn "S9: Network Policy" \
    bash -c 'for f in "$@"; do
  if grep -qE '"'"'kind:\s*(Deployment|StatefulSet|DaemonSet)'"'"' "$f" 2>/dev/null; then
    dir=$(dirname "$f")
    if ! grep -rqE "kind:\s*NetworkPolicy" "$dir" 2>/dev/null; then
      echo "$f: no NetworkPolicy found in directory"
    fi
  fi
done | grep -v '"'"'flight:ok'"'"'' _ "${FILES[@]}"

# S10: Probes Must Differ
warn "S10: Probes Must Differ" \
    bash -c 'for f in "$@"; do
  if grep -qE '"'"'livenessProbe:'"'"' "$f" 2>/dev/null && grep -qE '"'"'readinessProbe:'"'"' "$f" 2>/dev/null; then
    liveness=$(grep -A5 '"'"'livenessProbe:'"'"' "$f" 2>/dev/null | head -6)
    readiness=$(grep -A5 '"'"'readinessProbe:'"'"' "$f" 2>/dev/null | head -6)
    # Simple check - if paths/ports are same
    liveness_path=$(echo "$liveness" | grep -oE '"'"'path:\s*\S+'"'"' | head -1)
    readiness_path=$(echo "$readiness" | grep -oE '"'"'path:\s*\S+'"'"' | head -1)
    if [ -n "$liveness_path" ] && [ "$liveness_path" = "$readiness_path" ]; then
      echo "$f: liveness and readiness probes appear identical"
    fi
  fi
done | grep -v '"'"'flight:ok'"'"'' _ "${FILES[@]}"

printf '\n%s\n' "## Info"

DEPLOYMENT_COUNT=$( (grep -cE "kind:\s*Deployment" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  Deployments: %s\n' "$DEPLOYMENT_COUNT"

STATEFULSET_COUNT=$( (grep -cE "kind:\s*StatefulSet" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  StatefulSets: %s\n' "$STATEFULSET_COUNT"

SERVICE_COUNT=$( (grep -cE "kind:\s*Service" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  Services: %s\n' "$SERVICE_COUNT"

CONFIGMAP_COUNT=$( (grep -cE "kind:\s*ConfigMap" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  ConfigMaps: %s\n' "$CONFIGMAP_COUNT"

SECRET_COUNT=$( (grep -cE "kind:\s*Secret" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  Secrets: %s\n' "$SECRET_COUNT"

printf '\n%s\n' "═══════════════════════════════════════════"
printf '  PASS: %d  FAIL: %d  WARN: %d\n' "$PASS" "$FAIL" "$WARN"
if [[ $FAIL -eq 0 ]]; then
    green "  RESULT: PASS"
else
    red "  RESULT: FAIL"
fi
printf '%s\n' "═══════════════════════════════════════════"

exit "$FAIL"
