#!/usr/bin/env bash
# embedded-c-p10.validate.sh - Safety-critical embedded C following NASA JPL's "Power of 10" rules for reliable software
# Generated by flight-domain-compile from embedded-c-p10.flight
set -euo pipefail

# Script location for sourcing helpers
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Default: common file patterns
DEFAULT_PATTERNS="**/*.c"
PASS=0
FAIL=0
WARN=0

red() { printf '\033[31m%s\033[0m\n' "$1"; }
green() { printf '\033[32m%s\033[0m\n' "$1"; }
yellow() { printf '\033[33m%s\033[0m\n' "$1"; }

check() {
    local name="$1"
    shift
    local result
    result=$("$@" 2>/dev/null) || true
    if [[ -z "$result" ]]; then
        green "✅ $name"
        ((PASS++)) || true
    else
        red "❌ $name"
        # Use subshell to prevent SIGPIPE from killing script with pipefail
        (printf '%s\n' "$result" | head -10 | sed 's/^/   /') || true
        ((FAIL++)) || true
    fi
}

warn() {
    local name="$1"
    shift
    local result
    result=$("$@" 2>/dev/null) || true
    if [[ -z "$result" ]]; then
        green "✅ $name"
        ((PASS++)) || true
    else
        yellow "⚠️  $name"
        # Use subshell to prevent SIGPIPE from killing script with pipefail
        (printf '%s\n' "$result" | head -5 | sed 's/^/   /') || true
        ((WARN++)) || true
    fi
}

printf '%s\n' "═══════════════════════════════════════════"
printf '%s\n' "  EMBEDDED-C-P10 Domain Validation"
printf '%s\n' "═══════════════════════════════════════════"
printf '\n'

# Source exclusions helper if available
if [[ -f "$SCRIPT_DIR/../exclusions.sh" ]]; then
    source "$SCRIPT_DIR/../exclusions.sh"
    FLIGHT_HAS_EXCLUSIONS=true
else
    FLIGHT_HAS_EXCLUSIONS=false
fi

# Handle arguments or use defaults
if [[ $# -gt 0 ]]; then
    FILES=("$@")
elif [[ "$FLIGHT_HAS_EXCLUSIONS" == true ]]; then
    # Use exclusions-aware file discovery
    mapfile -t FILES < <(flight_get_files "*.c")
else
    # Fallback: use find (works on bash 3.2+, no globstar needed)
    # Redirect stdin from /dev/null to prevent hanging in piped contexts (curl | bash)
    mapfile -t FILES < <(find . -type f \( -name "*.c" \) -not -path "*/node_modules/*" -not -path "*/.git/*" -not -path "*/dist/*" -not -path "*/build/*" < /dev/null 2>/dev/null | sort)
fi

if [[ ${#FILES[@]} -eq 0 ]]; then
    yellow "No files found matching default patterns"
    printf '%s\n' "  Patterns: **/*.c..."
    printf '\n'
    green "  RESULT: SKIP (no files)"
    exit 0
fi

printf 'Files: %d\n\n' "${#FILES[@]}"

printf '\n%s\n' "## NEVER Rules"

# N1: No goto
check "N1: No goto" \
    grep -n "goto " "${FILES[@]}"

# N2: No setjmp/longjmp
check "N2: No setjmp/longjmp" \
    grep -n "setjmp\\|longjmp" "${FILES[@]}"

# N3: No Dynamic Memory Allocation
check "N3: No Dynamic Memory Allocation" \
    # Unknown check type: ast

# N4: No Conditional Compilation
check "N4: No Conditional Compilation" \
    grep -n "^#ifdef\\|^#if " "${FILES[@]}"

# N5: No Double Pointer Dereference
check "N5: No Double Pointer Dereference" \
    # Unknown check type: ast

# N6: No Chained Pointer Access
check "N6: No Chained Pointer Access" \
    grep -n "->.*->" "${FILES[@]}"

# N7: No Unbounded Loops
check "N7: No Unbounded Loops" \
    grep -En "while\\s*\\(1\\)|while\\s*\\(true\\)|for\\s*\\(;;\\)" "${FILES[@]}"

# N9: Functions Must Be 60 Lines or Less
check "N9: Functions Must Be 60 Lines or Less" \
    bash -c 'for file in "$@"; do
awk '"'"'
/^(status_t|static|void|int|uint[0-9]+_t|bool) [a-z_]+\(/ {
  start=NR; fname=$0; in_func=1
}
/^}$/ && in_func {
  len=NR-start
  if (len > 60) {
    gsub(/\(.*/, "", fname)
    gsub(/^.* /, "", fname)
    print fname": "len" lines"
  }
  in_func=0
}'"'"' "$@"
done' _ "${FILES[@]}"

# N10: Minimum 2 Assertions Per Function
check "N10: Minimum 2 Assertions Per Function" \
    bash -c 'for file in "$@"; do
awk '"'"'
/^(status_t|static|void|int|uint[0-9]+_t|bool) [a-z_]+\(/ {
  fname=$0; asserts=0; in_func=1
}
/ASSERT\(|assert\(/ && in_func { asserts++ }
/^}$/ && in_func {
  if (asserts < 2) {
    gsub(/\(.*/, "", fname)
    gsub(/^.* /, "", fname)
    print fname": "asserts" asserts"
  }
  in_func=0
}'"'"' "$@"
done' _ "${FILES[@]}"

# N11: Check or Cast All Return Values
check "N11: Check or Cast All Return Values" \
    # Unknown check type: ast

printf '\n%s\n' "═══════════════════════════════════════════"
printf '  PASS: %d  FAIL: %d  WARN: %d\n' "$PASS" "$FAIL" "$WARN"
if [[ $FAIL -eq 0 ]]; then
    green "  RESULT: PASS"
else
    red "  RESULT: FAIL"
fi
printf '%s\n' "═══════════════════════════════════════════"

exit "$FAIL"
