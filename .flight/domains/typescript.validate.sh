#!/usr/bin/env bash
# typescript.validate.sh - Type-safe TypeScript patterns that catch errors at compile time
# Generated by flight-domain-compile from typescript.flight
set -euo pipefail

# Script location for sourcing helpers
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Default: common file patterns
DEFAULT_PATTERNS="**/*.ts **/*.tsx"
PASS=0
FAIL=0
WARN=0

red() { printf '\033[31m%s\033[0m\n' "$1"; }
green() { printf '\033[32m%s\033[0m\n' "$1"; }
yellow() { printf '\033[33m%s\033[0m\n' "$1"; }

check() {
    local name="$1"
    shift
    local result
    result=$("$@" 2>/dev/null) || true
    if [[ -z "$result" ]]; then
        green "✅ $name"
        ((PASS++)) || true
    else
        red "❌ $name"
        # Use subshell to prevent SIGPIPE from killing script with pipefail
        (printf '%s\n' "$result" | head -10 | sed 's/^/   /') || true
        ((FAIL++)) || true
    fi
}

warn() {
    local name="$1"
    shift
    local result
    result=$("$@" 2>/dev/null) || true
    if [[ -z "$result" ]]; then
        green "✅ $name"
        ((PASS++)) || true
    else
        yellow "⚠️  $name"
        # Use subshell to prevent SIGPIPE from killing script with pipefail
        (printf '%s\n' "$result" | head -5 | sed 's/^/   /') || true
        ((WARN++)) || true
    fi
}

printf '%s\n' "═══════════════════════════════════════════"
printf '%s\n' "  TYPESCRIPT Domain Validation"
printf '%s\n' "═══════════════════════════════════════════"
printf '\n'

# Source exclusions helper if available
if [[ -f "$SCRIPT_DIR/../exclusions.sh" ]]; then
    source "$SCRIPT_DIR/../exclusions.sh"
    FLIGHT_HAS_EXCLUSIONS=true
else
    FLIGHT_HAS_EXCLUSIONS=false
fi

# Handle arguments or use defaults
if [[ $# -gt 0 ]]; then
    FILES=("$@")
elif [[ "$FLIGHT_HAS_EXCLUSIONS" == true ]]; then
    # Use exclusions-aware file discovery
    mapfile -t FILES < <(flight_get_files "*.ts" "*.tsx")
else
    # Fallback: use find (works on bash 3.2+, no globstar needed)
    # Redirect stdin from /dev/null to prevent hanging in piped contexts (curl | bash)
    mapfile -t FILES < <(find . -type f \( -name "*.ts" -o -name "*.tsx" \) -not -path "*/node_modules/*" -not -path "*/.git/*" -not -path "*/dist/*" -not -path "*/build/*" < /dev/null 2>/dev/null | sort)
fi

if [[ ${#FILES[@]} -eq 0 ]]; then
    yellow "No files found matching default patterns"
    printf '%s\n' "  Patterns: **/*.ts **/*.tsx..."
    printf '\n'
    green "  RESULT: SKIP (no files)"
    exit 0
fi

printf 'Files: %d\n\n' "${#FILES[@]}"

printf '\n%s\n' "## NEVER Rules"

# N1: Unjustified any
check "N1: Unjustified any" \
    # Unknown check type: ast

# N2: @ts-ignore Without Explanation
check "N2: @ts-ignore Without Explanation" \
    # Unknown check type: ast

# N3: Chained Non-null Assertions
check "N3: Chained Non-null Assertions" \
    grep -En "\\w+!\\.\\w+!\\." "${FILES[@]}"

# N4: Type Assertion on Unvalidated Data
check "N4: Type Assertion on Unvalidated Data" \
    grep -En "JSON\\.parse\\([^)]+\\)\\s+as\\s+|\\.json\\(\\)\\s+as\\s+" "${FILES[@]}"

# N5: Loose Object Types
check "N5: Loose Object Types" \
    grep -En ":\\s*object\\s*[;,)=\\{]|:\\s*\\{\\s*\\}\\s*[;,)=]" "${FILES[@]}"

# N6: String Type for Status/Type/Kind Fields
check "N6: String Type for Status/Type/Kind Fields" \
    grep -En "(status|type|kind|state|mode):\\s*string\\s*[;,)]" "${FILES[@]}"

# N7: Exported Functions Must Have Return Type
check "N7: Exported Functions Must Have Return Type" \
    bash -c '(grep -En "^export (async )?function \\w+\\([^)]*\\)\\s*\\{" "$@" | grep -v "\\):") || true' _ "${FILES[@]}"

# N8: Implicit Any in Callbacks (JSON.parse, as any)
check "N8: Implicit Any in Callbacks (JSON.parse, as any)" \
    grep -En "JSON\\.parse\\([^)]*\\)\\.(map|filter|reduce|forEach|find|some|every)\\(|as any\\)\\.(map|filter|reduce|forEach|find|some|every)\\(" "${FILES[@]}"

# N9: eval() Usage
check "N9: eval() Usage" \
    # Unknown check type: ast

# N10: innerHTML Assignment
check "N10: innerHTML Assignment" \
    # Unknown check type: ast

# N11: document.write() Usage
check "N11: document.write() Usage" \
    # Unknown check type: ast

printf '\n%s\n' "## MUST Rules"

# M2: Type Guards for unknown
check "M2: Type Guards for unknown" \
    bash -c '
for f in "$@"; do
    trigger_lines=$(grep -nE ": unknown" "$f" 2>/dev/null)
    if [[ -n "$trigger_lines" ]]; then
        if ! grep -qE "is [A-Z]" "$f" 2>/dev/null; then
            echo "$trigger_lines" | while IFS= read -r line; do
                linenum="${line%%:*}"
                echo "$f:$linenum: uses '"'"'unknown'"'"' but no type guard found"
            done
        fi
    fi
done
' _ "${FILES[@]}"

# M3: Interface for Object Shapes
check "M3: Interface for Object Shapes" \
    grep -En "type [A-Z][a-zA-Z]* = \\{" "${FILES[@]}"

# M4: Readonly for Array Parameters
check "M4: Readonly for Array Parameters" \
    bash -c '(grep -En "function.*\\([^)]*:\\s*[A-Za-z]+\\[\\]" "$@" | grep -v "readonly") || true' _ "${FILES[@]}"

printf '\n%s\n' "## Info"

TYPES_DEFINED=$( (grep -cE "^(export )?(type|interface) " "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  Types/Interfaces defined: %s\n' "$TYPES_DEFINED"

ANY_USAGE=$( (grep -oE ": any|as any|<any>" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  'any' usage count: %s\n' "$ANY_USAGE"

UNKNOWN_USAGE=$( (grep -oE ": unknown" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  'unknown' usage count: %s\n' "$UNKNOWN_USAGE"

TYPE_GUARDS=$( (grep -cE "is [A-Z][a-zA-Z]+" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  Type guards: %s\n' "$TYPE_GUARDS"

printf '\n%s\n' "═══════════════════════════════════════════"
printf '  PASS: %d  FAIL: %d  WARN: %d\n' "$PASS" "$FAIL" "$WARN"
if [[ $FAIL -eq 0 ]]; then
    green "  RESULT: PASS"
else
    red "  RESULT: FAIL"
fi
printf '%s\n' "═══════════════════════════════════════════"

exit "$FAIL"
