#!/bin/bash
# typescript.validate.sh - Type-safe TypeScript patterns that catch errors at compile time
# Generated by flight-domain-compile from typescript.flight
set -euo pipefail

# Default: common file patterns
DEFAULT_PATTERNS="**/*.ts **/*.tsx"
PASS=0
FAIL=0
WARN=0

red() { printf '\033[31m%s\033[0m\n' "$1"; }
green() { printf '\033[32m%s\033[0m\n' "$1"; }
yellow() { printf '\033[33m%s\033[0m\n' "$1"; }

check() {
    local name="$1"
    shift
    local result
    result=$("$@" 2>/dev/null) || true
    if [[ -z "$result" ]]; then
        green "✅ $name"
        ((PASS++)) || true
    else
        red "❌ $name"
        printf '%s\n' "$result" | head -10 | sed 's/^/   /'
        ((FAIL++)) || true
    fi
}

warn() {
    local name="$1"
    shift
    local result
    result=$("$@" 2>/dev/null) || true
    if [[ -z "$result" ]]; then
        green "✅ $name"
        ((PASS++)) || true
    else
        yellow "⚠️  $name"
        printf '%s\n' "$result" | head -5 | sed 's/^/   /'
        ((WARN++)) || true
    fi
}

printf '%s\n' "═══════════════════════════════════════════"
printf '%s\n' "  TYPESCRIPT Domain Validation"
printf '%s\n' "═══════════════════════════════════════════"
printf '\n'

# Handle arguments or use defaults
if [[ $# -gt 0 ]]; then
    FILES=("$@")
else
    shopt -s nullglob globstar
    FILES=($DEFAULT_PATTERNS)
    shopt -u nullglob globstar
fi

if [[ ${#FILES[@]} -eq 0 ]]; then
    yellow "No files found matching default patterns"
    printf '%s\n' "  Patterns: **/*.ts **/*.tsx..."
    printf '\n'
    green "  RESULT: SKIP (no files)"
    exit 0
fi

printf 'Files: %d\n\n' "${#FILES[@]}"

printf '\n%s\n' "## NEVER Rules"

# N1: Unjustified any
check "N1: Unjustified any" \
    bash -c 'for f in "$@"; do
  awk '"'"'
  /: any/ || /as any/ || /<any>/ {
    # Check if previous line has justification
    if (prev !~ /TODO|FIXME|any.*because|legacy|migration|third.party|lib types/) {
      # Check if current line has justification in a comment
      if ($0 !~ /\/\/.*any|\/\*.*any|\/\/.*TODO|\/\/.*FIXME|\/\/.*legacy|\/\/.*migration|\/\/.*third.party|\/\/.*lib types|flight:ok/) {
        print FILENAME":"NR": "$0
      }
    }
  }
  { prev = $0 }
  '"'"' "$f"
done' _ "${FILES[@]}"

# N2: @ts-ignore Without Explanation
check "N2: @ts-ignore Without Explanation" \
    grep -En "@ts-ignore\\s*\$" "${FILES[@]}"

# N3: Chained Non-null Assertions
check "N3: Chained Non-null Assertions" \
    grep -En "\\w+!\\.\\w+!\\." "${FILES[@]}"

# N4: Type Assertion on Unvalidated Data
check "N4: Type Assertion on Unvalidated Data" \
    grep -En "JSON\\.parse\\([^)]+\\)\\s+as\\s+|\\.json\\(\\)\\s+as\\s+" "${FILES[@]}"

# N5: Loose Object Types
check "N5: Loose Object Types" \
    grep -En ":\\s*object\\s*[;,)=\\{]|:\\s*\\{\\s*\\}\\s*[;,)=]" "${FILES[@]}"

# N6: String Type for Status/Type/Kind Fields
check "N6: String Type for Status/Type/Kind Fields" \
    grep -En "(status|type|kind|state|mode):\\s*string\\s*[;,)]" "${FILES[@]}"

# N7: Exported Functions Must Have Return Type
check "N7: Exported Functions Must Have Return Type" \
    bash -c 'grep -En '"'"'^export (async )?function \w+\([^)]*\)\s*\{'"'"' "$@" | grep -v '"'"'):'"'"'' _ "${FILES[@]}"

# N8: Implicit Any in Callbacks (JSON.parse, as any)
check "N8: Implicit Any in Callbacks (JSON.parse, as any)" \
    bash -c 'grep -En '"'"'JSON\.parse\([^)]*\)\.(map|filter|reduce|forEach|find|some|every)\('"'"' "$@" | grep -v '"'"'flight:ok'"'"'
grep -En '"'"'as any\)\.(map|filter|reduce|forEach|find|some|every)\('"'"' "$@" | grep -v '"'"'flight:ok'"'"'' _ "${FILES[@]}"

printf '\n%s\n' "## MUST Rules"

# M1: tsconfig strict Mode
check "M1: tsconfig strict Mode" \
    bash -c 'STRICT_FOUND=false
if [ -f tsconfig.json ]; then
  if grep -qE '"'"'"strict"[[:space:]]*:[[:space:]]*true'"'"' tsconfig.json 2>/dev/null; then
    STRICT_FOUND=true
  fi
fi
if [ -f tsconfig.app.json ]; then
  if grep -qE '"'"'"strict"[[:space:]]*:[[:space:]]*true'"'"' tsconfig.app.json 2>/dev/null; then
    STRICT_FOUND=true
  fi
fi
if [ "$STRICT_FOUND" = false ]; then
  if [ -f tsconfig.json ] || [ -f tsconfig.app.json ]; then
    echo '"'"'No tsconfig file has strict: true enabled'"'"'
  fi
fi' _ "${FILES[@]}"

# M2: Type Guards for unknown
check "M2: Type Guards for unknown" \
    bash -c 'for f in "$@"; do
  if grep -q '"'"': unknown'"'"' "$f"; then
    if ! grep -q '"'"'is [A-Z]'"'"' "$f"; then
      echo "$f: uses '"'"'unknown'"'"' but no type guard found"
    fi
  fi
done' _ "${FILES[@]}"

# M3: Interface for Object Shapes
check "M3: Interface for Object Shapes" \
    bash -c 'for f in "$@"; do
  grep -Hn '"'"'type [A-Z][a-zA-Z]* = {'"'"' "$f" 2>/dev/null | head -3
done' _ "${FILES[@]}"

# M4: Readonly for Array Parameters
check "M4: Readonly for Array Parameters" \
    bash -c 'for f in "$@"; do
  grep -En '"'"'function.*\([^)]*:\s*[A-Za-z]+\[\]'"'"' "$f" 2>/dev/null | grep -v '"'"'readonly'"'"' | head -3
done' _ "${FILES[@]}"

printf '\n%s\n' "## Info"

TYPES_DEFINED=$( (grep -cE "^(export )?(type|interface) " "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  Types/Interfaces defined: %s\n' "$TYPES_DEFINED"

ANY_USAGE=$( (grep -oE ": any|as any|<any>" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  'any' usage count: %s\n' "$ANY_USAGE"

UNKNOWN_USAGE=$( (grep -oE ": unknown" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  'unknown' usage count: %s\n' "$UNKNOWN_USAGE"

TYPE_GUARDS=$( (grep -cE "is [A-Z][a-zA-Z]+" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  Type guards: %s\n' "$TYPE_GUARDS"

printf '\n%s\n' "═══════════════════════════════════════════"
printf '  PASS: %d  FAIL: %d  WARN: %d\n' "$PASS" "$FAIL" "$WARN"
if [[ $FAIL -eq 0 ]]; then
    green "  RESULT: PASS"
else
    red "  RESULT: FAIL"
fi
printf '%s\n' "═══════════════════════════════════════════"

exit "$FAIL"
