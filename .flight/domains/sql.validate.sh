#!/usr/bin/env bash
# sql.validate.sh - Production SQL patterns for PostgreSQL/Supabase
# Generated by flight-domain-compile from sql.flight
set -euo pipefail

# Script location for sourcing helpers
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Default: common file patterns
DEFAULT_PATTERNS="**/*.sql **/*.js **/*.ts **/*.tsx **/*.py"
PASS=0
FAIL=0
WARN=0

red() { printf '\033[31m%s\033[0m\n' "$1"; }
green() { printf '\033[32m%s\033[0m\n' "$1"; }
yellow() { printf '\033[33m%s\033[0m\n' "$1"; }

check() {
    local name="$1"
    shift
    local result
    result=$("$@" 2>/dev/null) || true
    if [[ -z "$result" ]]; then
        green "✅ $name"
        ((PASS++)) || true
    else
        red "❌ $name"
        printf '%s\n' "$result" | head -10 | sed 's/^/   /'
        ((FAIL++)) || true
    fi
}

warn() {
    local name="$1"
    shift
    local result
    result=$("$@" 2>/dev/null) || true
    if [[ -z "$result" ]]; then
        green "✅ $name"
        ((PASS++)) || true
    else
        yellow "⚠️  $name"
        printf '%s\n' "$result" | head -5 | sed 's/^/   /'
        ((WARN++)) || true
    fi
}

printf '%s\n' "═══════════════════════════════════════════"
printf '%s\n' "  SQL Domain Validation"
printf '%s\n' "═══════════════════════════════════════════"
printf '\n'

# Source exclusions helper if available
if [[ -f "$SCRIPT_DIR/../exclusions.sh" ]]; then
    source "$SCRIPT_DIR/../exclusions.sh"
    FLIGHT_HAS_EXCLUSIONS=true
else
    FLIGHT_HAS_EXCLUSIONS=false
fi

# Handle arguments or use defaults
if [[ $# -gt 0 ]]; then
    FILES=("$@")
elif [[ "$FLIGHT_HAS_EXCLUSIONS" == true ]]; then
    # Use exclusions-aware file discovery
    mapfile -t FILES < <(flight_get_files "*.sql" "*.js" "*.ts" "*.tsx" "*.py")
else
    # Fallback: use find (works on bash 3.2+, no globstar needed)
    mapfile -t FILES < <(find . -type f \( -name "*.sql" -o -name "*.js" -o -name "*.ts" -o -name "*.tsx" -o -name "*.py" \) -not -path "*/node_modules/*" -not -path "*/.git/*" -not -path "*/dist/*" -not -path "*/build/*" 2>/dev/null | sort)
fi

if [[ ${#FILES[@]} -eq 0 ]]; then
    yellow "No files found matching default patterns"
    printf '%s\n' "  Patterns: **/*.sql **/*.js **/*.ts **/*.tsx **/*.py..."
    printf '\n'
    green "  RESULT: SKIP (no files)"
    exit 0
fi

printf 'Files: %d\n\n' "${#FILES[@]}"

printf '\n%s\n' "## NEVER Rules"

# N1: SELECT *
check "N1: SELECT *" \
    grep -Ein "SELECT\\s+\\*\\s+FROM" "${FILES[@]}"

# N2: String Interpolation in SQL
check "N2: String Interpolation in SQL" \
    bash -c 'for f in "$@"; do
  case "$f" in
    *.js|*.ts|*.tsx)
      # Template literals with SQL keywords
      grep -En '"'"'\`[^\`]*SELECT.*\$\{|\`[^\`]*INSERT.*\$\{|\`[^\`]*UPDATE.*\$\{|\`[^\`]*DELETE.*\$\{'"'"' "$f" 2>/dev/null
      # String concat with SQL
      grep -En "SELECT.*\"\\s*\\+|INSERT.*\"\\s*\\+|UPDATE.*\"\\s*\\+|DELETE.*\"\\s*\\+" "$f" 2>/dev/null
      ;;
    *.py)
      # Python f-strings with SQL
      grep -En '"'"'f"[^"]*SELECT.*\{|f"[^"]*INSERT.*\{|f"[^"]*UPDATE.*\{'"'"' "$f" 2>/dev/null
      ;;
  esac
done | head -10' _ "${FILES[@]}"

# N3: UPDATE/DELETE Without WHERE
check "N3: UPDATE/DELETE Without WHERE" \
    bash -c 'for f in "$@"; do
  # DELETE FROM table; without WHERE
  grep -Ein '"'"'DELETE\s+FROM\s+\w+\s*;'"'"' "$f" 2>/dev/null
  # UPDATE without WHERE on same line (basic check)
  grep -Ein '"'"'UPDATE\s+\w+\s+SET\s+.*;'"'"' "$f" 2>/dev/null | grep -iv '"'"'WHERE'"'"'
done | head -5' _ "${FILES[@]}"

# N4: LIKE with Leading Wildcard
check "N4: LIKE with Leading Wildcard" \
    grep -Ein "LIKE\\s+['\"]%[^'\"]+['\"]" "${FILES[@]}"

# N5: Functions on Columns in WHERE
check "N5: Functions on Columns in WHERE" \
    grep -Ein "WHERE.*(YEAR|MONTH|DAY|LOWER|UPPER|TRIM)\\s*\\(" "${FILES[@]}"

# N6: Large OFFSET Values
check "N6: Large OFFSET Values" \
    grep -Ein "OFFSET\\s+[0-9]{4,}|OFFSET\\s+\\\$" "${FILES[@]}"

# N7: Plain Text Password Column
check "N7: Plain Text Password Column" \
    bash -c 'for f in "$@"; do
  case "$f" in
    *.sql)
      grep -Ein '"'"'password\s+(varchar|text|char)'"'"' "$f" 2>/dev/null | grep -iv '"'"'password_hash\|password_digest\|hashed_password'"'"'
      ;;
  esac
done' _ "${FILES[@]}"

# N8: timestamp Without Timezone
check "N8: timestamp Without Timezone" \
    bash -c 'for f in "$@"; do
  case "$f" in
    *.sql)
      grep -Ein '"'"'\stimestamp\s'"'"' "$f" 2>/dev/null | grep -iv '"'"'timestamptz\|timestamp with time zone'"'"'
      ;;
  esac
done' _ "${FILES[@]}"

# N9: float/real for Money
check "N9: float/real for Money" \
    bash -c 'for f in "$@"; do
  case "$f" in
    *.sql)
      grep -Ein '"'"'(price|cost|total|amount|balance|fee|rate)\s+(float|real|double)'"'"' "$f" 2>/dev/null
      ;;
  esac
done' _ "${FILES[@]}"

printf '\n%s\n' "## SHOULD Rules"

# S1: Boolean Without NOT NULL DEFAULT
warn "S1: Boolean Without NOT NULL DEFAULT" \
    bash -c 'for f in "$@"; do
  case "$f" in
    *.sql)
      grep -Ein '"'"'\s+boolean\s*[,)]'"'"' "$f" 2>/dev/null | grep -iv '"'"'NOT NULL'"'"'
      ;;
  esac
done' _ "${FILES[@]}"

# S2: Missing RLS on user_id Tables
warn "S2: Missing RLS on user_id Tables" \
    bash -c 'for f in "$@"; do
  case "$f" in
    *.sql)
      if grep -qi '"'"'user_id.*REFERENCES\|user_id\s+uuid'"'"' "$f"; then
        if ! grep -qi '"'"'ENABLE ROW LEVEL SECURITY'"'"' "$f"; then
          echo "$f: has user_id but no RLS"
        fi
      fi
      ;;
  esac
done' _ "${FILES[@]}"

# S3: Missing Index on Foreign Key
warn "S3: Missing Index on Foreign Key" \
    bash -c 'for f in "$@"; do
  case "$f" in
    *.sql)
      grep -Eo '"'"'[a-z_]+\s+uuid\s+REFERENCES'"'"' "$f" 2>/dev/null | while read -r line; do
        col=$(echo "$line" | awk '"'"'{print $1}'"'"')
        if ! grep -qi "INDEX.*$col" "$f"; then
          echo "$f: $col has FK but no index"
        fi
      done
      ;;
  esac
done | head -5' _ "${FILES[@]}"

# S4: N+1 Query Pattern
warn "S4: N+1 Query Pattern" \
    bash -c 'for f in "$@"; do
  case "$f" in
    *.js|*.ts|*.tsx|*.py)
      awk '"'"'/for\s*\(|while\s*\(|for .* in/{inloop=5} inloop>0{inloop--; if(/await.*(query|select|execute|from\()/) print FILENAME":"NR": "$0}'"'"' "$f"
      ;;
  esac
done | head -5' _ "${FILES[@]}"

# S5: Multiple Writes Without Transaction
warn "S5: Multiple Writes Without Transaction" \
    bash -c 'for f in "$@"; do
  case "$f" in
    *.js|*.ts|*.tsx|*.py)
      inserts=$(grep -c '"'"'INSERT INTO\|UPDATE.*SET'"'"' "$f" 2>/dev/null || echo 0)
      if [ "$inserts" -gt 2 ]; then
        if ! grep -qi '"'"'BEGIN\|transaction\|\.transaction'"'"' "$f"; then
          echo "$f: $inserts writes without transaction"
        fi
      fi
      ;;
  esac
done' _ "${FILES[@]}"

# S6: Supabase .select() Without Columns
warn "S6: Supabase .select() Without Columns" \
    grep -En "\\.select\\(\\s*\\)" "${FILES[@]}"

printf '\n%s\n' "═══════════════════════════════════════════"
printf '  PASS: %d  FAIL: %d  WARN: %d\n' "$PASS" "$FAIL" "$WARN"
if [[ $FAIL -eq 0 ]]; then
    green "  RESULT: PASS"
else
    red "  RESULT: FAIL"
fi
printf '%s\n' "═══════════════════════════════════════════"

exit "$FAIL"
