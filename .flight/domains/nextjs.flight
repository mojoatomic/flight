# nextjs.flight - Next.js 14+ App Router patterns
# Source: Migrated from nextjs.md and nextjs.validate.sh

domain: nextjs
version: 1.0.0
description: >
  Next.js 14+ App Router patterns for server components, routing, and data fetching.
  Enforces proper client/server boundaries, prevents secret exposure, and promotes
  parallel data fetching.

file_patterns:
  - "app/**/*.tsx"
  - "app/**/*.ts"
  - "app/*.tsx"
  - "app/*.ts"

exclude_patterns:
  - "**/node_modules/**"
  - "**/dist/**"
  - "**/build/**"
  - "**/.next/**"
  - "**/.git/**"

suppression:
  comment: "flight:ok"
  guidance: |
    Add `// flight:ok` comment on the same line to suppress.
    Use sparingly. Document why the suppression is acceptable.

# ===========================================================================
# RULES
# ===========================================================================
# Next.js App Router-SPECIFIC rules. Universal code hygiene rules are in
# code-hygiene.flight.
#
# ID format: {severity_prefix}{number}
#   N = NEVER (check - fails build)
#   S = SHOULD (warn - advisory)
#   G = GUIDANCE (not checked)
# ===========================================================================

rules:

  # =========================================================================
  # NEVER - App Router violations (validator will reject)
  # =========================================================================

  N1:
    title: "'use client' in page.tsx Files"
    severity: NEVER
    mechanical: true
    description: >
      Page components should be server components by default. Adding 'use client'
      at the page level kills SSR benefits for the entire page tree.
    check:
      type: script
      code: |
        for f in "$@"; do
            if [[ "$f" == *page.tsx ]]; then
                if head -5 "$f" | grep -q "'use client'\|\"use client\""; then
                    echo "$f: page.tsx should be server component"
                fi
            fi
        done
    note: |
      Push client boundaries down to the smallest interactive components.
      Keep page.tsx as server component to benefit from SSR and server-side data fetching.
    examples:
      bad:
        - |
          // page.tsx
          'use client';
          export default function Page() { ... }  // Entire tree is now client
      good:
        - |
          // page.tsx (server by default)
          export default function Page() {
            return (
              <div>
                <StaticContent />
                <InteractiveWidget />  {/* Only this file has 'use client' */}
              </div>
            );
          }

  N2:
    title: React Hooks in Server Components
    severity: NEVER
    mechanical: true
    description: >
      useState, useEffect, and other React hooks cannot be used in server components.
      Files without 'use client' directive are server components.
    check:
      type: script
      code: |
        for f in "$@"; do
            if ! grep -q "'use client'\|\"use client\"" "$f"; then
                if grep -qE 'useState|useEffect|useRef|useCallback|useMemo|useReducer' "$f"; then
                    echo "$f: has hooks but no 'use client'"
                fi
            fi
        done
    note: |
      Server components run on the server where React hooks don't work.
      Either add 'use client' or refactor to use server-side data fetching.
    examples:
      bad:
        - |
          // No 'use client' = server component
          export default function Page() {
            const [count, setCount] = useState(0);  // Error!
          }
      good:
        - |
          // Server component with direct data fetching
          export default async function Page() {
            const data = await fetchData();
            return <Display data={data} />;
          }

  N3:
    title: useEffect Fetch for Initial Page Data
    severity: NEVER
    mechanical: true
    description: >
      Don't use useEffect to fetch initial page data. Server components can
      fetch data directly, avoiding the extra round trip.
    check:
      type: grep
      pattern: 'useEffect.*fetch\(|useEffect.*axios|useEffect.*useSWR'
      flags: -lE
    note: |
      Client-side fetch in useEffect means: render empty → fetch → re-render.
      Server component fetch means: fetch → render with data. One round trip saved.
    examples:
      bad:
        - |
          'use client';
          export default function Page() {
            const [data, setData] = useState(null);
            useEffect(() => {
              fetch('/api/data').then(r => r.json()).then(setData);
            }, []);
          }
      good:
        - |
          // Server component fetches directly
          export default async function Page() {
            const data = await fetch('https://api.example.com/data');
            return <Display data={data} />;
          }

  N4:
    title: process.env in Client Components
    severity: NEVER
    mechanical: true
    description: >
      Non-NEXT_PUBLIC_ environment variables are not available in client components
      and would expose secrets if they were. Only NEXT_PUBLIC_ vars are safe client-side.
    check:
      type: script
      code: |
        for f in "$@"; do
            if grep -q "'use client'\|\"use client\"" "$f"; then
                if grep -E 'process\.env\.' "$f" | grep -v 'NEXT_PUBLIC_'; then
                    echo "$f: uses non-public env in client"
                fi
            fi
        done
    note: |
      NEXT_PUBLIC_ vars are inlined at build time and safe for client.
      All other env vars are server-only and undefined in client bundles.
    examples:
      bad:
        - |
          'use client';
          const API_KEY = process.env.API_KEY;  // undefined or exposed!
      good:
        - |
          // Server component or route handler
          const API_KEY = process.env.API_KEY;  // Safe, server only
        - |
          'use client';
          const PUBLIC_URL = process.env.NEXT_PUBLIC_API_URL;  // Safe

  N5:
    title: "'any' Type in Route Handlers"
    severity: NEVER
    mechanical: true
    description: >
      Route handlers should validate input, not use 'any'. External data
      from requests is unknown until validated.
    check:
      type: script
      code: |
        for f in "$@"; do
            if [[ "$f" == *route.ts ]]; then
                if grep -n ': any' "$f"; then
                    echo "$f"
                fi
            fi
        done
    note: |
      'any' disables type checking. Route handlers receive untrusted input.
      Use 'unknown' and validate with Zod or similar.
    examples:
      bad:
        - |
          export async function POST(req: Request) {
            const body: any = await req.json();
          }
      good:
        - |
          export async function POST(req: Request) {
            const body: unknown = await req.json();
            const validated = orderSchema.parse(body);
          }

  N6:
    title: Hardcoded Multi-segment Routes
    severity: NEVER
    mechanical: true
    description: >
      Hardcoded route strings with multiple segments are fragile.
      Use centralized route constants for maintainability.
    check:
      type: grep
      pattern: "href=['\"][^'\"]+/[^'\"]+/[^'\"]+['\"]|push\\(['\"][^'\"]+/[^'\"]+/[^'\"]+['\"]\\)"
      flags: -En
    note: |
      When routes change, hardcoded strings break silently.
      Centralized constants give you type safety and single-point updates.
    examples:
      bad:
        - "<Link href=\"/dashboard/settings/profile\">"
        - "router.push('/dashboard/settings/profile');"
      good:
        - |
          // lib/routes.ts
          export const routes = {
            profile: '/dashboard/settings/profile',
          } as const;

          <Link href={routes.profile}>

  N7:
    title: console.log in App Directory
    severity: NEVER
    mechanical: true
    description: >
      Console statements in production code indicate incomplete development
      or forgotten debugging. Remove before deploying.
    check:
      type: grep
      pattern: 'console\.log'
      flags: -rn
    note: |
      Console.log in server components runs on server logs.
      In client components it clutters browser console.
      Use proper logging or remove before commit.
    examples:
      bad:
        - "console.log('data:', data);"
      good:
        - "// Use proper logging service for production"

  N8:
    title: Fat Route Handlers (>50 lines)
    severity: NEVER
    mechanical: true
    description: >
      Route handlers should be thin orchestrators. Extract business logic
      to separate functions for testability and reuse.
    check:
      type: script
      code: |
        for f in "$@"; do
            if [[ "$f" == *route.ts ]]; then
                lines=$(wc -l < "$f")
                if [ "$lines" -gt 50 ]; then
                    echo "$f: $lines lines (max 50)"
                fi
            fi
        done
    note: |
      Fat handlers are hard to test and reason about.
      Extract validation, business logic, and responses to separate functions.
    examples:
      bad:
        - |
          export async function POST(req: Request) {
            // 200 lines of validation, db calls, emails...
          }
      good:
        - |
          export async function POST(req: Request) {
            const body = await req.json();
            const result = await createOrder(body);  // Logic extracted
            return Response.json(result);
          }

  # =========================================================================
  # SHOULD - Best practices (validator warns)
  # =========================================================================

  S1:
    title: Dynamic Routes Should Use notFound()
    severity: SHOULD
    mechanical: true
    description: >
      Dynamic route pages ([id], [slug]) should call notFound() when the
      resource doesn't exist, rendering the not-found.tsx boundary.
    check:
      type: script
      code: |
        for f in "$@"; do
            if [[ "$f" == *\[*\]*page.tsx ]]; then
                if ! grep -q 'notFound' "$f"; then
                    echo "$f: dynamic route without notFound()"
                fi
            fi
        done
    note: |
      Without notFound(), missing resources may render broken pages or
      show confusing errors. notFound() renders a proper 404.
    examples:
      good:
        - |
          import { notFound } from 'next/navigation';

          export default async function UserPage({ params }: Props) {
            const user = await getUser(params.id);
            if (!user) notFound();  // Renders not-found.tsx
            return <UserProfile user={user} />;
          }

  S2:
    title: Consider Promise.all for Independent Fetches
    severity: SHOULD
    mechanical: true
    description: >
      Multiple sequential awaits that don't depend on each other should use
      Promise.all to fetch in parallel and reduce load time.
    check:
      type: script
      code: |
        for f in "$@"; do
            count=$(grep -c 'await ' "$f" 2>/dev/null || echo 0)
            if [ "$count" -gt 3 ]; then
                if ! grep -q 'Promise.all' "$f"; then
                    echo "$f: $count awaits without Promise.all"
                fi
            fi
        done
    note: |
      Sequential awaits are waterfall requests. If fetches are independent,
      Promise.all runs them in parallel, cutting total time.
    examples:
      bad:
        - |
          const user = await fetchUser();
          const config = await fetchConfig();  // Waits for user unnecessarily
          const posts = await fetchPosts();    // Waits for config unnecessarily
      good:
        - |
          const [user, config, posts] = await Promise.all([
            fetchUser(),
            fetchConfig(),
            fetchPosts(),
          ]);

  S3:
    title: Pages Should Have loading.tsx
    severity: SHOULD
    mechanical: true
    description: >
      Directories with page.tsx should have loading.tsx to show instant
      loading state while the page suspends.
    check:
      type: script
      code: |
        find app -name 'page.tsx' 2>/dev/null | while read page; do
            dir=$(dirname "$page")
            if [ ! -f "$dir/loading.tsx" ]; then
                echo "$dir: missing loading.tsx"
            fi
        done | head -5
    note: |
      Without loading.tsx, users see nothing while page data loads.
      loading.tsx shows immediately, improving perceived performance.
    examples:
      good:
        - |
          app/
            dashboard/
              page.tsx
              loading.tsx    # Shows while page.tsx suspends

  S4:
    title: Pages Should Have error.tsx
    severity: SHOULD
    mechanical: true
    description: >
      Directories with page.tsx should have error.tsx to handle errors
      gracefully instead of crashing the entire app.
    check:
      type: script
      code: |
        find app -name 'page.tsx' 2>/dev/null | while read page; do
            dir=$(dirname "$page")
            if [ ! -f "$dir/error.tsx" ]; then
                echo "$dir: missing error.tsx"
            fi
        done | head -5
    note: |
      Without error boundaries, errors bubble up and crash larger sections.
      error.tsx contains errors and allows retry.
    examples:
      good:
        - |
          app/
            dashboard/
              page.tsx
              error.tsx      # Catches errors, allows recovery

  S5:
    title: Server-Only Import for Sensitive Files
    severity: SHOULD
    mechanical: true
    description: >
      Database and auth files should import 'server-only' to prevent
      accidental import in client components.
    check:
      type: script
      code: |
        for f in lib/db.ts lib/auth.ts lib/database.ts; do
            if [ -f "$f" ]; then
                if ! grep -q "import 'server-only'" "$f"; then
                    echo "$f: should import 'server-only'"
                fi
            fi
        done
    note: |
      'server-only' package causes build error if imported in client component.
      This prevents accidental exposure of server secrets.
    examples:
      good:
        - |
          // lib/db.ts
          import 'server-only';
          export const db = new PrismaClient();

  # =========================================================================
  # GUIDANCE - Design patterns (not mechanically checked)
  # =========================================================================

  G1:
    title: App Directory File Structure
    severity: GUIDANCE
    mechanical: false
    description: >
      Recommended file structure for Next.js App Router projects.
    note: |
      app/
      ├── (marketing)/           # Route group for marketing pages
      │   ├── page.tsx           # Home
      │   └── layout.tsx
      ├── (dashboard)/           # Route group for authenticated pages
      │   ├── dashboard/
      │   │   ├── page.tsx
      │   │   ├── loading.tsx
      │   │   └── error.tsx
      │   └── layout.tsx
      ├── api/
      │   └── webhooks/
      │       └── stripe/
      │           └── route.ts
      ├── layout.tsx             # Root layout
      ├── not-found.tsx          # Global 404
      └── error.tsx              # Global error

      lib/
      ├── db.ts                  # Database (with server-only)
      ├── auth.ts                # Auth helpers
      ├── routes.ts              # Route constants
      └── validations/
          └── user.ts            # Zod schemas

  G2:
    title: Server Component with Suspense
    severity: GUIDANCE
    mechanical: false
    description: >
      Pattern for async server components with Suspense boundaries.
    note: |
      // app/users/page.tsx
      import { Suspense } from 'react';

      export default function UsersPage() {
        return (
          <div>
            <h1>Users</h1>
            <Suspense fallback={<UserListSkeleton />}>
              <UserList />
            </Suspense>
          </div>
        );
      }

      // app/users/user-list.tsx
      export async function UserList() {
        const users = await getUsers();  // This suspends
        return (
          <ul>
            {users.map(user => <li key={user.id}>{user.name}</li>)}
          </ul>
        );
      }

  G3:
    title: Route Handler with Validation
    severity: GUIDANCE
    mechanical: false
    description: >
      Pattern for type-safe route handlers with Zod validation.
    note: |
      // app/api/users/route.ts
      import { NextResponse } from 'next/server';
      import { z } from 'zod';

      const createUserSchema = z.object({
        email: z.string().email(),
        name: z.string().min(1).max(100),
      });

      export async function POST(request: Request) {
        const body: unknown = await request.json();
        const parsed = createUserSchema.safeParse(body);

        if (!parsed.success) {
          return NextResponse.json(
            { error: 'Validation failed', details: parsed.error.flatten() },
            { status: 400 }
          );
        }

        const user = await createUser(parsed.data);
        return NextResponse.json(user, { status: 201 });
      }

  G4:
    title: Middleware Pattern
    severity: GUIDANCE
    mechanical: false
    description: >
      Pattern for Next.js middleware with auth checks and path matching.
    note: |
      // middleware.ts
      import { NextResponse } from 'next/server';
      import type { NextRequest } from 'next/server';

      export function middleware(request: NextRequest) {
        const { pathname } = request.nextUrl;

        if (pathname.startsWith('/dashboard')) {
          const token = request.cookies.get('token');
          if (!token) {
            return NextResponse.redirect(new URL('/login', request.url));
          }
        }

        return NextResponse.next();
      }

      export const config = {
        matcher: ['/dashboard/:path*', '/api/:path*'],
      };

# ===========================================================================
# INFO CHECKS - Statistics for reporting (not pass/fail)
# ===========================================================================

info:
  server_components:
    pattern: "'use client'|\"use client\""
    flags: -rL
    label: "Server components"
    aggregate: count

  client_components:
    pattern: "'use client'|\"use client\""
    flags: -rl
    label: "Client components"
    aggregate: count

  route_handlers:
    pattern: 'route\.ts$'
    flags: -E
    label: "Route handlers"
    aggregate: count

  server_actions:
    pattern: "'use server'"
    flags: -rl
    label: "Server action files"
    aggregate: count

# ===========================================================================
# ANTI-PATTERNS - Quick reference table (documentation only)
# ===========================================================================

anti_patterns:
  - pattern: "'use client' on page"
    description: "Kills SSR benefits"
    fix: "Push client boundary down"

  - pattern: "useEffect fetch"
    description: "Extra round trip"
    fix: "Server component fetch"

  - pattern: "process.env.X client"
    description: "Secrets exposed"
    fix: "Server only or NEXT_PUBLIC_"

  - pattern: "Sequential awaits"
    description: "Slow page load"
    fix: "Promise.all for independent"

  - pattern: "No loading.tsx"
    description: "Layout shift"
    fix: "Add loading boundary"

  - pattern: "No error.tsx"
    description: "Crashes bubble up"
    fix: "Add error boundary"

  - pattern: "Fat route handlers"
    description: "Hard to test"
    fix: "Extract to functions"

  - pattern: "Hardcoded paths"
    description: "Refactor hell"
    fix: "Route constants"

  - pattern: "'any' in handlers"
    description: "No validation"
    fix: "Zod + unknown"

# ===========================================================================
# SOURCES
# ===========================================================================

sources:
  - title: "Next.js Documentation - App Router"
    url: "https://nextjs.org/docs/app"

  - title: "Next.js Documentation - Server Components"
    url: "https://nextjs.org/docs/app/building-your-application/rendering/server-components"

  - title: "Next.js Documentation - Route Handlers"
    url: "https://nextjs.org/docs/app/building-your-application/routing/route-handlers"
