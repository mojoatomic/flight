# nextjs.flight - Next.js 14+ App Router patterns

domain: nextjs
version: 1.1.0
schema_version: 2
description: >
  Next.js 14+ App Router patterns for server components, routing, and data fetching.
  Enforces proper client/server boundaries, prevents secret exposure, and promotes
  parallel data fetching.

provenance:
  last_full_audit: "2026-01-16"
  audited_by: "flight-research"
  next_audit_due: "2026-07-16"

  sources_consulted:
    - url: "https://nextjs.org/docs/app"
      accessed: "2026-01-16"
      note: "Next.js App Router documentation"
    - url: "https://nextjs.org/docs/app/building-your-application/rendering/server-components"
      accessed: "2026-01-16"
      note: "Server Components rendering documentation"
    - url: "https://nextjs.org/docs/app/building-your-application/routing/route-handlers"
      accessed: "2026-01-16"
      note: "Route Handlers documentation"
    - url: "https://nextjs.org/docs/app/building-your-application/configuring/environment-variables"
      accessed: "2026-01-16"
      note: "Environment Variables documentation"

  coverage:
    apis_covered:
      - "Server Components vs Client Components"
      - "Route Handlers (app/api)"
      - "Environment variable handling"
      - "Error and loading boundaries"
      - "Dynamic routes with notFound()"
    known_gaps:
      - "Server Actions not fully covered"
      - "Parallel Routes not covered"
      - "Intercepting Routes not covered"

file_patterns:
  - "app/**/*.tsx"
  - "app/**/*.ts"
  - "app/*.tsx"
  - "app/*.ts"

exclude_patterns:
  - "**/node_modules/**"
  - "**/dist/**"
  - "**/build/**"
  - "**/.next/**"
  - "**/.git/**"

# ===========================================================================
# RULES
# ===========================================================================
# Next.js App Router-SPECIFIC rules. Universal code hygiene rules are in
# code-hygiene.flight.
#
# ID format: {severity_prefix}{number}
#   N = NEVER (check - fails build)
#   S = SHOULD (warn - advisory)
#   G = GUIDANCE (not checked)
# ===========================================================================

rules:

  # =========================================================================
  # NEVER - App Router violations (validator will reject)
  # =========================================================================

  N0:
    title: Inconsistent Source Directory Structure
    severity: NEVER
    mechanical: true
    provenance:
      last_verified: "2026-01-23"
      confidence: high
      re_verify_after: "2027-01-23"
      sources:
        - url: "https://nextjs.org/docs/app/building-your-application/configuring/src-directory"
          accessed: "2026-01-23"
          quote: "Next.js also supports storing application code inside an optional src directory."
    description: >
      If src/ directory exists, all application code must live under src/.
      No parallel directories at root level (lib/ alongside src/lib/).
      This prevents AI assistants from creating duplicate file structures.
    check:
      type: script
      code: |
        # Only check if src/ exists (indicates src/ convention chosen)
        if [ -d "src" ]; then
            found=0
            # Check for parallel directories that should be under src/
            for dir in lib components types utils hooks services helpers; do
                if [ -d "$dir" ] && [ -d "src/$dir" ]; then
                    if [ $found -eq 0 ]; then
                        echo "Split directory structure detected:"
                        found=1
                    fi
                    echo "  $dir/ exists alongside src/$dir/"
                elif [ -d "$dir" ] && [ -d "src" ]; then
                    # Even if src/$dir doesn't exist, root $dir is wrong when src/ exists
                    if [ $found -eq 0 ]; then
                        echo "Split directory structure detected:"
                        found=1
                    fi
                    echo "  $dir/ should be src/$dir/"
                fi
            done
        fi
    note: |
      When src/ directory exists, Next.js expects application code under src/.
      Path aliases like @/* typically map to ./src/*.

      Having both lib/ and src/lib/ causes:
      - Import confusion (which lib/ is correct?)
      - AI assistants creating files in wrong locations
      - Maintenance nightmare with duplicate code
    examples:
      bad:
        - |
          # Split structure - NEVER do this
          src/
            app/
            components/
          lib/           # Wrong! Should be src/lib/
          components/    # Wrong! Duplicate of src/components/
      good:
        - |
          # All code under src/
          src/
            app/
            lib/
            components/
            types/
        - |
          # Or no src/ at all (root convention)
          app/
          lib/
          components/
          types/

  N1:
    title: "'use client' in page.tsx Files"
    severity: NEVER
    mechanical: true
    provenance:
      last_verified: "2026-01-16"
      confidence: high
      re_verify_after: "2027-01-16"
      sources:
        - url: "https://nextjs.org/docs/app/building-your-application/rendering/server-components"
          accessed: "2026-01-16"
          quote: "By default, Next.js uses Server Components... move the 'use client' directive down in the tree."
    description: >
      Page components should be server components by default. Adding 'use client'
      at the page level kills SSR benefits for the entire page tree.
    check:
      type: script
      code: |
        for f in "$@"; do
            if [[ "$f" == *page.tsx ]]; then
                if head -5 "$f" | grep -q "'use client'\|\"use client\""; then
                    echo "$f: page.tsx should be server component"
                fi
            fi
        done
    note: |
      Push client boundaries down to the smallest interactive components.
      Keep page.tsx as server component to benefit from SSR and server-side data fetching.
    examples:
      bad:
        - |
          // page.tsx
          'use client';
          export default function Page() { ... }  // Entire tree is now client
      good:
        - |
          // page.tsx (server by default)
          export default function Page() {
            return (
              <div>
                <StaticContent />
                <InteractiveWidget />  {/* Only this file has 'use client' */}
              </div>
            );
          }

  N2:
    title: React Hooks in Server Components
    severity: NEVER
    mechanical: true
    provenance:
      last_verified: "2026-01-16"
      confidence: high
      re_verify_after: "2027-01-16"
      sources:
        - url: "https://nextjs.org/docs/app/building-your-application/rendering/server-components"
          accessed: "2026-01-16"
          quote: "Server Components do not support hooks like useState or useEffect."
    description: >
      useState, useEffect, and other React hooks cannot be used in server components.
      Files without 'use client' directive are server components.
    check:
      type: script
      code: |
        for f in "$@"; do
            if ! grep -q "'use client'\|\"use client\"" "$f"; then
                if grep -qE 'useState|useEffect|useRef|useCallback|useMemo|useReducer' "$f"; then
                    echo "$f: has hooks but no 'use client'"
                fi
            fi
        done
    note: |
      Server components run on the server where React hooks don't work.
      Either add 'use client' or refactor to use server-side data fetching.
    examples:
      bad:
        - |
          // No 'use client' = server component
          export default function Page() {
            const [count, setCount] = useState(0);  // Error!
          }
      good:
        - |
          // Server component with direct data fetching
          export default async function Page() {
            const data = await fetchData();
            return <Display data={data} />;
          }

  N3:
    title: useEffect Fetch for Initial Page Data
    severity: NEVER
    mechanical: true
    provenance:
      last_verified: "2026-01-16"
      confidence: high
      re_verify_after: "2027-01-16"
      sources:
        - url: "https://nextjs.org/docs/app/building-your-application/data-fetching"
          accessed: "2026-01-16"
          quote: "We recommend fetching data in Server Components... reduces client-server waterfalls."
    description: >
      Don't use useEffect to fetch initial page data. Server components can
      fetch data directly, avoiding the extra round trip.
    check:
      type: ast
      language: typescript
      query: |
        (call_expression
          function: (identifier) @fn
          arguments: (arguments
            (arrow_function
              body: (statement_block) @body))
          (#eq? @fn "useEffect")
          (#match? @body "\\bfetch\\s*\\(|\\baxios\\.")) @violation
    note: |
      Client-side fetch in useEffect means: render empty → fetch → re-render.
      Server component fetch means: fetch → render with data. One round trip saved.
    examples:
      bad:
        - |
          'use client';
          export default function Page() {
            const [data, setData] = useState(null);
            useEffect(() => {
              fetch('/api/data').then(r => r.json()).then(setData);
            }, []);
          }
      good:
        - |
          // Server component fetches directly
          export default async function Page() {
            const data = await fetch('https://api.example.com/data');
            return <Display data={data} />;
          }

  N4:
    title: process.env in Client Components
    severity: NEVER
    mechanical: true
    provenance:
      last_verified: "2026-01-16"
      confidence: high
      re_verify_after: "2027-01-16"
      sources:
        - url: "https://nextjs.org/docs/app/building-your-application/configuring/environment-variables"
          accessed: "2026-01-16"
          quote: "By default, environment variables are only available on the server... prefix with NEXT_PUBLIC_ to make available in the browser."
    description: >
      Non-NEXT_PUBLIC_ environment variables are not available in client components
      and would expose secrets if they were. Only NEXT_PUBLIC_ vars are safe client-side.
    check:
      type: script
      code: |
        for f in "$@"; do
            if grep -q "'use client'\|\"use client\"" "$f"; then
                if grep -E 'process\.env\.' "$f" | grep -v 'NEXT_PUBLIC_'; then
                    echo "$f: uses non-public env in client"
                fi
            fi
        done
    note: |
      NEXT_PUBLIC_ vars are inlined at build time and safe for client.
      All other env vars are server-only and undefined in client bundles.
    examples:
      bad:
        - |
          'use client';
          const API_KEY = process.env.API_KEY;  // undefined or exposed!
      good:
        - |
          // Server component or route handler
          const API_KEY = process.env.API_KEY;  // Safe, server only
        - |
          'use client';
          const PUBLIC_URL = process.env.NEXT_PUBLIC_API_URL;  // Safe

  N5:
    title: "'any' Type in Route Handlers"
    severity: NEVER
    mechanical: true
    provenance:
      last_verified: "2026-01-16"
      confidence: high
      re_verify_after: "2027-01-16"
      sources:
        - url: "https://nextjs.org/docs/app/building-your-application/routing/route-handlers"
          accessed: "2026-01-16"
          quote: "TypeScript warning: Response.json() requires TypeScript 5.2 or higher."
    description: >
      Route handlers should validate input, not use 'any'. External data
      from requests is unknown until validated.
    check:
      type: script
      code: |
        for f in "$@"; do
            if [[ "$f" == *route.ts ]]; then
                if grep -n ': any' "$f"; then
                    echo "$f"
                fi
            fi
        done
    note: |
      'any' disables type checking. Route handlers receive untrusted input.
      Use 'unknown' and validate with Zod or similar.
    examples:
      bad:
        - |
          export async function POST(req: Request) {
            const body: any = await req.json();
          }
      good:
        - |
          export async function POST(req: Request) {
            const body: unknown = await req.json();
            const validated = orderSchema.parse(body);
          }

  N6:
    title: Hardcoded Multi-segment Routes
    severity: NEVER
    mechanical: true
    provenance:
      last_verified: "2026-01-16"
      confidence: medium
      re_verify_after: "2026-07-16"
      sources:
        - url: "https://nextjs.org/docs/app/building-your-application/routing"
          accessed: "2026-01-16"
          quote: "Next.js uses file-system based routing where folders define routes."
    description: >
      Hardcoded route strings with multiple segments are fragile.
      Use centralized route constants for maintainability.
    check:
      type: ast
      language: typescript
      query: |
        ; Match JSX href attributes with multi-segment paths
        (jsx_attribute
          (property_identifier) @attr
          (string (string_fragment) @path)
          (#eq? @attr "href")
          (#match? @path "^/[^/]+/[^/]+/")) @violation

        ; Match router.push() calls with multi-segment paths
        (call_expression
          function: (member_expression
            property: (property_identifier) @method)
          arguments: (arguments
            (string (string_fragment) @path2))
          (#eq? @method "push")
          (#match? @path2 "^/[^/]+/[^/]+/")) @violation
    note: |
      When routes change, hardcoded strings break silently.
      Centralized constants give you type safety and single-point updates.
    examples:
      bad:
        - "<Link href=\"/dashboard/settings/profile\">"
        - "router.push('/dashboard/settings/profile');"
      good:
        - |
          // lib/routes.ts
          export const routes = {
            profile: '/dashboard/settings/profile',
          } as const;

          <Link href={routes.profile}>

  N7:
    title: console.log in App Directory
    severity: NEVER
    mechanical: true
    provenance:
      last_verified: "2026-01-16"
      confidence: high
      re_verify_after: "2027-01-16"
      sources:
        - url: "https://eslint.org/docs/latest/rules/no-console"
          accessed: "2026-01-16"
          quote: "In JavaScript that is designed to be executed in the browser, it's considered a best practice to avoid using methods on console."
    description: >
      Console statements in production code indicate incomplete development
      or forgotten debugging. Remove before deploying.
    check:
      type: ast
      language: typescript
      query: |
        (call_expression
          function: (member_expression
            object: (identifier) @obj
            property: (property_identifier) @prop)
          (#eq? @obj "console")
          (#eq? @prop "log")) @violation
    note: |
      Console.log in server components runs on server logs.
      In client components it clutters browser console.
      Use proper logging or remove before commit.
    examples:
      bad:
        - "console.log('data:', data);"
      good:
        - "// Use proper logging service for production"

  N8:
    title: Fat Route Handlers (>100 lines)
    severity: NEVER
    mechanical: true
    provenance:
      last_verified: "2026-01-23"
      confidence: medium
      re_verify_after: "2026-07-23"
      sources:
        - url: "https://nextjs.org/docs/app/building-your-application/routing/route-handlers"
          accessed: "2026-01-16"
          quote: "Route Handlers can be nested inside the app directory... similar to page.tsx."
    description: >
      Route handlers should be thin orchestrators. Extract business logic
      to separate functions for testability and reuse. 100 lines allows for
      proper validation, auth, and error handling while flagging genuinely fat handlers.
    check:
      type: script
      code: |
        for f in "$@"; do
            if [[ "$f" == *route.ts ]]; then
                lines=$(wc -l < "$f")
                if [ "$lines" -gt 100 ]; then
                    echo "$f: $lines lines (max 100)"
                fi
            fi
        done
    note: |
      Fat handlers are hard to test and reason about.
      Extract validation, business logic, and responses to separate functions.
    examples:
      bad:
        - |
          export async function POST(req: Request) {
            // 200 lines of validation, db calls, emails...
          }
      good:
        - |
          export async function POST(req: Request) {
            const body = await req.json();
            const result = await createOrder(body);  // Logic extracted
            return Response.json(result);
          }

  # =========================================================================
  # SHOULD - Best practices (validator warns)
  # =========================================================================

  S1:
    title: Dynamic Routes Should Use notFound()
    severity: SHOULD
    mechanical: true
    provenance:
      last_verified: "2026-01-16"
      confidence: high
      re_verify_after: "2027-01-16"
      sources:
        - url: "https://nextjs.org/docs/app/api-reference/functions/not-found"
          accessed: "2026-01-16"
          quote: "The notFound function allows you to render the not-found file within a route segment."
    description: >
      Dynamic route pages ([id], [slug]) should call notFound() when the
      resource doesn't exist, rendering the not-found.tsx boundary.
    check:
      type: script
      code: |
        for f in "$@"; do
            if [[ "$f" == *\[*\]*page.tsx ]]; then
                if ! grep -q 'notFound' "$f"; then
                    echo "$f: dynamic route without notFound()"
                fi
            fi
        done
    note: |
      Without notFound(), missing resources may render broken pages or
      show confusing errors. notFound() renders a proper 404.
    examples:
      good:
        - |
          import { notFound } from 'next/navigation';

          export default async function UserPage({ params }: Props) {
            const user = await getUser(params.id);
            if (!user) notFound();  // Renders not-found.tsx
            return <UserProfile user={user} />;
          }

  S2:
    title: Consider Promise.all for Independent Fetches
    severity: SHOULD
    mechanical: true
    provenance:
      last_verified: "2026-01-16"
      confidence: high
      re_verify_after: "2027-01-16"
      sources:
        - url: "https://nextjs.org/docs/app/building-your-application/data-fetching/fetching"
          accessed: "2026-01-16"
          quote: "To reduce total time it takes to get data, you can fetch data in parallel."
    description: >
      Multiple sequential awaits that don't depend on each other should use
      Promise.all to fetch in parallel and reduce load time.
    check:
      type: script
      code: |
        for f in "$@"; do
            count=$(grep -c 'await ' "$f" 2>/dev/null || echo 0)
            if [ "$count" -gt 3 ]; then
                if ! grep -q 'Promise.all' "$f"; then
                    echo "$f: $count awaits without Promise.all"
                fi
            fi
        done
    note: |
      Sequential awaits are waterfall requests. If fetches are independent,
      Promise.all runs them in parallel, cutting total time.
    examples:
      bad:
        - |
          const user = await fetchUser();
          const config = await fetchConfig();  // Waits for user unnecessarily
          const posts = await fetchPosts();    // Waits for config unnecessarily
      good:
        - |
          const [user, config, posts] = await Promise.all([
            fetchUser(),
            fetchConfig(),
            fetchPosts(),
          ]);

  S3:
    title: Pages Should Have loading.tsx
    severity: SHOULD
    mechanical: true
    provenance:
      last_verified: "2026-01-16"
      confidence: high
      re_verify_after: "2027-01-16"
      sources:
        - url: "https://nextjs.org/docs/app/building-your-application/routing/loading-ui-and-streaming"
          accessed: "2026-01-16"
          quote: "The special file loading.js helps you create meaningful Loading UI with React Suspense."
    description: >
      Directories with page.tsx should have loading.tsx to show instant
      loading state while the page suspends.
    check:
      type: script
      code: |
        find app -name 'page.tsx' 2>/dev/null | while read page; do
            dir=$(dirname "$page")
            if [ ! -f "$dir/loading.tsx" ]; then
                echo "$dir: missing loading.tsx"
            fi
        done | head -5
    note: |
      Without loading.tsx, users see nothing while page data loads.
      loading.tsx shows immediately, improving perceived performance.
    examples:
      good:
        - |
          app/
            dashboard/
              page.tsx
              loading.tsx    # Shows while page.tsx suspends

  S4:
    title: Pages Should Have error.tsx
    severity: SHOULD
    mechanical: true
    provenance:
      last_verified: "2026-01-16"
      confidence: high
      re_verify_after: "2027-01-16"
      sources:
        - url: "https://nextjs.org/docs/app/building-your-application/routing/error-handling"
          accessed: "2026-01-16"
          quote: "The error.js file convention allows you to gracefully handle unexpected runtime errors."
    description: >
      Directories with page.tsx should have error.tsx to handle errors
      gracefully instead of crashing the entire app.
    check:
      type: script
      code: |
        find app -name 'page.tsx' 2>/dev/null | while read page; do
            dir=$(dirname "$page")
            if [ ! -f "$dir/error.tsx" ]; then
                echo "$dir: missing error.tsx"
            fi
        done | head -5
    note: |
      Without error boundaries, errors bubble up and crash larger sections.
      error.tsx contains errors and allows retry.
    examples:
      good:
        - |
          app/
            dashboard/
              page.tsx
              error.tsx      # Catches errors, allows recovery

  S5:
    title: Server-Only Import for Sensitive Files
    severity: SHOULD
    mechanical: true
    provenance:
      last_verified: "2026-01-16"
      confidence: high
      re_verify_after: "2027-01-16"
      sources:
        - url: "https://nextjs.org/docs/app/building-your-application/rendering/composition-patterns"
          accessed: "2026-01-16"
          quote: "To prevent this from happening, we can use the server-only package to give developers a build-time error."
    description: >
      Database and auth files should import 'server-only' to prevent
      accidental import in client components.
    check:
      type: script
      code: |
        for f in lib/db.ts lib/auth.ts lib/database.ts; do
            if [ -f "$f" ]; then
                if ! grep -q "import 'server-only'" "$f"; then
                    echo "$f: should import 'server-only'"
                fi
            fi
        done
    note: |
      'server-only' package causes build error if imported in client component.
      This prevents accidental exposure of server secrets.
    examples:
      good:
        - |
          // lib/db.ts
          import 'server-only';
          export const db = new PrismaClient();

  # =========================================================================
  # GUIDANCE - Design patterns (not mechanically checked)
  # =========================================================================

  G1:
    title: App Directory File Structure
    severity: GUIDANCE
    mechanical: false
    description: >
      Recommended file structure for Next.js App Router projects.
    note: |
      app/
      ├── (marketing)/           # Route group for marketing pages
      │   ├── page.tsx           # Home
      │   └── layout.tsx
      ├── (dashboard)/           # Route group for authenticated pages
      │   ├── dashboard/
      │   │   ├── page.tsx
      │   │   ├── loading.tsx
      │   │   └── error.tsx
      │   └── layout.tsx
      ├── api/
      │   └── webhooks/
      │       └── stripe/
      │           └── route.ts
      ├── layout.tsx             # Root layout
      ├── not-found.tsx          # Global 404
      └── error.tsx              # Global error

      lib/
      ├── db.ts                  # Database (with server-only)
      ├── auth.ts                # Auth helpers
      ├── routes.ts              # Route constants
      └── validations/
          └── user.ts            # Zod schemas

  G2:
    title: Server Component with Suspense
    severity: GUIDANCE
    mechanical: false
    description: >
      Pattern for async server components with Suspense boundaries.
    note: |
      // app/users/page.tsx
      import { Suspense } from 'react';

      export default function UsersPage() {
        return (
          <div>
            <h1>Users</h1>
            <Suspense fallback={<UserListSkeleton />}>
              <UserList />
            </Suspense>
          </div>
        );
      }

      // app/users/user-list.tsx
      export async function UserList() {
        const users = await getUsers();  // This suspends
        return (
          <ul>
            {users.map(user => <li key={user.id}>{user.name}</li>)}
          </ul>
        );
      }

  G3:
    title: Route Handler with Validation
    severity: GUIDANCE
    mechanical: false
    description: >
      Pattern for type-safe route handlers with Zod validation.
    note: |
      // app/api/users/route.ts
      import { NextResponse } from 'next/server';
      import { z } from 'zod';

      const createUserSchema = z.object({
        email: z.string().email(),
        name: z.string().min(1).max(100),
      });

      export async function POST(request: Request) {
        const body: unknown = await request.json();
        const parsed = createUserSchema.safeParse(body);

        if (!parsed.success) {
          return NextResponse.json(
            { error: 'Validation failed', details: parsed.error.flatten() },
            { status: 400 }
          );
        }

        const user = await createUser(parsed.data);
        return NextResponse.json(user, { status: 201 });
      }

  G4:
    title: Middleware Pattern
    severity: GUIDANCE
    mechanical: false
    description: >
      Pattern for Next.js middleware with auth checks and path matching.
    note: |
      // middleware.ts
      import { NextResponse } from 'next/server';
      import type { NextRequest } from 'next/server';

      export function middleware(request: NextRequest) {
        const { pathname } = request.nextUrl;

        if (pathname.startsWith('/dashboard')) {
          const token = request.cookies.get('token');
          if (!token) {
            return NextResponse.redirect(new URL('/login', request.url));
          }
        }

        return NextResponse.next();
      }

      export const config = {
        matcher: ['/dashboard/:path*', '/api/:path*'],
      };

# ===========================================================================
# INFO CHECKS - Statistics for reporting (not pass/fail)
# ===========================================================================

info:
  server_components:
    pattern: "'use client'|\"use client\""
    flags: -rL
    label: "Server components"
    aggregate: count

  client_components:
    pattern: "'use client'|\"use client\""
    flags: -rl
    label: "Client components"
    aggregate: count

  route_handlers:
    pattern: 'route\.ts$'
    flags: -E
    label: "Route handlers"
    aggregate: count

  server_actions:
    pattern: "'use server'"
    flags: -rl
    label: "Server action files"
    aggregate: count

# ===========================================================================
# ANTI-PATTERNS - Quick reference table (documentation only)
# ===========================================================================

anti_patterns:
  - pattern: "'use client' on page"
    description: "Kills SSR benefits"
    fix: "Push client boundary down"

  - pattern: "useEffect fetch"
    description: "Extra round trip"
    fix: "Server component fetch"

  - pattern: "process.env.X client"
    description: "Secrets exposed"
    fix: "Server only or NEXT_PUBLIC_"

  - pattern: "Sequential awaits"
    description: "Slow page load"
    fix: "Promise.all for independent"

  - pattern: "No loading.tsx"
    description: "Layout shift"
    fix: "Add loading boundary"

  - pattern: "No error.tsx"
    description: "Crashes bubble up"
    fix: "Add error boundary"

  - pattern: "Fat route handlers"
    description: "Hard to test"
    fix: "Extract to functions"

  - pattern: "Hardcoded paths"
    description: "Refactor hell"
    fix: "Route constants"

  - pattern: "'any' in handlers"
    description: "No validation"
    fix: "Zod + unknown"

