# python.flight - Python Domain
# Source: Migrated from python.md and python.validate.sh

domain: python
version: 1.1.0
schema_version: 2
description: >
  Production Python patterns for clean, maintainable, type-safe code.
  Prevents common mistakes like mutable defaults, bare exceptions, and
  silent failures.

file_patterns:
  - "**/*.py"

exclude_patterns:
  - "**/node_modules/**"
  - "**/dist/**"
  - "**/build/**"
  - "**/.venv/**"
  - "**/venv/**"
  - "**/__pycache__/**"
  - "**/.git/**"

provenance:
  last_full_audit: "2026-01-20"
  audited_by: "flight-research"
  next_audit_due: "2026-07-20"

  sources_consulted:
    - url: "https://docs.python.org/3/tutorial/errors.html"
      accessed: "2026-01-20"
      note: "Python exception handling documentation"
    - url: "https://docs.python.org/3/tutorial/controlflow.html#default-argument-values"
      accessed: "2026-01-20"
      note: "Default argument values behavior"
    - url: "https://docs.python.org/3/library/logging.html"
      accessed: "2026-01-20"
      note: "Logging module documentation"
    - url: "https://docs.python.org/3/library/pathlib.html"
      accessed: "2026-01-20"
      note: "pathlib module for file operations"
    - url: "https://peps.python.org/pep-0008/"
      accessed: "2026-01-20"
      note: "PEP 8 Style Guide"
    - url: "https://peps.python.org/pep-0484/"
      accessed: "2026-01-20"
      note: "PEP 484 Type Hints"

  coverage:
    apis_covered:
      - "Exception handling (try/except patterns)"
      - "Function definitions (defaults, type hints)"
      - "Import statements"
      - "Logging module"
      - "pathlib for file operations"
      - "Code structure and organization"
    known_gaps:
      - "Async/await patterns (mechanical checks)"
      - "pytest fixtures and testing patterns"
      - "Django/Flask specific patterns"
      - "Package management (pyproject.toml)"

suppression:
  comment: "# noqa"
  guidance: |
    Add `# noqa` comment on the same line to suppress.
    Use sparingly. Document why the suppression is acceptable.

# ===========================================================================
# RULES
# ===========================================================================
# Python-specific rules for production code quality.
#
# ID format: {severity_prefix}{number}
#   N = NEVER (check - fails build)
#   S = SHOULD (warn - advisory)
#   G = GUIDANCE (not checked)
# ===========================================================================

rules:

  # =========================================================================
  # NEVER - Python anti-patterns (validator will reject)
  # =========================================================================

  N1:
    title: "Bare except:"
    severity: NEVER
    mechanical: true
    provenance:
      last_verified: "2026-01-20"
      confidence: high
      re_verify_after: "2027-01-20"
      sources:
        - url: "https://docs.python.org/3/tutorial/errors.html#handling-exceptions"
          accessed: "2026-01-20"
          quote: "A bare except clause will catch all exceptions, including SystemExit and KeyboardInterrupt"
    description: >
      Never use bare 'except:' which catches everything including
      KeyboardInterrupt and SystemExit.
    check:
      type: ast
      query: |
        (except_clause
          . "except"
          . ":" @violation)
    note: |
      Bare except catches KeyboardInterrupt, SystemExit, and GeneratorExit.
      Always specify the exception type you're handling.
    examples:
      bad:
        - |
          try:
              do_something()
          except:
              pass
      good:
        - |
          try:
              do_something()
          except ValueError as e:
              handle_error(e)

  N2:
    title: "except Exception: pass"
    severity: NEVER
    mechanical: true
    provenance:
      last_verified: "2026-01-20"
      confidence: high
      re_verify_after: "2027-01-20"
      sources:
        - url: "https://peps.python.org/pep-0008/#programming-recommendations"
          accessed: "2026-01-20"
          quote: "When catching exceptions, mention specific exceptions whenever possible instead of using a bare except clause"
    description: >
      Never silently swallow exceptions with 'except Exception: pass'.
      Silent failures hide bugs and make debugging impossible.
    check:
      type: script
      code: |
        for f in "$@"; do
          awk '/except\s+(Exception|BaseException)/ { getline; if (/^\s*pass\s*$/) print FILENAME":"NR-1": except with pass" }' "$f"
        done
    examples:
      bad:
        - |
          try:
              risky_operation()
          except Exception:
              pass
      good:
        - |
          try:
              risky_operation()
          except SpecificError as e:
              logger.warning(f"Operation failed: {e}")
              return default_value

  N3:
    title: Mutable Default Arguments
    severity: NEVER
    mechanical: true
    provenance:
      last_verified: "2026-01-20"
      confidence: high
      re_verify_after: "2027-01-20"
      sources:
        - url: "https://docs.python.org/3/tutorial/controlflow.html#default-argument-values"
          accessed: "2026-01-20"
          quote: "The default value is evaluated only once. This makes a difference when the default is a mutable object"
    description: >
      Never use mutable default arguments (=[], ={}, =set()).
      Default arguments are evaluated once at function definition,
      causing shared state across calls.
    check:
      type: ast
      query: |
        (default_parameter
          value: (list) @violation)
        (default_parameter
          value: (dictionary) @violation)
        (default_parameter
          value: (call
            function: (identifier) @fn
            (#eq? @fn "set")) @violation)
    note: |
      The default value is created once when the function is defined,
      not each time it's called. Use None and create inside the function.
    examples:
      bad:
        - "def add_item(item, items=[]):"
        - "def merge_data(data, result={}):"
      good:
        - |
          def add_item(item, items=None):
              if items is None:
                  items = []
              items.append(item)
              return items

  N4:
    title: "from x import *"
    severity: NEVER
    mechanical: true
    provenance:
      last_verified: "2026-01-20"
      confidence: high
      re_verify_after: "2027-01-20"
      sources:
        - url: "https://peps.python.org/pep-0008/#imports"
          accessed: "2026-01-20"
          quote: "Wildcard imports (from <module> import *) should be avoided"
    description: >
      Never use wildcard imports. They pollute the namespace and
      hide where names come from.
    check:
      type: grep
      pattern: '^from .+ import \*'
      flags: -En
    note: |
      Wildcard imports make it impossible to know where names come from,
      can shadow built-ins, and break static analysis tools.
    examples:
      bad:
        - "from os import *"
        - "from utils import *"
      good:
        - "from os import path, getcwd"
        - "from utils import validate_input, format_output"

  N5:
    title: "type(x) == for Type Checking"
    severity: NEVER
    mechanical: true
    provenance:
      last_verified: "2026-01-20"
      confidence: high
      re_verify_after: "2027-01-20"
      sources:
        - url: "https://peps.python.org/pep-0008/#programming-recommendations"
          accessed: "2026-01-20"
          quote: "Object type comparisons should always use isinstance() instead of comparing types directly"
    description: >
      Never use type() for type checking. It breaks inheritance
      and doesn't work with abstract base classes.
    check:
      type: grep
      pattern: 'type\(.+\)\s*==|==\s*type\('
      flags: -En
    note: |
      type() returns the exact type, not accounting for inheritance.
      isinstance() handles inheritance and ABCs correctly.
    examples:
      bad:
        - "if type(obj) == list:"
        - "if type(x) == str:"
      good:
        - "if isinstance(obj, list):"
        - "if isinstance(x, (str, bytes)):"

  N6:
    title: Generic Variable Names at Module Level
    severity: NEVER
    mechanical: true
    provenance:
      last_verified: "2026-01-20"
      confidence: high
      re_verify_after: "2027-01-20"
      sources:
        - url: "https://peps.python.org/pep-0008/#naming-conventions"
          accessed: "2026-01-20"
          quote: "Names should be short but descriptive"
    description: >
      Never use generic variable names (data, temp, result, info, obj)
      at module level. Use domain-specific names.
    check:
      type: grep
      pattern: '^(data|temp|result|info|obj)\s*='
      flags: -En
    note: |
      Generic names provide no context. Use names that describe
      what the variable holds in your domain.
    examples:
      bad:
        - "data = load_users()"
        - "result = process()"
      good:
        - "users = load_users()"
        - "processed_orders = process()"

  N7:
    title: print() Outside __main__
    severity: NEVER
    mechanical: true
    provenance:
      last_verified: "2026-01-20"
      confidence: high
      re_verify_after: "2027-01-20"
      sources:
        - url: "https://docs.python.org/3/library/logging.html"
          accessed: "2026-01-20"
          quote: "Logging provides a set of convenience functions for simple logging usage"
    description: >
      Never use print() for logging outside of __main__ blocks.
      Use the logging module for proper log levels and context.
    check:
      type: script
      code: |
        for f in "$@"; do
          awk '
          /__name__.*__main__/ { in_main=1 }
          /^[^ ]/ && in_main { in_main=0 }
          /print\(/ && !in_main && !/# noqa/ { print FILENAME":"NR": "$0 }
          ' "$f"
        done | head -10
    examples:
      bad:
        - 'print(f"Processing user {user_id}")'
        - 'print(f"Error: {e}")'
      good:
        - |
          import logging
          logger = logging.getLogger(__name__)
          logger.info(f"Processing user {user_id}")

  N8:
    title: Hardcoded Absolute Paths
    severity: NEVER
    mechanical: true
    provenance:
      last_verified: "2026-01-20"
      confidence: high
      re_verify_after: "2027-01-20"
      sources:
        - url: "https://docs.python.org/3/library/pathlib.html"
          accessed: "2026-01-20"
          quote: "pathlib offers classes representing filesystem paths with semantics appropriate for different operating systems"
    description: >
      Never hardcode absolute paths. They break across environments
      and operating systems.
    check:
      type: grep
      pattern: "['\"]/(home|usr|var|etc|tmp)/|['\"][A-Z]:\\\\"
      flags: -En
    note: |
      Use pathlib.Path for portable path handling. Use Path(__file__).parent
      for paths relative to the current file.
    examples:
      bad:
        - 'config_path = "/home/user/app/config.json"'
        - 'output_dir = "C:\\Users\\app\\output"'
      good:
        - |
          from pathlib import Path
          CONFIG_PATH = Path(__file__).parent / "config.json"

  N9:
    title: Deeply Nested Conditionals
    severity: NEVER
    mechanical: true
    provenance:
      last_verified: "2026-01-20"
      confidence: high
      re_verify_after: "2027-01-20"
      sources:
        - url: "https://peps.python.org/pep-0020/"
          accessed: "2026-01-20"
          quote: "Flat is better than nested"
    description: >
      Never nest conditionals more than 3 levels deep.
      Use early returns to flatten the structure.
    check:
      type: script
      code: |
        for f in "$@"; do
          awk '
          /^\s+if / {
            spaces = length($0) - length(gensub(/^\s+/, "", "g", $0))
            if (spaces > 16) {
              print FILENAME":"NR": deeply nested ("int(spaces/4)" levels)"
            }
          }
          ' "$f"
        done | head -5
    examples:
      bad:
        - |
          if user:
              if user.is_active:
                  if user.has_permission:
                      if not user.is_banned:
                          do_action()
      good:
        - |
          if not user:
              return
          if not user.is_active:
              return
          if not user.has_permission:
              return
          if user.is_banned:
              return
          do_action()

  N10:
    title: Hardcoded Credentials
    severity: NEVER
    mechanical: true
    provenance:
      last_verified: "2026-01-25"
      confidence: high
      re_verify_after: "2026-07-25"
      sources:
        - url: "https://cwe.mitre.org/data/definitions/798.html"
          accessed: "2026-01-25"
          quote: "CWE-798: Use of Hard-coded Credentials"
    description: >
      Never hardcode passwords, API keys, or secrets in source code.
      Use environment variables or secret management systems.
    check:
      type: grep
      pattern: "(password|passwd|api_key|api_secret|secret_key|auth_token|access_token)\\s*=\\s*['\"][^'\"]{8,}['\"]"
      flags: -Eni
    note: |
      Hardcoded credentials are a critical security vulnerability.
      Use os.environ.get() or a secrets manager for sensitive values.
    examples:
      bad:
        - "password = 'mysecretpassword123'"
        - "API_KEY = 'sk-proj-abc123def456ghi'"
        - "auth_token = 'eyJhbGciOiJIUzI1NiIs...'"
      good:
        - "password = os.environ.get('DB_PASSWORD')"
        - "API_KEY = os.environ['OPENAI_API_KEY']"
        - "auth_token = get_secret('auth_token')"

  N11:
    title: eval() Usage
    severity: NEVER
    mechanical: true
    provenance:
      last_verified: "2026-01-25"
      confidence: high
      re_verify_after: "2026-07-25"
      sources:
        - url: "https://cwe.mitre.org/data/definitions/95.html"
          accessed: "2026-01-25"
          quote: "CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')"
    description: >
      Never use eval() to execute arbitrary code. It allows code injection
      attacks if any part of the input is user-controlled.
    check:
      type: ast
      language: python
      query: |
        (call
          function: (identifier) @fn
          (#eq? @fn "eval")) @violation
    note: |
      eval() executes arbitrary Python code. Even "sanitized" input can be
      exploited. Use ast.literal_eval() for safe literal parsing, or find
      a domain-specific parser for your use case.
    examples:
      bad:
        - "result = eval(user_input)"
        - "config = eval(f'dict({params})')"
      good:
        - "result = ast.literal_eval(user_input)  # Safe for literals only"
        - "config = json.loads(params)"

  N12:
    title: exec() Usage
    severity: NEVER
    mechanical: true
    provenance:
      last_verified: "2026-01-25"
      confidence: high
      re_verify_after: "2026-07-25"
      sources:
        - url: "https://cwe.mitre.org/data/definitions/94.html"
          accessed: "2026-01-25"
          quote: "CWE-94: Improper Control of Generation of Code ('Code Injection')"
    description: >
      Never use exec() to execute code strings. It allows arbitrary code
      execution and is almost never necessary.
    check:
      type: ast
      language: python
      query: |
        (call
          function: (identifier) @fn
          (#eq? @fn "exec")) @violation
    note: |
      exec() is even more dangerous than eval() - it can execute multiple
      statements. There's almost always a safer alternative.
    examples:
      bad:
        - "exec(code_string)"
        - "exec(f'import {module_name}')"
      good:
        - "importlib.import_module(module_name)"
        - "# Redesign to avoid dynamic code execution"

  N13:
    title: subprocess shell=True
    severity: NEVER
    mechanical: true
    provenance:
      last_verified: "2026-01-25"
      confidence: high
      re_verify_after: "2026-07-25"
      sources:
        - url: "https://cwe.mitre.org/data/definitions/78.html"
          accessed: "2026-01-25"
          quote: "CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
    description: >
      Never use shell=True with subprocess. It enables shell injection
      attacks when any part of the command is user-controlled.
    check:
      type: ast
      language: python
      query: |
        (call
          function: (attribute
            object: (identifier) @mod
            attribute: (identifier) @method)
          arguments: (argument_list
            (keyword_argument
              name: (identifier) @kwarg
              value: (true)))
          (#eq? @mod "subprocess")
          (#match? @method "^(run|call|Popen|check_output|check_call)$")
          (#eq? @kwarg "shell")) @violation
    note: |
      With shell=True, command strings are passed through the shell,
      enabling injection via metacharacters. Pass args as a list instead.
    examples:
      bad:
        - "subprocess.run(f'ls {user_dir}', shell=True)"
        - "subprocess.call(cmd_string, shell=True)"
      good:
        - "subprocess.run(['ls', user_dir])"
        - "subprocess.call(shlex.split(cmd_string))"

  N14:
    title: pickle.loads() on Untrusted Data
    severity: NEVER
    mechanical: true
    provenance:
      last_verified: "2026-01-25"
      confidence: high
      re_verify_after: "2026-07-25"
      sources:
        - url: "https://cwe.mitre.org/data/definitions/502.html"
          accessed: "2026-01-25"
          quote: "CWE-502: Deserialization of Untrusted Data"
    description: >
      Never unpickle data from untrusted sources. Pickle can execute
      arbitrary code during deserialization.
    check:
      type: ast
      language: python
      query: |
        (call
          function: (attribute
            object: (identifier) @mod
            attribute: (identifier) @method)
          (#eq? @mod "pickle")
          (#match? @method "^(loads?|Unpickler)$")) @violation
    note: |
      Pickle is not secure. Malicious pickle data can execute arbitrary
      code. Use JSON, msgpack, or other safe serialization formats.
    examples:
      bad:
        - "data = pickle.loads(request.body)"
        - "obj = pickle.load(open(user_file, 'rb'))"
      good:
        - "data = json.loads(request.body)"
        - "obj = msgpack.unpackb(content)"

  # =========================================================================
  # SHOULD - Best practices (validator warns)
  # =========================================================================

  S1:
    title: String += Patterns
    severity: SHOULD
    mechanical: true
    provenance:
      last_verified: "2026-01-20"
      confidence: high
      re_verify_after: "2027-01-20"
      sources:
        - url: "https://docs.python.org/3/library/stdtypes.html#str.join"
          accessed: "2026-01-20"
          quote: "Return a string which is the concatenation of the strings in iterable"
    description: >
      Avoid string concatenation with += in loops. It creates O(n²)
      complexity due to string immutability.
    check:
      type: grep
      pattern: '\+=\s*[''"]|\+=.*str\('
      flags: -En
    note: |
      Each += creates a new string object. Use str.join() or list
      accumulation for efficient string building.
    examples:
      bad:
        - |
          result = ""
          for item in items:
              result += str(item) + ", "
      good:
        - 'result = ", ".join(str(item) for item in items)'

  S2:
    title: Magic Numbers in Logic
    severity: SHOULD
    mechanical: true
    provenance:
      last_verified: "2026-01-20"
      confidence: high
      re_verify_after: "2027-01-20"
      sources:
        - url: "https://peps.python.org/pep-0008/#constants"
          accessed: "2026-01-20"
          quote: "Constants are usually defined on a module level and written in all capital letters"
    description: >
      Avoid magic numbers in conditionals and function calls.
      Use named constants for clarity.
    check:
      type: grep
      pattern: 'if .+ [<>=]+ [0-9]{2,}|while .+ [<>=]+ [0-9]{2,}|sleep\([0-9]{2,}\)'
      flags: -En
    examples:
      bad:
        - "if retry_count > 3:"
        - "time.sleep(86400)"
      good:
        - |
          MAX_RETRIES = 3
          SECONDS_PER_DAY = 86400
          if retry_count > MAX_RETRIES:
              raise TooManyRetries()

  S3:
    title: Type Hints on Public Functions
    severity: SHOULD
    mechanical: true
    provenance:
      last_verified: "2026-01-20"
      confidence: high
      re_verify_after: "2027-01-20"
      sources:
        - url: "https://peps.python.org/pep-0484/"
          accessed: "2026-01-20"
          quote: "This PEP aims to provide a standard syntax for type annotations"
    description: >
      Public functions should have type hints for parameters and
      return values to enable static analysis and documentation.
    check:
      type: script
      code: |
        for f in "$@"; do
          grep -n '^def [a-z]' "$f" | grep -v '\->' | grep -v '__' | head -3
        done
    examples:
      bad:
        - |
          def calculate_total(items, tax_rate):
              return sum(i.price for i in items) * (1 + tax_rate)
      good:
        - |
          def calculate_total(items: list[LineItem], tax_rate: float) -> Decimal:
              return sum(i.price for i in items) * (1 + tax_rate)

  S4:
    title: if __name__ == __main__ Guard
    severity: SHOULD
    mechanical: true
    provenance:
      last_verified: "2026-01-20"
      confidence: high
      re_verify_after: "2027-01-20"
      sources:
        - url: "https://docs.python.org/3/library/__main__.html"
          accessed: "2026-01-20"
          quote: "__main__ is the name of the environment where top-level code is run"
    description: >
      Scripts with a main() function should have an
      'if __name__ == "__main__":' guard.
    check:
      type: script
      code: |
        for f in "$@"; do
          if grep -q '^def main' "$f"; then
            if ! grep -q '__name__.*__main__' "$f"; then
              echo "$f: has main() but no __name__ guard"
            fi
          fi
        done
    examples:
      good:
        - |
          def main():
              app = create_app()
              app.run()

          if __name__ == "__main__":
              main()

  S5:
    title: Use pathlib for File Operations
    severity: SHOULD
    mechanical: true
    provenance:
      last_verified: "2026-01-20"
      confidence: high
      re_verify_after: "2027-01-20"
      sources:
        - url: "https://docs.python.org/3/library/pathlib.html"
          accessed: "2026-01-20"
          quote: "This module offers classes representing filesystem paths with semantics appropriate for different operating systems"
    description: >
      Prefer pathlib over os.path for file operations.
      pathlib provides a cleaner, more object-oriented API.
    check:
      type: script
      code: |
        for f in "$@"; do
          if grep -q 'os.path' "$f"; then
            if ! grep -q 'pathlib' "$f"; then
              echo "$f: uses os.path, consider pathlib"
            fi
          fi
        done
    examples:
      bad:
        - |
          import os
          config_path = os.path.join(base_dir, "config.json")
      good:
        - |
          from pathlib import Path
          config_path = Path(base_dir) / "config.json"

  S6:
    title: Use logging Module
    severity: SHOULD
    mechanical: true
    provenance:
      last_verified: "2026-01-20"
      confidence: high
      re_verify_after: "2027-01-20"
      sources:
        - url: "https://docs.python.org/3/howto/logging.html"
          accessed: "2026-01-20"
          quote: "Logging is a means of tracking events that happen when some software runs"
    description: >
      Large files (>50 lines) should use the logging module
      for proper log levels and configuration.
    check:
      type: script
      code: |
        for f in "$@"; do
          if [ $(wc -l < "$f") -gt 50 ]; then
            if ! grep -q 'import logging\|from logging' "$f"; then
              echo "$f: large file without logging"
            fi
          fi
        done
    examples:
      good:
        - |
          import logging
          logger = logging.getLogger(__name__)

          logger.debug("Detailed info for debugging")
          logger.info("General information")
          logger.warning("Something unexpected")
          logger.error("Error occurred", exc_info=True)

  S7:
    title: Docstrings on Public Functions
    severity: SHOULD
    mechanical: true
    provenance:
      last_verified: "2026-01-20"
      confidence: high
      re_verify_after: "2027-01-20"
      sources:
        - url: "https://peps.python.org/pep-0257/"
          accessed: "2026-01-20"
          quote: "A docstring is a string literal that occurs as the first statement in a module, function, class, or method definition"
    description: >
      Public functions should have docstrings explaining their
      purpose, arguments, and return values.
    check:
      type: script
      code: |
        for f in "$@"; do
          awk '
          /^def [a-z][a-z_]+\(/ {
            fname=$0; getline;
            if ($0 !~ /"""/ && $0 !~ /\x27\x27\x27/) {
              print FILENAME":"NR-1": "fname" - no docstring"
            }
          }
          ' "$f" | head -3
        done
    examples:
      good:
        - |
          def calculate_shipping(
              weight: float,
              destination: str,
              express: bool = False
          ) -> Decimal:
              """Calculate shipping cost for an order.

              Args:
                  weight: Package weight in kg
                  destination: Country code (ISO 3166-1)
                  express: Whether to use express shipping

              Returns:
                  Shipping cost in USD

              Raises:
                  InvalidDestination: If country code not supported
              """

  # =========================================================================
  # GUIDANCE - Best practices (not mechanically checked)
  # =========================================================================

  G1:
    title: Module Structure
    severity: GUIDANCE
    mechanical: false
    description: >
      Standard module structure with imports organized by category,
      module-level constants, and main guard.
    guidance: |
      """Module docstring explaining purpose."""

      # Standard library imports
      import logging
      from pathlib import Path
      from typing import Optional

      # Third-party imports
      import requests
      from pydantic import BaseModel

      # Local imports
      from .utils import validate
      from .models import User

      # Module-level constants
      MAX_RETRIES = 3
      DEFAULT_TIMEOUT = 30

      # Logger
      logger = logging.getLogger(__name__)


      # Classes and functions
      class UserService:
          ...


      def main():
          ...


      if __name__ == "__main__":
          main()

  G2:
    title: Error Handling Pattern
    severity: GUIDANCE
    mechanical: false
    description: >
      Define custom exception hierarchies for your domain.
      Catch specific exceptions and log appropriately.
    guidance: |
      class OrderError(Exception):
          """Base exception for order operations."""
          pass

      class OrderNotFound(OrderError):
          """Raised when order doesn't exist."""
          pass

      class InvalidOrderStatus(OrderError):
          """Raised when order status transition is invalid."""
          pass


      def get_order(order_id: str) -> Order:
          """Fetch order by ID.

          Raises:
              OrderNotFound: If order doesn't exist
          """
          order = db.orders.get(order_id)
          if order is None:
              raise OrderNotFound(f"Order {order_id} not found")
          return order


      # Usage
      try:
          order = get_order(order_id)
      except OrderNotFound:
          logger.warning(f"Order {order_id} not found")
          return None
      except OrderError as e:
          logger.error(f"Order error: {e}")
          raise

  G3:
    title: Configuration Pattern
    severity: GUIDANCE
    mechanical: false
    description: >
      Use pydantic-settings for type-safe configuration from
      environment variables.
    guidance: |
      from pydantic_settings import BaseSettings


      class Settings(BaseSettings):
          """Application settings from environment."""

          database_url: str
          api_key: str
          debug: bool = False
          max_connections: int = 10

          class Config:
              env_file = ".env"


      settings = Settings()

  G4:
    title: Async Pattern
    severity: GUIDANCE
    mechanical: false
    description: >
      Use asyncio.gather for concurrent operations and
      async iterators for streaming.
    guidance: |
      import asyncio
      from typing import AsyncIterator


      async def fetch_users(user_ids: list[str]) -> list[User]:
          """Fetch multiple users concurrently."""
          tasks = [fetch_user(uid) for uid in user_ids]
          return await asyncio.gather(*tasks)


      async def process_stream(items: AsyncIterator[Item]) -> None:
          """Process items from async stream."""
          async for item in items:
              await process_item(item)

  G5:
    title: Use Dataclasses or Pydantic
    severity: GUIDANCE
    mechanical: false
    description: >
      Use dataclasses or Pydantic models for structured data
      instead of plain dicts or tuples.
    guidance: |
      from dataclasses import dataclass
      from typing import Optional

      @dataclass
      class User:
          id: str
          email: str
          name: str
          is_active: bool = True
          metadata: Optional[dict] = None

  G6:
    title: Use Enums for Fixed Choices
    severity: GUIDANCE
    mechanical: false
    description: >
      Use Enum classes for values with a fixed set of choices.
    guidance: |
      from enum import Enum, auto

      class OrderStatus(Enum):
          PENDING = auto()
          PROCESSING = auto()
          SHIPPED = auto()
          DELIVERED = auto()

      def update_status(order: Order, status: OrderStatus) -> None:
          order.status = status

  G7:
    title: Use Comprehensions
    severity: GUIDANCE
    mechanical: false
    description: >
      Use list/dict/set comprehensions for simple transformations
      instead of explicit loops.
    guidance: |
      # List comprehension
      squares = [x ** 2 for x in range(10)]

      # Dict comprehension
      user_map = {u.id: u for u in users}

      # Set comprehension
      unique_names = {u.name for u in users}

      # With conditions
      active_users = [u for u in users if u.is_active]

  G8:
    title: Context Managers for Resources
    severity: GUIDANCE
    mechanical: false
    description: >
      Use context managers (with statement) for resources that
      need cleanup.
    guidance: |
      # Files
      with open("data.txt") as f:
          content = f.read()

      # Database connections
      with db.connection() as conn:
          conn.execute(query)

      # Locks
      with threading.Lock():
          shared_resource.update()

info_metrics:
  - name: "Functions defined"
    pattern: "^def "
  - name: "Classes defined"
    pattern: "^class "
  - name: "Functions with return type"
    pattern: "def.*->.*:"
  - name: "Dataclasses"
    pattern: "@dataclass"

anti_patterns:
  - pattern: "except:"
    problem: "Catches everything"
    fix: "Specific exceptions"
  - pattern: "except Exception: pass"
    problem: "Silent failure"
    fix: "Log or handle"
  - pattern: "def f(x=[])"
    problem: "Mutable default"
    fix: "x=None pattern"
  - pattern: "from x import *"
    problem: "Namespace pollution"
    fix: "Explicit imports"
  - pattern: "s += item in loop"
    problem: "O(n²)"
    fix: '"".join()'
  - pattern: "type(x) == Y"
    problem: "Breaks inheritance"
    fix: "isinstance()"
  - pattern: "print() for logs"
    problem: "No levels"
    fix: "logging module"
  - pattern: "Magic numbers"
    problem: "Unclear intent"
    fix: "Named constants"
  - pattern: "No type hints"
    problem: "Hard to maintain"
    fix: "Add annotations"
  - pattern: "Nested if > 3"
    problem: "Hard to read"
    fix: "Early returns"
  - pattern: "Hardcoded paths"
    problem: "Not portable"
    fix: "pathlib.Path"
  - pattern: "Generic names"
    problem: "Unclear purpose"
    fix: "Domain terms"
  - pattern: "password = 'secret'"
    problem: "Hardcoded credentials"
    fix: "os.environ.get()"
  - pattern: "eval(user_input)"
    problem: "Code injection"
    fix: "ast.literal_eval() or json.loads()"
  - pattern: "exec(code_string)"
    problem: "Arbitrary code execution"
    fix: "Redesign without dynamic code"
  - pattern: "shell=True"
    problem: "Command injection"
    fix: "Pass args as list"
  - pattern: "pickle.loads()"
    problem: "Deserialization RCE"
    fix: "Use JSON or msgpack"
