#!/bin/bash
# rust.validate.sh - Rust development patterns covering error handling, ownership, memory safety, concurrency, and idiomatic code
# Generated by flight-domain-compile from rust.flight
set -euo pipefail

# Script location for sourcing helpers
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Default: common file patterns
DEFAULT_PATTERNS="**/*.rs"
PASS=0
FAIL=0
WARN=0

red() { printf '\033[31m%s\033[0m\n' "$1"; }
green() { printf '\033[32m%s\033[0m\n' "$1"; }
yellow() { printf '\033[33m%s\033[0m\n' "$1"; }

check() {
    local name="$1"
    shift
    local result
    result=$("$@" 2>/dev/null) || true
    if [[ -z "$result" ]]; then
        green "✅ $name"
        ((PASS++)) || true
    else
        red "❌ $name"
        printf '%s\n' "$result" | head -10 | sed 's/^/   /'
        ((FAIL++)) || true
    fi
}

warn() {
    local name="$1"
    shift
    local result
    result=$("$@" 2>/dev/null) || true
    if [[ -z "$result" ]]; then
        green "✅ $name"
        ((PASS++)) || true
    else
        yellow "⚠️  $name"
        printf '%s\n' "$result" | head -5 | sed 's/^/   /'
        ((WARN++)) || true
    fi
}

printf '%s\n' "═══════════════════════════════════════════"
printf '%s\n' "  RUST Domain Validation"
printf '%s\n' "═══════════════════════════════════════════"
printf '\n'

# Source exclusions helper if available
if [[ -f "$SCRIPT_DIR/../exclusions.sh" ]]; then
    source "$SCRIPT_DIR/../exclusions.sh"
    FLIGHT_HAS_EXCLUSIONS=true
else
    FLIGHT_HAS_EXCLUSIONS=false
fi

# Handle arguments or use defaults
if [[ $# -gt 0 ]]; then
    FILES=("$@")
elif [[ "$FLIGHT_HAS_EXCLUSIONS" == true ]]; then
    # Use exclusions-aware file discovery
    mapfile -t FILES < <(flight_get_files "*.rs")
else
    # Fallback: glob expansion without exclusions
    shopt -s nullglob globstar
    FILES=($DEFAULT_PATTERNS)
    shopt -u nullglob globstar
fi

if [[ ${#FILES[@]} -eq 0 ]]; then
    yellow "No files found matching default patterns"
    printf '%s\n' "  Patterns: **/*.rs..."
    printf '\n'
    green "  RESULT: SKIP (no files)"
    exit 0
fi

printf 'Files: %d\n\n' "${#FILES[@]}"

printf '\n%s\n' "## NEVER Rules"

# N1: Unsafe Block Without Safety Comment
check "N1: Unsafe Block Without Safety Comment" \
    bash -c 'for f in "$@"; do
  awk '"'"'
    /unsafe\s*\{/ {
      if (prev !~ /\/\/\s*SAFETY:/ && prev !~ /\/\/\s*safety:/ && prev !~ /\/\*.*SAFETY:/) {
        print FILENAME ":" NR ": unsafe block without SAFETY comment"
      }
    }
    { prev = $0 }
  '"'"' "$f" 2>/dev/null | grep -v "flight:ok"
done' _ "${FILES[@]}"

# N2: mem::transmute Usage
check "N2: mem::transmute Usage" \
    bash -c 'grep -En "mem::transmute\\s*[<(]|transmute::<" "$@" | grep -v "flight:ok"' _ "${FILES[@]}"

# N3: Panic in Library Code
check "N3: Panic in Library Code" \
    bash -c 'for f in "$@"; do
  # Skip test files, main.rs, and bin files
  if [[ "$f" == *"_test.rs" ]] || [[ "$f" == *"/tests/"* ]] || \
     [[ "$f" == *"main.rs" ]] || [[ "$f" == *"/bin/"* ]] || \
     [[ "$f" == *"/examples/"* ]]; then
    continue
  fi
  grep -HnE '"'"'panic!\s*\(|todo!\s*\(|unimplemented!\s*\('"'"' "$f" 2>/dev/null | \
    grep -v "flight:ok" | grep -v "unreachable!"
done' _ "${FILES[@]}"

# N4: .unwrap() in Production Code
check "N4: .unwrap() in Production Code" \
    bash -c 'for f in "$@"; do
  # Skip test files
  if [[ "$f" == *"_test.rs" ]] || [[ "$f" == *"/tests/"* ]] || \
     [[ "$f" == *"/examples/"* ]]; then
    continue
  fi
  grep -HnE '"'"'\.unwrap\(\s*\)'"'"' "$f" 2>/dev/null | grep -v "flight:ok"
done' _ "${FILES[@]}"

# N5: .expect() Without Descriptive Message
check "N5: .expect() Without Descriptive Message" \
    bash -c 'grep -En "\\.expect\\s*\\(\\s*\"\"\\s*\\)|\\.expect\\s*\\(\\s*\\)" "$@" | grep -v "flight:ok"' _ "${FILES[@]}"

# N6: Raw Pointer Arithmetic Without Bounds Check
check "N6: Raw Pointer Arithmetic Without Bounds Check" \
    bash -c 'grep -En "\\.offset\\s*\\(|\\.add\\s*\\(|\\.sub\\s*\\(|\\.wrapping_offset\\s*\\(" "$@" | grep -v "flight:ok"' _ "${FILES[@]}"

# N7: mem::forget Without Clear Justification
check "N7: mem::forget Without Clear Justification" \
    bash -c 'grep -En "mem::forget\\s*\\(|std::mem::forget\\s*\\(" "$@" | grep -v "flight:ok"' _ "${FILES[@]}"

# N8: Mutex Held Across Await Point
check "N8: Mutex Held Across Await Point" \
    bash -c 'for f in "$@"; do
  # Look for patterns like: lock() followed by .await without drop
  if grep -qE '"'"'\.lock\(\)'"'"' "$f" 2>/dev/null; then
    if grep -qE '"'"'\.await'"'"' "$f" 2>/dev/null; then
      # Check for suspicious patterns (heuristic)
      awk '"'"'
        /\.lock\(\)/ { in_lock = 1; lock_line = NR }
        /\.await/ && in_lock {
          print FILENAME ":" lock_line ": mutex may be held across await"
          in_lock = 0
        }
        /drop\(|}\s*$/ { in_lock = 0 }
      '"'"' "$f" 2>/dev/null | grep -v "flight:ok"
    fi
  fi
done' _ "${FILES[@]}"

printf '\n%s\n' "## MUST Rules"

# M1: Use ? Operator for Error Propagation
check "M1: Use ? Operator for Error Propagation" \
    bash -c 'for f in "$@"; do
  # Look for verbose match patterns that could use ?
  grep -HnE '"'"'match\s+\w+\s*\{[^}]*Ok\s*\(\s*\w+\s*\)\s*=>\s*\w+\s*,'"'"' "$f" 2>/dev/null | \
    grep -v "flight:ok"
done' _ "${FILES[@]}"

# M2: Clone Abuse - Cloning to Satisfy Borrow Checker
check "M2: Clone Abuse - Cloning to Satisfy Borrow Checker" \
    bash -c 'for f in "$@"; do
  # Look for .clone() immediately before passing to function or after &
  grep -HnE '"'"'&\w+\.clone\(\)|\.clone\(\)\s*\)'"'"' "$f" 2>/dev/null | grep -v "flight:ok"
done' _ "${FILES[@]}"

# M3: String Parameter When &str Would Work
check "M3: String Parameter When &str Would Work" \
    bash -c 'grep -En "fn\\s+\\w+\\s*\\([^)]*:\\s*&?String[^)]*(,|\\))|fn\\s+\\w+\\s*<[^>]*>\\s*\\([^)]*:\\s*&?String" "$@" | grep -v "flight:ok"' _ "${FILES[@]}"

# M4: Vec Parameter When Slice Would Work
check "M4: Vec Parameter When Slice Would Work" \
    bash -c 'grep -En "fn\\s+\\w+\\s*\\([^)]*:\\s*&Vec<[^>]+>[^)]*(,|\\))" "$@" | grep -v "flight:ok"' _ "${FILES[@]}"

# M5: Box<T> When T Would Work
check "M5: Box<T> When T Would Work" \
    bash -c 'grep -En "Box<(String|Vec<|HashMap<|HashSet<)" "$@" | grep -v "flight:ok"' _ "${FILES[@]}"

# M6: println! in Library Code
check "M6: println! in Library Code" \
    bash -c 'for f in "$@"; do
  # Skip test files, main.rs, bin files, and examples
  if [[ "$f" == *"_test.rs" ]] || [[ "$f" == *"/tests/"* ]] || \
     [[ "$f" == *"main.rs" ]] || [[ "$f" == *"/bin/"* ]] || \
     [[ "$f" == *"/examples/"* ]] || [[ "$f" == *"/benches/"* ]]; then
    continue
  fi
  grep -HnE '"'"'println!\s*\(|print!\s*\(|eprintln!\s*\(|eprint!\s*\('"'"' "$f" 2>/dev/null | \
    grep -v "flight:ok"
done' _ "${FILES[@]}"

# M7: Blocking Operations in Async Context
check "M7: Blocking Operations in Async Context" \
    bash -c 'for f in "$@"; do
  if grep -qE '"'"'async\s+fn'"'"' "$f" 2>/dev/null; then
    grep -HnE '"'"'std::fs::|std::thread::sleep|std::io::stdin|\.read_to_string\('"'"' "$f" 2>/dev/null | \
      grep -v "flight:ok"
  fi
done' _ "${FILES[@]}"

# M9: Derive Common Traits
check "M9: Derive Common Traits" \
    bash -c 'for f in "$@"; do
  awk '"'"'
    /^pub\s+(struct|enum)\s+\w+/ {
      if (prev !~ /#\[derive\(.*Debug/) {
        print FILENAME ":" NR ": public type missing Debug derive"
      }
    }
    { prev = $0 }
  '"'"' "$f" 2>/dev/null | grep -v "flight:ok"
done' _ "${FILES[@]}"

printf '\n%s\n' "## SHOULD Rules"

# S1: Use Iterators Over Manual Loops
warn "S1: Use Iterators Over Manual Loops" \
    bash -c 'for f in "$@"; do
  # Look for patterns like for i in 0..vec.len() { vec[i] }
  grep -HnE '"'"'for\s+\w+\s+in\s+0\s*\.\.\s*\w+\.len\(\)'"'"' "$f" 2>/dev/null | \
    grep -v "flight:ok"
done' _ "${FILES[@]}"

# S2: Use if let for Single-Arm Matches
warn "S2: Use if let for Single-Arm Matches" \
    bash -c 'for f in "$@"; do
  # Look for match with only one meaningful arm and _ => {}
  grep -HnE '"'"'match\s+\w+\s*\{[^}]*_\s*=>\s*\{\s*\}[^}]*\}'"'"' "$f" 2>/dev/null | \
    grep -v "flight:ok"
done' _ "${FILES[@]}"

# S3: Implement Default for Types with Obvious Defaults
warn "S3: Implement Default for Types with Obvious Defaults" \
    bash -c 'for f in "$@"; do
  # Look for pub fn new() that takes no args - might want Default
  if grep -qE '"'"'pub\s+fn\s+new\s*\(\s*\)\s*->'"'"' "$f" 2>/dev/null; then
    if ! grep -qE '"'"'impl\s+Default\s+for'"'"' "$f" 2>/dev/null; then
      name=$(grep -oE '"'"'impl[^{]+\{[^}]*pub\s+fn\s+new\s*\('"'"' "$f" 2>/dev/null | head -1)
      if [ -n "$name" ]; then
        echo "$f: has new() but no Default implementation"
      fi
    fi
  fi
done | grep -v "flight:ok"' _ "${FILES[@]}"

# S5: Avoid Wildcard Imports
warn "S5: Avoid Wildcard Imports" \
    bash -c 'for f in "$@"; do
  # Skip test modules and prelude imports
  grep -HnE '"'"'^use\s+[^;]+::\*;'"'"' "$f" 2>/dev/null | \
    grep -vE '"'"'prelude::\*|flight:ok|#\[cfg\(test\)\]'"'"'
done' _ "${FILES[@]}"

# S6: Use snake_case for Functions and Variables
warn "S6: Use snake_case for Functions and Variables" \
    bash -c 'grep -En "(let|fn)\\s+[a-z]+[A-Z][a-zA-Z]*\\s*[=:(]" "$@" | grep -v "flight:ok"' _ "${FILES[@]}"

# S7: Avoid Large Stack Allocations
warn "S7: Avoid Large Stack Allocations" \
    bash -c 'for f in "$@"; do
  # Look for arrays larger than 256 elements of basic types
  grep -HnE '"'"'\[\s*[a-z0-9_]+\s*;\s*[0-9]{4,}\s*\]'"'"' "$f" 2>/dev/null | \
    grep -v "flight:ok"
done' _ "${FILES[@]}"

# S8: Prefer From/Into Over as for Type Conversions
warn "S8: Prefer From/Into Over as for Type Conversions" \
    bash -c 'grep -En "\\s+as\\s+(u8|u16|u32|i8|i16|i32)\\s*[;,)\\]]" "$@" | grep -v "flight:ok"' _ "${FILES[@]}"

printf '\n%s\n' "## Info"

UNSAFE_COUNT=$( (grep -cE "unsafe\s*\{" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  Unsafe blocks: %s\n' "$UNSAFE_COUNT"

UNWRAP_COUNT=$( (grep -cE "\.unwrap\(\)" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  Unwrap calls: %s\n' "$UNWRAP_COUNT"

EXPECT_COUNT=$( (grep -cE "\.expect\(" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  Expect calls: %s\n' "$EXPECT_COUNT"

CLONE_COUNT=$( (grep -cE "\.clone\(\)" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  Clone calls: %s\n' "$CLONE_COUNT"

ARC_MUTEX_COUNT=$( (grep -cE "Arc<.*Mutex<|Arc::new.*Mutex::new" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  Arc<Mutex<T>> patterns: %s\n' "$ARC_MUTEX_COUNT"

ASYNC_FN_COUNT=$( (grep -cE "async\s+fn" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  Async functions: %s\n' "$ASYNC_FN_COUNT"

PUB_FN_COUNT=$( (grep -cE "^pub\s+(async\s+)?fn\s+" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  Public functions: %s\n' "$PUB_FN_COUNT"

DERIVE_COUNT=$( (grep -cE "#\[derive\(" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  Derive macros: %s\n' "$DERIVE_COUNT"

TEST_COUNT=$( (grep -cE "#\[test\]|#\[tokio::test\]" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  Test functions: %s\n' "$TEST_COUNT"

printf '\n%s\n' "═══════════════════════════════════════════"
printf '  PASS: %d  FAIL: %d  WARN: %d\n' "$PASS" "$FAIL" "$WARN"
if [[ $FAIL -eq 0 ]]; then
    green "  RESULT: PASS"
else
    red "  RESULT: FAIL"
fi
printf '%s\n' "═══════════════════════════════════════════"

exit "$FAIL"
