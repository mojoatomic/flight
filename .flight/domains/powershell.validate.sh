#!/usr/bin/env bash
# powershell.validate.sh - PowerShell scripting best practices for automation, DevOps, and system administration
# Generated by flight-domain-compile from powershell.flight
set -euo pipefail

# Script location for sourcing helpers
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Default: common file patterns
DEFAULT_PATTERNS="*.ps1 *.psm1 *.psd1"
PASS=0
FAIL=0
WARN=0

red() { printf '\033[31m%s\033[0m\n' "$1"; }
green() { printf '\033[32m%s\033[0m\n' "$1"; }
yellow() { printf '\033[33m%s\033[0m\n' "$1"; }

check() {
    local name="$1"
    shift
    local result
    result=$("$@" 2>/dev/null) || true
    if [[ -z "$result" ]]; then
        green "✅ $name"
        ((PASS++)) || true
    else
        red "❌ $name"
        # Use subshell to prevent SIGPIPE from killing script with pipefail
        (printf '%s\n' "$result" | head -10 | sed 's/^/   /') || true
        ((FAIL++)) || true
    fi
}

warn() {
    local name="$1"
    shift
    local result
    result=$("$@" 2>/dev/null) || true
    if [[ -z "$result" ]]; then
        green "✅ $name"
        ((PASS++)) || true
    else
        yellow "⚠️  $name"
        # Use subshell to prevent SIGPIPE from killing script with pipefail
        (printf '%s\n' "$result" | head -5 | sed 's/^/   /') || true
        ((WARN++)) || true
    fi
}

printf '%s\n' "═══════════════════════════════════════════"
printf '%s\n' "  POWERSHELL Domain Validation"
printf '%s\n' "═══════════════════════════════════════════"
printf '\n'

# Source exclusions helper if available
if [[ -f "$SCRIPT_DIR/../exclusions.sh" ]]; then
    source "$SCRIPT_DIR/../exclusions.sh"
    FLIGHT_HAS_EXCLUSIONS=true
else
    FLIGHT_HAS_EXCLUSIONS=false
fi

# Handle arguments or use defaults
if [[ $# -gt 0 ]]; then
    FILES=("$@")
elif [[ "$FLIGHT_HAS_EXCLUSIONS" == true ]]; then
    # Use exclusions-aware file discovery
    mapfile -t FILES < <(flight_get_files "*.ps1" "*.psm1" "*.psd1")
else
    # Fallback: use find (works on bash 3.2+, no globstar needed)
    # Redirect stdin from /dev/null to prevent hanging in piped contexts (curl | bash)
    mapfile -t FILES < <(find . -type f \( -name "*.ps1" -o -name "*.psm1" -o -name "*.psd1" \) -not -path "*/node_modules/*" -not -path "*/.git/*" -not -path "*/dist/*" -not -path "*/build/*" < /dev/null 2>/dev/null | sort)
fi

if [[ ${#FILES[@]} -eq 0 ]]; then
    yellow "No files found matching default patterns"
    printf '%s\n' "  Patterns: *.ps1 *.psm1 *.psd1..."
    printf '\n'
    green "  RESULT: SKIP (no files)"
    exit 0
fi

printf 'Files: %d\n\n' "${#FILES[@]}"

printf '\n%s\n' "## NEVER Rules"

# N1: Invoke-Expression with User Input
check "N1: Invoke-Expression with User Input" \
    grep -Ein "Invoke-Expression|[^a-zA-Z]iex\\s" "${FILES[@]}"

# N2: Plain Text Passwords in Code
check "N2: Plain Text Passwords in Code" \
    grep -Ein "-Password\\s+['\"][^'\"]+['\"]|password\\s*=\\s*['\"][^'\"]+['\"]" "${FILES[@]}"

# N3: Invoke-WebRequest Without -UseBasicParsing
check "N3: Invoke-WebRequest Without -UseBasicParsing" \
    bash -c 'for file in "$@"; do
# Check for Invoke-WebRequest or iwr without -UseBasicParsing
for f in "$@"; do
  grep -Ein '"'"'Invoke-WebRequest|[^a-zA-Z]iwr\s'"'"' "$f" 2>/dev/null | \
  grep -v '"'"'UseBasicParsing'"'"' | grep -v '"'"'SuppressMessage'"'"' | \
  sed "s|^|$f:|"
done
done' _ "${FILES[@]}"

# N4: ConvertTo-SecureString with -AsPlainText in Source
check "N4: ConvertTo-SecureString with -AsPlainText in Source" \
    grep -Ein "ConvertTo-SecureString.*-AsPlainText.*['\"][^'\"]+['\"]" "${FILES[@]}"

# N5: Using Aliases in Scripts
check "N5: Using Aliases in Scripts" \
    grep -En "^\\s*(%|[?]|\\bls\\b|\\bcat\\b|\\bcurl\\b|\\bwget\\b|\\bdiff\\b|\\bsort\\b)\\s" "${FILES[@]}"

# N6: Write-Host for Data Output
check "N6: Write-Host for Data Output" \
    grep -En "Write-Host.*\\\$[a-zA-Z]" "${FILES[@]}"

# N7: Positional Parameters in Scripts
check "N7: Positional Parameters in Scripts" \
    grep -En "\\b(Copy-Item|Move-Item|Set-Content|Out-File)\\s+[^-]" "${FILES[@]}"

# N9: Hardcoded Paths
check "N9: Hardcoded Paths" \
    bash -c 'for file in "$@"; do
# Exclude comment lines before checking for hardcoded paths
for f in "$@"; do
  grep -v '"'"'^\s*#'"'"' "$f" 2>/dev/null | grep -n "['"'"'\"][A-Za-z]:\\\|['"'"'\"]/tmp/" | \
  while read -r line; do echo "$f:$line"; done
done
done' _ "${FILES[@]}"

printf '\n%s\n' "## MUST Rules"

# M1: Set-StrictMode Required
check "M1: Set-StrictMode Required" \
    bash -c 'for file in "$@"; do
# Report files missing Set-StrictMode
grep -L '"'"'Set-StrictMode'"'"' "$@" 2>/dev/null | \
while read -r f; do echo "$f: Missing Set-StrictMode"; done
done' _ "${FILES[@]}"

# M2: ErrorActionPreference Stop for Critical Scripts
check "M2: ErrorActionPreference Stop for Critical Scripts" \
    bash -c 'for file in "$@"; do
# Report files missing ErrorActionPreference or -ErrorAction Stop
grep -L -E '"'"'\$ErrorActionPreference.*Stop|-ErrorAction\s+Stop'"'"' "$@" 2>/dev/null | \
while read -r f; do echo "$f: Missing ErrorActionPreference or -ErrorAction Stop"; done
done' _ "${FILES[@]}"

# M4: CmdletBinding for Advanced Functions
check "M4: CmdletBinding for Advanced Functions" \
    bash -c 'for file in "$@"; do
# Find functions without CmdletBinding
grep -Pzo '"'"'function\s+\w+[^{]*\{(?![^}]*\[CmdletBinding)'"'"' "$file"
done' _ "${FILES[@]}"

# M5: Approved Verbs for Functions
check "M5: Approved Verbs for Functions" \
    bash -c 'for file in "$@"; do
# Check for functions not using approved verbs
grep -Po '"'"'function\s+\K[A-Za-z]+-'"'"' "$file" | \
while read -r verb; do
  verb="${verb%-}"
  if ! pwsh -c "Get-Verb '"'"'$verb'"'"'" 2>/dev/null | grep -q "$verb"; then
    echo "$file: Unapproved verb '"'"'$verb'"'"'"
  fi
done
done' _ "${FILES[@]}"

# M6: Parameter Validation
check "M6: Parameter Validation" \
    grep -En "param\\s*\\(\\s*\\\$" "${FILES[@]}"

printf '\n%s\n' "## SHOULD Rules"

# S1: Use
warn "S1: Use" \
    bash -c 'grep -ql "#Requires" "$@" || echo "Pattern not found"' _ "${FILES[@]}"

# S2: Comment-Based Help
warn "S2: Comment-Based Help" \
    bash -c 'for file in "$@"; do
# Check functions without help comments
grep -Pzo '"'"'function\s+\w+[^}]*\{(?![^}]*\.SYNOPSIS)'"'"' "$file"
done' _ "${FILES[@]}"

# S3: ShouldProcess for Destructive Operations
warn "S3: ShouldProcess for Destructive Operations" \
    bash -c 'for file in "$@"; do
# Check for Set/Remove/New functions without ShouldProcess
grep -E '"'"'function\s+(Set|Remove|New|Clear|Disable|Enable)-'"'"' "$file" | \
while read -r line; do
  if ! grep -A20 "$line" "$file" | grep -q '"'"'SupportsShouldProcess'"'"'; then
    echo "$file: $line - Missing ShouldProcess"
  fi
done
done' _ "${FILES[@]}"

# S6: Explicitly Handle $null Comparisons
warn "S6: Explicitly Handle \$null Comparisons" \
    grep -En "\\\$\\w+\\s+-eq\\s+\\\$null|\\\$\\w+\\s+-ne\\s+\\\$null" "${FILES[@]}"

# S7: Avoid Global Variables
warn "S7: Avoid Global Variables" \
    grep -En "\\\$global:" "${FILES[@]}"

# S8: Avoid Empty Catch Blocks
warn "S8: Avoid Empty Catch Blocks" \
    grep -En "catch\\s*\\{\\s*\\}" "${FILES[@]}"

# S11: Use Join-Path for Path Construction
warn "S11: Use Join-Path for Path Construction" \
    grep -En "\\\$\\w+\\s*\\+\\s*['\"][\\\\/]|['\"][\\\\/]['\"]" "${FILES[@]}"

printf '\n%s\n' "## Info"

FUNCTION_COUNT=$( (grep -cE "^\s*function\s+\w+" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  Function definitions: %s\n' "$FUNCTION_COUNT"

CMDLETBINDING_COUNT=$( (grep -cE "\[CmdletBinding" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  Advanced functions: %s\n' "$CMDLETBINDING_COUNT"

TRY_CATCH_COUNT=$( (grep -cE "^\s*try\s*\{" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  Try-catch blocks: %s\n' "$TRY_CATCH_COUNT"

ERROR_ACTION_STOP=$( (grep -ci "-ErrorAction\s+Stop" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  Explicit error handling: %s\n' "$ERROR_ACTION_STOP"

COMMENT_HELP_BLOCKS=$( (grep -ci "\.SYNOPSIS" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  Functions with help: %s\n' "$COMMENT_HELP_BLOCKS"

printf '\n%s\n' "═══════════════════════════════════════════"
printf '  PASS: %d  FAIL: %d  WARN: %d\n' "$PASS" "$FAIL" "$WARN"
if [[ $FAIL -eq 0 ]]; then
    green "  RESULT: PASS"
else
    red "  RESULT: FAIL"
fi
printf '%s\n' "═══════════════════════════════════════════"

exit "$FAIL"
