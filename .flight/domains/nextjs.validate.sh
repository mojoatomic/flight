#!/usr/bin/env bash
# nextjs.validate.sh - Next
# Generated by flight-domain-compile from nextjs.flight
set -euo pipefail

# Script location for sourcing helpers
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Default: common file patterns
DEFAULT_PATTERNS="app/**/*.tsx app/**/*.ts app/*.tsx app/*.ts"
PASS=0
FAIL=0
WARN=0

red() { printf '\033[31m%s\033[0m\n' "$1"; }
green() { printf '\033[32m%s\033[0m\n' "$1"; }
yellow() { printf '\033[33m%s\033[0m\n' "$1"; }

check() {
    local name="$1"
    shift
    local result
    result=$("$@" 2>/dev/null) || true
    if [[ -z "$result" ]]; then
        green "✅ $name"
        ((PASS++)) || true
    else
        red "❌ $name"
        printf '%s\n' "$result" | head -10 | sed 's/^/   /'
        ((FAIL++)) || true
    fi
}

warn() {
    local name="$1"
    shift
    local result
    result=$("$@" 2>/dev/null) || true
    if [[ -z "$result" ]]; then
        green "✅ $name"
        ((PASS++)) || true
    else
        yellow "⚠️  $name"
        printf '%s\n' "$result" | head -5 | sed 's/^/   /'
        ((WARN++)) || true
    fi
}

printf '%s\n' "═══════════════════════════════════════════"
printf '%s\n' "  NEXTJS Domain Validation"
printf '%s\n' "═══════════════════════════════════════════"
printf '\n'

# Source exclusions helper if available
if [[ -f "$SCRIPT_DIR/../exclusions.sh" ]]; then
    source "$SCRIPT_DIR/../exclusions.sh"
    FLIGHT_HAS_EXCLUSIONS=true
else
    FLIGHT_HAS_EXCLUSIONS=false
fi

# Handle arguments or use defaults
if [[ $# -gt 0 ]]; then
    FILES=("$@")
elif [[ "$FLIGHT_HAS_EXCLUSIONS" == true ]]; then
    # Use exclusions-aware file discovery
    mapfile -t FILES < <(flight_get_files "*.tsx" "*.ts")
else
    # Fallback: use find (works on bash 3.2+, no globstar needed)
    mapfile -t FILES < <(find . -type f \( -name "*.tsx" -o -name "*.ts" \) -not -path "*/node_modules/*" -not -path "*/.git/*" -not -path "*/dist/*" -not -path "*/build/*" 2>/dev/null | sort)
fi

if [[ ${#FILES[@]} -eq 0 ]]; then
    yellow "No files found matching default patterns"
    printf '%s\n' "  Patterns: app/**/*.tsx app/**/*.ts app/*.tsx app/*.ts..."
    printf '\n'
    green "  RESULT: SKIP (no files)"
    exit 0
fi

printf 'Files: %d\n\n' "${#FILES[@]}"

printf '\n%s\n' "## NEVER Rules"

# N0: Inconsistent Source Directory Structure
check "N0: Inconsistent Source Directory Structure" \
    bash -c '# Only check if src/ exists (indicates src/ convention chosen)
if [ -d "src" ]; then
    found=0
    # Check for parallel directories that should be under src/
    for dir in lib components types utils hooks services helpers; do
        if [ -d "$dir" ] && [ -d "src/$dir" ]; then
            if [ $found -eq 0 ]; then
                echo "Split directory structure detected:"
                found=1
            fi
            echo "  $dir/ exists alongside src/$dir/"
        elif [ -d "$dir" ] && [ -d "src" ]; then
            # Even if src/$dir doesn'"'"'t exist, root $dir is wrong when src/ exists
            if [ $found -eq 0 ]; then
                echo "Split directory structure detected:"
                found=1
            fi
            echo "  $dir/ should be src/$dir/"
        fi
    done
fi' _ "${FILES[@]}"

# N1: 'use client' in page.tsx Files
check "N1: 'use client' in page.tsx Files" \
    bash -c 'for f in "$@"; do
    if [[ "$f" == *page.tsx ]]; then
        if head -5 "$f" | grep -q "'"'"'use client'"'"'\|\"use client\""; then
            echo "$f: page.tsx should be server component"
        fi
    fi
done' _ "${FILES[@]}"

# N2: React Hooks in Server Components
check "N2: React Hooks in Server Components" \
    bash -c 'for f in "$@"; do
    if ! grep -q "'"'"'use client'"'"'\|\"use client\"" "$f"; then
        if grep -qE '"'"'useState|useEffect|useRef|useCallback|useMemo|useReducer'"'"' "$f"; then
            echo "$f: has hooks but no '"'"'use client'"'"'"
        fi
    fi
done' _ "${FILES[@]}"

# N3: useEffect Fetch for Initial Page Data
check "N3: useEffect Fetch for Initial Page Data" \
    # Unknown check type: ast

# N4: process.env in Client Components
check "N4: process.env in Client Components" \
    bash -c 'for f in "$@"; do
    if grep -q "'"'"'use client'"'"'\|\"use client\"" "$f"; then
        if grep -E '"'"'process\.env\.'"'"' "$f" | grep -v '"'"'NEXT_PUBLIC_'"'"'; then
            echo "$f: uses non-public env in client"
        fi
    fi
done' _ "${FILES[@]}"

# N5: 'any' Type in Route Handlers
check "N5: 'any' Type in Route Handlers" \
    bash -c 'for f in "$@"; do
    if [[ "$f" == *route.ts ]]; then
        if grep -n '"'"': any'"'"' "$f"; then
            echo "$f"
        fi
    fi
done' _ "${FILES[@]}"

# N6: Hardcoded Multi-segment Routes
check "N6: Hardcoded Multi-segment Routes" \
    # Unknown check type: ast

# N7: console.log in App Directory
check "N7: console.log in App Directory" \
    # Unknown check type: ast

# N8: Fat Route Handlers (>100 lines)
check "N8: Fat Route Handlers (>100 lines)" \
    bash -c 'for f in "$@"; do
    if [[ "$f" == *route.ts ]]; then
        lines=$(wc -l < "$f")
        if [ "$lines" -gt 100 ]; then
            echo "$f: $lines lines (max 100)"
        fi
    fi
done' _ "${FILES[@]}"

# S6: Deprecated middleware.ts File (Next.js 16+)
warn "S6: Deprecated middleware.ts File (Next.js 16+)" \
    bash -c '# Check for middleware files at root or src level
for loc in "." "src"; do
  for ext in ts js; do
    if [ -f "$loc/middleware.$ext" ]; then
      echo "$loc/middleware.$ext: deprecated in Next.js 16+, rename to proxy.$ext"
      echo "  Migration: npx @next/codemod@canary middleware-to-proxy ."
    fi
  done
done' _ "${FILES[@]}"

printf '\n%s\n' "## SHOULD Rules"

# S1: Dynamic Routes Should Use notFound()
warn "S1: Dynamic Routes Should Use notFound()" \
    bash -c 'for f in "$@"; do
    if [[ "$f" == *\[*\]*page.tsx ]]; then
        if ! grep -q '"'"'notFound'"'"' "$f"; then
            echo "$f: dynamic route without notFound()"
        fi
    fi
done' _ "${FILES[@]}"

# S2: Consider Promise.all for Independent Fetches
warn "S2: Consider Promise.all for Independent Fetches" \
    bash -c 'for f in "$@"; do
    count=$(grep -c '"'"'await '"'"' "$f" 2>/dev/null || echo 0)
    if [ "$count" -gt 3 ]; then
        if ! grep -q '"'"'Promise.all'"'"' "$f"; then
            echo "$f: $count awaits without Promise.all"
        fi
    fi
done' _ "${FILES[@]}"

# S3: Pages Should Have loading.tsx
warn "S3: Pages Should Have loading.tsx" \
    bash -c 'find app -name '"'"'page.tsx'"'"' 2>/dev/null | while read page; do
    dir=$(dirname "$page")
    if [ ! -f "$dir/loading.tsx" ]; then
        echo "$dir: missing loading.tsx"
    fi
done | head -5' _ "${FILES[@]}"

# S4: Pages Should Have error.tsx
warn "S4: Pages Should Have error.tsx" \
    bash -c 'find app -name '"'"'page.tsx'"'"' 2>/dev/null | while read page; do
    dir=$(dirname "$page")
    if [ ! -f "$dir/error.tsx" ]; then
        echo "$dir: missing error.tsx"
    fi
done | head -5' _ "${FILES[@]}"

# S5: Server-Only Import for Sensitive Files
warn "S5: Server-Only Import for Sensitive Files" \
    bash -c 'for f in lib/db.ts lib/auth.ts lib/database.ts; do
    if [ -f "$f" ]; then
        if ! grep -q "import '"'"'server-only'"'"'" "$f"; then
            echo "$f: should import '"'"'server-only'"'"'"
        fi
    fi
done' _ "${FILES[@]}"

printf '\n%s\n' "## Info"

SERVER_COMPONENTS=$( (grep -rL "'use client'|"use client"" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  Server components: %s\n' "$SERVER_COMPONENTS"

CLIENT_COMPONENTS=$( (grep -rl "'use client'|"use client"" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  Client components: %s\n' "$CLIENT_COMPONENTS"

ROUTE_HANDLERS=$( (grep -E "route\.ts$" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  Route handlers: %s\n' "$ROUTE_HANDLERS"

SERVER_ACTIONS=$( (grep -rl "'use server'" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  Server action files: %s\n' "$SERVER_ACTIONS"

printf '\n%s\n' "═══════════════════════════════════════════"
printf '  PASS: %d  FAIL: %d  WARN: %d\n' "$PASS" "$FAIL" "$WARN"
if [[ $FAIL -eq 0 ]]; then
    green "  RESULT: PASS"
else
    red "  RESULT: FAIL"
fi
printf '%s\n' "═══════════════════════════════════════════"

exit "$FAIL"
