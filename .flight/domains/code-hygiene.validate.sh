#!/usr/bin/env bash
# code-hygiene.validate.sh - Universal code quality patterns that apply to ALL languages
# Generated by flight-domain-compile from code-hygiene.flight
set -euo pipefail

# Script location for sourcing helpers
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Default: common file patterns
DEFAULT_PATTERNS="**/*.js **/*.ts **/*.tsx **/*.jsx **/*.py **/*.go **/*.rs **/*.java **/*.c **/*.cpp **/*.h"
PASS=0
FAIL=0
WARN=0

red() { printf '\033[31m%s\033[0m\n' "$1"; }
green() { printf '\033[32m%s\033[0m\n' "$1"; }
yellow() { printf '\033[33m%s\033[0m\n' "$1"; }

check() {
    local name="$1"
    shift
    local result
    result=$("$@" 2>/dev/null) || true
    if [[ -z "$result" ]]; then
        green "✅ $name"
        ((PASS++)) || true
    else
        red "❌ $name"
        printf '%s\n' "$result" | head -10 | sed 's/^/   /'
        ((FAIL++)) || true
    fi
}

warn() {
    local name="$1"
    shift
    local result
    result=$("$@" 2>/dev/null) || true
    if [[ -z "$result" ]]; then
        green "✅ $name"
        ((PASS++)) || true
    else
        yellow "⚠️  $name"
        printf '%s\n' "$result" | head -5 | sed 's/^/   /'
        ((WARN++)) || true
    fi
}

printf '%s\n' "═══════════════════════════════════════════"
printf '%s\n' "  CODE-HYGIENE Domain Validation"
printf '%s\n' "═══════════════════════════════════════════"
printf '\n'

# Source exclusions helper if available
if [[ -f "$SCRIPT_DIR/../exclusions.sh" ]]; then
    source "$SCRIPT_DIR/../exclusions.sh"
    FLIGHT_HAS_EXCLUSIONS=true
else
    FLIGHT_HAS_EXCLUSIONS=false
fi

# Handle arguments or use defaults
if [[ $# -gt 0 ]]; then
    FILES=("$@")
elif [[ "$FLIGHT_HAS_EXCLUSIONS" == true ]]; then
    # Use exclusions-aware file discovery
    mapfile -t FILES < <(flight_get_files "*.js" "*.ts" "*.tsx" "*.jsx" "*.py" "*.go" "*.rs" "*.java" "*.c" "*.cpp" "*.h")
else
    # Fallback: use find (works on bash 3.2+, no globstar needed)
    mapfile -t FILES < <(find . -type f \( -name "*.js" -o -name "*.ts" -o -name "*.tsx" -o -name "*.jsx" -o -name "*.py" -o -name "*.go" -o -name "*.rs" -o -name "*.java" -o -name "*.c" -o -name "*.cpp" -o -name "*.h" \) -not -path "*/node_modules/*" -not -path "*/.git/*" -not -path "*/dist/*" -not -path "*/build/*" 2>/dev/null | sort)
fi

if [[ ${#FILES[@]} -eq 0 ]]; then
    yellow "No files found matching default patterns"
    printf '%s\n' "  Patterns: **/*.js **/*.ts **/*.tsx **/*.jsx **/*.py **/*.go **/*.rs **..."
    printf '\n'
    green "  RESULT: SKIP (no files)"
    exit 0
fi

printf 'Files: %d\n\n' "${#FILES[@]}"

printf '\n%s\n' "## NEVER Rules"

# N1: Generic Variable Names
check "N1: Generic Variable Names" \
    grep -En "^\\s*(const|let|var|)\\s*(data|result|temp|tmp|info|item|value|val|obj|thing|stuff|ret|res|output|input|payload)\\s*=" "${FILES[@]}"

# N2: Redundant Conditional Returns
check "N2: Redundant Conditional Returns" \
    grep -En "if\\s*\\([^)]+\\)\\s*return\\s+(true|false)\\s*;\\s*(else\\s*)?(return\\s+(true|false))?" "${FILES[@]}"

# N3: Ternary Returning Boolean Literals
check "N3: Ternary Returning Boolean Literals" \
    grep -En "\\?\\s*true\\s*:\\s*false|\\?\\s*false\\s*:\\s*true" "${FILES[@]}"

# N4: Redundant Boolean Comparisons
check "N4: Redundant Boolean Comparisons" \
    grep -En "===?\\s*true|===?\\s*false|!==?\\s*true|!==?\\s*false" "${FILES[@]}"

# N5: Magic Number Calculations
check "N5: Magic Number Calculations" \
    bash -c 'for f in "$@"; do
  grep -HnE '"'"'60\s*\*\s*60|24\s*\*\s*60|1000\s*\*\s*60|7\s*\*\s*24|1024\s*\*\s*1024'"'"' "$f" 2>/dev/null | \
    grep -v '"'"'[A-Z_]\{2,\}\s*='"'"'
done' _ "${FILES[@]}"

# N6: Generic Function Names
check "N6: Generic Function Names" \
    grep -En "function\\s+(handleData|processItem|processItems|doSomething|getData|setData|updateValue|handleEvent|processResult|transformData|handleInput|processInput)\\s*\\(|def\\s+(handle_data|process_item|do_something|get_data|set_data|update_value|handle_event|process_result|transform_data)\\s*\\(" "${FILES[@]}"

# N7: Single-Letter Variables Outside Loops
check "N7: Single-Letter Variables Outside Loops" \
    bash -c 'for f in "$@"; do
  # Find single letter assignments not in for/while lines
  # Exclude i, j for loops and x for simple lambdas
  grep -HnE '"'"'^\s*(const|let|var|)\s+[a-hk-wyz]\s*='"'"' "$f" 2>/dev/null | \
    grep -v '"'"'for\s*('"'"' | grep -v '"'"'while\s*('"'"'
done' _ "${FILES[@]}"

# N8: Console/Print Debugging in Production Code
check "N8: Console/Print Debugging in Production Code" \
    bash -c 'for f in "$@"; do
  # Skip test files
  if [[ "$f" == *"_test."* ]] || [[ "$f" == *".test."* ]] || \
     [[ "$f" == *"test_"* ]] || [[ "$f" == *"/tests/"* ]] || \
     [[ "$f" == *"_spec."* ]] || [[ "$f" == *".spec."* ]]; then
    continue
  fi
  grep -HnE '"'"'console\.(log|warn|error)\s*\(|print\s*\(|System\.out\.print|println!\s*\(|fmt\.Print'"'"' "$f" 2>/dev/null
done' _ "${FILES[@]}"

# N9: Negated Boolean Names
check "N9: Negated Boolean Names" \
    grep -En "(is|has|can|should|will)(Not|No)[A-Z]" "${FILES[@]}"

# N10_js: snake_case Declaration in JavaScript/TypeScript
check "N10_js: snake_case Declaration in JavaScript/TypeScript" \
    # Unknown check type: ast

# N10_py: camelCase Declaration in Python
check "N10_py: camelCase Declaration in Python" \
    # Unknown check type: ast

printf '\n%s\n' "## MUST Rules"

# M1: Boolean Variables Use Proper Prefixes
check "M1: Boolean Variables Use Proper Prefixes" \
    bash -c 'for f in "$@"; do
  # Find boolean assignments without proper prefix
  grep -HnE '"'"'(const|let|var)\s+[a-z]+\s*=\s*(true|false)\s*;'"'"' "$f" 2>/dev/null | \
    grep -vE '"'"'(is|has|can|should|will|was|did|does)[A-Z]'"'"'
done' _ "${FILES[@]}"

# M2: Collections Use Plural Names
check "M2: Collections Use Plural Names" \
    bash -c 'for f in "$@"; do
  # Find array literals assigned to singular names
  grep -HnE '"'"'(const|let|var)\s+(user|item|order|product|result|file|row|record|entry)\s*=\s*\['"'"' "$f" 2>/dev/null
done' _ "${FILES[@]}"

# M3: Constants Use UPPER_SNAKE_CASE
check "M3: Constants Use UPPER_SNAKE_CASE" \
    bash -c 'for f in "$@"; do
  # Find const with numeric value not in UPPER_CASE
  grep -HnE '"'"'const\s+[a-z][a-zA-Z]*\s*=\s*[0-9]+\s*;'"'"' "$f" 2>/dev/null | \
    grep -vE '"'"'const\s+[A-Z_]+\s*='"'"'
done' _ "${FILES[@]}"

# M4: Error Messages Include Context
check "M4: Error Messages Include Context" \
    bash -c 'for f in "$@"; do
  # Find short/generic error messages (less than 15 chars)
  grep -HnE "throw\s+new\s+Error\(['"'"'\"][^'"'"'\"]{0,15}['"'"'\"]|raise\s+.*Exception\(['"'"'\"][^'"'"'\"]{0,15}['"'"'\"]" "$f" 2>/dev/null
done' _ "${FILES[@]}"

# M5: Function Names Are Verb Phrases
check "M5: Function Names Are Verb Phrases" \
    bash -c 'for f in "$@"; do
  # Find function names that don'"'"'t start with common verb prefixes
  grep -HnE '"'"'^(export\s+)?(async\s+)?function\s+[a-z]+\s*\('"'"' "$f" 2>/dev/null | \
    grep -vE '"'"'function\s+(get|set|fetch|load|save|send|create|update|delete|remove|add|find|check|validate|is|has|can|should|handle|process|render|init|start|stop|on|do|make|build|parse|format|convert|to|from|ensure|assert|verify|compute|calculate|generate|transform|map|filter|reduce|sort|merge|split|join|open|close|read|write|run|execute|apply|reset|clear|register|subscribe|unsubscribe|publish|emit|dispatch|trigger|mount|unmount|connect|disconnect|enable|disable|show|hide|toggle|select|deselect|activate|deactivate|delay|wait|sleep|pause|retry|poll|defer|schedule|queue|batch|throttle|debounce)([A-Z]|\s*\()'"'"'
done' _ "${FILES[@]}"

printf '\n%s\n' "## Info"

GENERIC_NAMES=$( (grep -oE "\b(data|result|temp|info|item|value|obj)\s*=" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  Generic name assignments: %s\n' "$GENERIC_NAMES"

BOOLEAN_PREFIXES=$( (grep -oE "\b(is|has|can|should|will|was|did|does)[A-Z][a-zA-Z]*" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  Properly prefixed booleans: %s\n' "$BOOLEAN_PREFIXES"

UPPER_CONSTANTS=$( (grep -oE "\b[A-Z][A-Z_]+\s*=" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  UPPER_CASE constants: %s\n' "$UPPER_CONSTANTS"

CONSOLE_LOGS=$( (grep -cE "console\.(log|warn|error)\s*\(" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  Console.log calls: %s\n' "$CONSOLE_LOGS"

PRINT_STATEMENTS=$( (grep -cE "print\s*\(|println|fmt\.Print" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  Print statements: %s\n' "$PRINT_STATEMENTS"

printf '\n%s\n' "═══════════════════════════════════════════"
printf '  PASS: %d  FAIL: %d  WARN: %d\n' "$PASS" "$FAIL" "$WARN"
if [[ $FAIL -eq 0 ]]; then
    green "  RESULT: PASS"
else
    red "  RESULT: FAIL"
fi
printf '%s\n' "═══════════════════════════════════════════"

exit "$FAIL"
