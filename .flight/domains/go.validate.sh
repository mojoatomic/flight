#!/usr/bin/env bash
# go.validate.sh - Go (Golang) development patterns
# Generated by flight-domain-compile from go.flight
set -euo pipefail

# Script location for sourcing helpers
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Default: common file patterns
DEFAULT_PATTERNS="**/*.go"
PASS=0
FAIL=0
WARN=0

red() { printf '\033[31m%s\033[0m\n' "$1"; }
green() { printf '\033[32m%s\033[0m\n' "$1"; }
yellow() { printf '\033[33m%s\033[0m\n' "$1"; }

check() {
    local name="$1"
    shift
    local result
    result=$("$@" 2>/dev/null) || true
    if [[ -z "$result" ]]; then
        green "✅ $name"
        ((PASS++)) || true
    else
        red "❌ $name"
        printf '%s\n' "$result" | head -10 | sed 's/^/   /'
        ((FAIL++)) || true
    fi
}

warn() {
    local name="$1"
    shift
    local result
    result=$("$@" 2>/dev/null) || true
    if [[ -z "$result" ]]; then
        green "✅ $name"
        ((PASS++)) || true
    else
        yellow "⚠️  $name"
        printf '%s\n' "$result" | head -5 | sed 's/^/   /'
        ((WARN++)) || true
    fi
}

printf '%s\n' "═══════════════════════════════════════════"
printf '%s\n' "  GO Domain Validation"
printf '%s\n' "═══════════════════════════════════════════"
printf '\n'

# Source exclusions helper if available
if [[ -f "$SCRIPT_DIR/../exclusions.sh" ]]; then
    source "$SCRIPT_DIR/../exclusions.sh"
    FLIGHT_HAS_EXCLUSIONS=true
else
    FLIGHT_HAS_EXCLUSIONS=false
fi

# Handle arguments or use defaults
if [[ $# -gt 0 ]]; then
    FILES=("$@")
elif [[ "$FLIGHT_HAS_EXCLUSIONS" == true ]]; then
    # Use exclusions-aware file discovery
    mapfile -t FILES < <(flight_get_files "*.go")
else
    # Fallback: use find (works on bash 3.2+, no globstar needed)
    mapfile -t FILES < <(find . -type f \( -name "*.go" \) -not -path "*/node_modules/*" -not -path "*/.git/*" -not -path "*/dist/*" -not -path "*/build/*" 2>/dev/null | sort)
fi

if [[ ${#FILES[@]} -eq 0 ]]; then
    yellow "No files found matching default patterns"
    printf '%s\n' "  Patterns: **/*.go..."
    printf '\n'
    green "  RESULT: SKIP (no files)"
    exit 0
fi

printf 'Files: %d\n\n' "${#FILES[@]}"

printf '\n%s\n' "## NEVER Rules"

# N1: Ignored Errors
check "N1: Ignored Errors" \
    grep -En "[^_]\\s*,\\s*_\\s*:?=\\s*\\w+\\s*\\([^)]*\\)|_\\s*=\\s*\\w+\\.\\w+\\s*\\(" "${FILES[@]}"

# N2: Panic for Normal Error Handling
check "N2: Panic for Normal Error Handling" \
    grep -Ein "panic\\s*\\(\\s*(err|fmt\\.Errorf|errors\\.New|\"[^\"]*error|\"[^\"]*fail|\"[^\"]*invalid)" "${FILES[@]}"

# N3: math/rand for Security
check "N3: math/rand for Security" \
    grep -E "math/rand[\"/v2]*\"" "${FILES[@]}"

# N4: Defer in Loop
check "N4: Defer in Loop" \
    grep -Ezn "for\\s+[^{]*\\{[^}]*defer\\s+" "${FILES[@]}"

# N5: Goroutine without Lifetime Management
check "N5: Goroutine without Lifetime Management" \
    bash -c 'for f in "$@"; do
  # Look for goroutines without context, done channel, or WaitGroup
  if grep -qE '"'"'go\s+func\s*\('"'"' "$f" 2>/dev/null; then
    if ! grep -qE '"'"'context\.|<-done|<-ctx\.Done|sync\.WaitGroup|errgroup\.'"'"' "$f" 2>/dev/null; then
      echo "$f: goroutine found but no lifetime management (context, done channel, or WaitGroup)"
    fi
  fi
done' _ "${FILES[@]}"

# N6: Unbuffered Channel in Select with Default
check "N6: Unbuffered Channel in Select with Default" \
    grep -Ezn "select\\s*\\{[^}]*case\\s+[^<]*<-[^:]*:[^}]*default:" "${FILES[@]}"

# N7: Nil Map Write
check "N7: Nil Map Write" \
    grep -En "var\\s+\\w+\\s+map\\[[^\\]]+\\][^\\n=]*\$" "${FILES[@]}"

# N8: Range Loop Variable Capture (Pre-Go 1.22)
check "N8: Range Loop Variable Capture (Pre-Go 1.22)" \
    grep -Ezn "for\\s+[^,]+,?\\s*(\\w+)\\s*:?=\\s*range[^{]*\\{[^}]*go\\s+func\\s*\\([^)]*\\)\\s*\\{[^}]*\\1" "${FILES[@]}"

printf '\n%s\n' "## MUST Rules"

# M1: MixedCaps Naming
check "M1: MixedCaps Naming" \
    grep -En "(func|var|const|type)\\s+[a-z]+_[a-z]+\\s*[=(]" "${FILES[@]}"

# M2: Initialisms Must Be Consistent Case
check "M2: Initialisms Must Be Consistent Case" \
    grep -En "(Url|Http|Api|Sql|Json|Xml|Html|Css|Tcp|Udp|Ip|Dns|Cpu|Gpu|Ram|Ssd|Hdd|Usb|Pdf|Csv)[A-Z]|(Url|Http|Api|Sql|Json|Xml|Html|Css|Tcp|Udp|Ip|Dns|Cpu|Gpu|Ram|Ssd|Hdd|Usb|Pdf|Csv)\\s*[=:(]" "${FILES[@]}"

# M3: Exported Names Must Have Doc Comments
check "M3: Exported Names Must Have Doc Comments" \
    bash -c 'for f in "$@"; do
  # Find exported functions/types without preceding comment
  awk '"'"'
    /^func [A-Z]/ && prev !~ /^\/\// { print FILENAME ":" NR ": " $0 }
    /^type [A-Z]/ && prev !~ /^\/\// { print FILENAME ":" NR ": " $0 }
    /^var [A-Z]/ && prev !~ /^\/\// { print FILENAME ":" NR ": " $0 }
    /^const [A-Z]/ && prev !~ /^\/\// { print FILENAME ":" NR ": " $0 }
    { prev = $0 }
  '"'"' "$f" 2>/dev/null
done' _ "${FILES[@]}"

# M4: Context as First Parameter
check "M4: Context as First Parameter" \
    grep -En "func\\s+\\w+\\([^)]*,\\s*ctx\\s+context\\.Context|func\\s+\\w+\\([^)]*context\\.Context[^)]*,[^)]+\\)\\s*[^{]*\\{" "${FILES[@]}"

# M5: Error Variable Naming
check "M5: Error Variable Naming" \
    grep -En "var\\s+[A-Z][a-z]+Error\\s*=" "${FILES[@]}"

# M6: Package Names Must Be Lowercase
check "M6: Package Names Must Be Lowercase" \
    grep -En "^package\\s+[A-Z_]|^package\\s+\\w+_\\w+" "${FILES[@]}"

# M7: Receiver Name Consistency
check "M7: Receiver Name Consistency" \
    grep -Ein "func\\s*\\(\\s*(this|self|me|my)\\s+" "${FILES[@]}"

# M8: Error Strings Lowercase
check "M8: Error Strings Lowercase" \
    grep -En "errors\\.New\\s*\\(\\s*\"[A-Z]|fmt\\.Errorf\\s*\\(\\s*\"[A-Z]|errors\\.New\\s*\\([^)]*\\.\\s*\"\\s*\\)|fmt\\.Errorf\\s*\\([^)]*\\.\\s*\"\\s*\\)" "${FILES[@]}"

printf '\n%s\n' "## SHOULD Rules"

# S1: Wrap Errors with Context
warn "S1: Wrap Errors with Context" \
    bash -c 'for f in "$@"; do
  # Look for bare error returns without wrapping
  if grep -qE '"'"'return\s+(nil,\s*)?err\s*$'"'"' "$f" 2>/dev/null; then
    if ! grep -qE '"'"'fmt\.Errorf.*%w|errors\.Wrap|errors\.WithMessage'"'"' "$f" 2>/dev/null; then
      echo "$f: bare error returns found but no error wrapping"
    fi
  fi
done' _ "${FILES[@]}"

# S2: Table-Driven Tests
warn "S2: Table-Driven Tests" \
    bash -c 'for f in "$@"; do
  if [[ "$f" == *"_test.go" ]]; then
    # Multiple similar test functions suggest table-driven would be better
    count=$(grep -cE '"'"'^func Test\w+\('"'"' "$f" 2>/dev/null || echo 0)
    if [[ "$count" -gt 5 ]]; then
      if ! grep -qE '"'"'tests?\s*:?=\s*\[\]struct|for\s+.*,\s*tt\s*:=\s*range'"'"' "$f" 2>/dev/null; then
        echo "$f: $count test functions - consider table-driven tests"
      fi
    fi
  fi
done' _ "${FILES[@]}"

# S3: Prefer var for Zero Values
warn "S3: Prefer var for Zero Values" \
    grep -En ":=\\s*\\[\\][a-zA-Z]+\\{\\s*\\}|:=\\s*make\\s*\\(\\s*\\[\\][a-zA-Z]+\\s*,\\s*0\\s*\\)" "${FILES[@]}"

# S4: Synchronous Functions Preferred
warn "S4: Synchronous Functions Preferred" \
    grep -Ezn "func\\s+\\w+\\([^)]*chan\\s*<-[^)]*\\)\\s*\\{[^}]*go\\s+func" "${FILES[@]}"

# S5: Project Structure
warn "S5: Project Structure" \
    bash -c '# Only check if this looks like a project root (has go.mod)
if [[ -f "go.mod" ]]; then
  issues=""
  # Check for proper cmd/ structure for multiple binaries
  if ls cmd/*/main.go 2>/dev/null | wc -l | grep -q '"'"'^0$'"'"'; then
    if ls *.go 2>/dev/null | grep -v _test.go | wc -l | grep -qv '"'"'^[01]$'"'"'; then
      : # OK - single binary project
    fi
  fi
  # Check for internal/ misuse
  if [[ -d "internal" ]] && ls internal/*.go 2>/dev/null | grep -q .; then
    : # OK
  fi
  # Warn about pkg/ antipattern
  if [[ -d "pkg" ]]; then
    echo "pkg/ directory found - consider using internal/ instead"
  fi
fi' _ "${FILES[@]}"

# S6: Use t.Helper in Test Helpers
warn "S6: Use t.Helper in Test Helpers" \
    bash -c 'for f in "$@"; do
  if [[ "$f" == *"_test.go" ]]; then
    # Find functions that take *testing.T but don'"'"'t call t.Helper()
    awk '"'"'
      /func [a-z]\w*\([^)]*\*testing\.(T|B)/ && !/t\.Helper\(\)/ {
        # Read until end of function
        start = NR
        while ((getline line) > 0) {
          if (line ~ /t\.Helper\(\)/) { next }
          if (line ~ /^}$/) {
            print FILENAME ":" start ": test helper missing t.Helper()"
            break
          }
        }
      }
    '"'"' "$f" 2>/dev/null
  fi
done' _ "${FILES[@]}"

# S7: Avoid Global State
warn "S7: Avoid Global State" \
    grep -En "^var\\s+\\w+\\s*=\\s*&?\\w+\\{|^var\\s+\\w+\\s+\\*\\w+\\s*\$" "${FILES[@]}"

# S8: Mutex Field Naming
warn "S8: Mutex Field Naming" \
    grep -En "sync\\.(Mutex|RWMutex)\\s*\$" "${FILES[@]}"

# S9: Check Errors Before Using Defer
warn "S9: Check Errors Before Using Defer" \
    grep -Ezn "\\w+,\\s*_\\s*:?=\\s*\\w+\\.[^)]+\\)\\s*\\n\\s*defer" "${FILES[@]}"

# S10: Indent Error Flow
warn "S10: Indent Error Flow" \
    grep -Ezn "if\\s+err\\s*==\\s*nil\\s*\\{[^}]+\\}\\s*else\\s*\\{" "${FILES[@]}"

# S11: Avoid Init Functions
warn "S11: Avoid Init Functions" \
    grep -En "^func init\\s*\\(\\s*\\)" "${FILES[@]}"

# S12: Use Meaningful Test Names
warn "S12: Use Meaningful Test Names" \
    grep -En "func Test[A-Z][a-z]*\\s*\\(" "${FILES[@]}"

printf '\n%s\n' "## Info"

GOROUTINE_COUNT=$( (grep -cE "go\s+func|go\s+\w+\(" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  Goroutine spawns: %s\n' "$GOROUTINE_COUNT"

CHANNEL_COUNT=$( (grep -cE "make\s*\(\s*chan\s|chan\s+\w+" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  Channel declarations: %s\n' "$CHANNEL_COUNT"

ERROR_HANDLING=$( (grep -cE "if\s+err\s*!=\s*nil" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  Error checks: %s\n' "$ERROR_HANDLING"

TEST_COUNT=$( (grep -cE "^func Test\w+\(" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  Test functions: %s\n' "$TEST_COUNT"

INTERFACE_COUNT=$( (grep -cE "type\s+\w+\s+interface\s*\{" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  Interface definitions: %s\n' "$INTERFACE_COUNT"

STRUCT_COUNT=$( (grep -cE "type\s+\w+\s+struct\s*\{" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  Struct definitions: %s\n' "$STRUCT_COUNT"

printf '\n%s\n' "═══════════════════════════════════════════"
printf '  PASS: %d  FAIL: %d  WARN: %d\n' "$PASS" "$FAIL" "$WARN"
if [[ $FAIL -eq 0 ]]; then
    green "  RESULT: PASS"
else
    red "  RESULT: FAIL"
fi
printf '%s\n' "═══════════════════════════════════════════"

exit "$FAIL"
