#!/usr/bin/env bash
# sms-twilio.validate.sh - SMS consent management, opt-in/opt-out handling, and Twilio error code interpretation
# Generated by flight-domain-compile from sms-twilio.flight
set -euo pipefail

# Script location for sourcing helpers
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Default: common file patterns
DEFAULT_PATTERNS="**/sms*.js **/sms*.ts **/*twilio*.js **/*twilio*.ts **/consent*.js **/consent*.ts **/sms*.py **/twilio*.py"
PASS=0
FAIL=0
WARN=0

red() { printf '\033[31m%s\033[0m\n' "$1"; }
green() { printf '\033[32m%s\033[0m\n' "$1"; }
yellow() { printf '\033[33m%s\033[0m\n' "$1"; }

check() {
    local name="$1"
    shift
    local result
    result=$("$@" 2>/dev/null) || true
    if [[ -z "$result" ]]; then
        green "✅ $name"
        ((PASS++)) || true
    else
        red "❌ $name"
        printf '%s\n' "$result" | head -10 | sed 's/^/   /'
        ((FAIL++)) || true
    fi
}

warn() {
    local name="$1"
    shift
    local result
    result=$("$@" 2>/dev/null) || true
    if [[ -z "$result" ]]; then
        green "✅ $name"
        ((PASS++)) || true
    else
        yellow "⚠️  $name"
        printf '%s\n' "$result" | head -5 | sed 's/^/   /'
        ((WARN++)) || true
    fi
}

printf '%s\n' "═══════════════════════════════════════════"
printf '%s\n' "  SMS-TWILIO Domain Validation"
printf '%s\n' "═══════════════════════════════════════════"
printf '\n'

# Source exclusions helper if available
if [[ -f "$SCRIPT_DIR/../exclusions.sh" ]]; then
    source "$SCRIPT_DIR/../exclusions.sh"
    FLIGHT_HAS_EXCLUSIONS=true
else
    FLIGHT_HAS_EXCLUSIONS=false
fi

# Handle arguments or use defaults
if [[ $# -gt 0 ]]; then
    FILES=("$@")
elif [[ "$FLIGHT_HAS_EXCLUSIONS" == true ]]; then
    # Use exclusions-aware file discovery
    mapfile -t FILES < <(flight_get_files "sms*.js" "sms*.ts" "*twilio*.js" "*twilio*.ts" "consent*.js" "consent*.ts" "sms*.py" "twilio*.py")
else
    # Fallback: use find (works on bash 3.2+, no globstar needed)
    mapfile -t FILES < <(find . -type f \( -name "sms*.js" -o -name "sms*.ts" -o -name "*twilio*.js" -o -name "*twilio*.ts" -o -name "consent*.js" -o -name "consent*.ts" -o -name "sms*.py" -o -name "twilio*.py" \) -not -path "*/node_modules/*" -not -path "*/.git/*" -not -path "*/dist/*" -not -path "*/build/*" 2>/dev/null | sort)
fi

if [[ ${#FILES[@]} -eq 0 ]]; then
    yellow "No files found matching default patterns"
    printf '%s\n' "  Patterns: **/sms*.js **/sms*.ts **/*twilio*.js **/*twilio*.ts **/conse..."
    printf '\n'
    green "  RESULT: SKIP (no files)"
    exit 0
fi

printf 'Files: %d\n\n' "${#FILES[@]}"

printf '\n%s\n' "## NEVER Rules"

# N1: Consent States Defined
check "N1: Consent States Defined" \
    bash -c 'strip_comments() {
  grep -v "^\s*//" "$1" 2>/dev/null | grep -v "^\s*#" | grep -v "^\s*\*"
}
found=0
for f in "$@"; do
  if strip_comments "$f" | grep -qEi "OPTED_IN|OPTED_OUT"; then
    found=1
    break
  fi
done
[[ $found -eq 0 ]] && echo "No consent states found"' _ "${FILES[@]}"

# N2: Never Send to OPTED_OUT or UNKNOWN
check "N2: Never Send to OPTED_OUT or UNKNOWN" \
    grep -Ein "OPTED_OUT.*send|UNKNOWN.*send|send.*OPTED_OUT|send.*UNKNOWN" "${FILES[@]}"

# N3: Consent Check Before Sending
check "N3: Consent Check Before Sending" \
    bash -c 'strip_comments() {
  grep -v "^\s*//" "$1" 2>/dev/null | grep -v "^\s*#" | grep -v "^\s*\*"
}
for f in "$@"; do
  if strip_comments "$f" | grep -qEi "sendSMS|send.*message|twilio.*messages.*create"; then
    if ! strip_comments "$f" | grep -qEi "consent|opted.?in|OPTED_IN|getConsent"; then
      printf "%s: sends without consent check\n" "$f"
    fi
  fi
done' _ "${FILES[@]}"

# N4: STOP Keyword Triggers State Change
check "N4: STOP Keyword Triggers State Change" \
    bash -c 'strip_comments() {
  grep -v "^\s*//" "$1" 2>/dev/null | grep -v "^\s*#" | grep -v "^\s*\*"
}
for f in "$@"; do
  if strip_comments "$f" | grep -qEi "STOP"; then
    if ! strip_comments "$f" | grep -qEi "OPTED_OUT|updateConsent|setState|optOut"; then
      printf "%s: STOP found but no state change\n" "$f"
    fi
  fi
done' _ "${FILES[@]}"

# N5: Error 21610 Marks OPTED_OUT
check "N5: Error 21610 Marks OPTED_OUT" \
    bash -c 'strip_comments() {
  grep -v "^\s*//" "$1" 2>/dev/null | grep -v "^\s*#" | grep -v "^\s*\*"
}
for f in "$@"; do
  if strip_comments "$f" | grep -qEi "twilio|sendSMS|messages.*create"; then
    if ! strip_comments "$f" | grep -qEi "21610"; then
      printf "%s: no 21610 handling\n" "$f"
    fi
  fi
done' _ "${FILES[@]}"

# N6: Error 30004 Marks OPTED_OUT
check "N6: Error 30004 Marks OPTED_OUT" \
    bash -c 'strip_comments() {
  grep -v "^\s*//" "$1" 2>/dev/null | grep -v "^\s*#" | grep -v "^\s*\*"
}
for f in "$@"; do
  if strip_comments "$f" | grep -qEi "twilio|sendSMS|messages.*create"; then
    if ! strip_comments "$f" | grep -qEi "30004"; then
      printf "%s: no 30004 handling\n" "$f"
    fi
  fi
done' _ "${FILES[@]}"

# N7: No Retry on Opt-Out Errors
check "N7: No Retry on Opt-Out Errors" \
    bash -c 'strip_comments() {
  grep -v "^\s*//" "$1" 2>/dev/null | grep -v "^\s*#" | grep -v "^\s*\*"
}
for f in "$@"; do
  result=$(strip_comments "$f" | grep -Ein "21610.*retry|30004.*retry|retry.*21610|retry.*30004" 2>/dev/null) || true
  if [[ -n "$result" ]]; then
    printf "%s:%s\n" "$f" "$result"
  fi
done' _ "${FILES[@]}"

# N8: Error 30005/30006 Marks Number INVALID
check "N8: Error 30005/30006 Marks Number INVALID" \
    bash -c 'strip_comments() {
  grep -v "^\s*//" "$1" 2>/dev/null | grep -v "^\s*#" | grep -v "^\s*\*"
}
for f in "$@"; do
  if strip_comments "$f" | grep -qEi "twilio|sendSMS|messages.*create"; then
    if ! strip_comments "$f" | grep -qEi "30005|30006|invalid.*number|landline|INVALID"; then
      printf "%s: no 30005/30006 handling\n" "$f"
    fi
  fi
done' _ "${FILES[@]}"

# N9: First Message Includes Opt-Out Instructions
check "N9: First Message Includes Opt-Out Instructions" \
    bash -c 'strip_comments() {
  grep -v "^\s*//" "$1" 2>/dev/null | grep -v "^\s*#" | grep -v "^\s*\*"
}
for f in "$@"; do
  if strip_comments "$f" | grep -qEi "first.?message|welcome|initial|confirm.*message"; then
    if ! strip_comments "$f" | grep -qEi "STOP|opt.?out|unsubscribe"; then
      printf "%s: first message may lack opt-out\n" "$f"
    fi
  fi
done' _ "${FILES[@]}"

# N10: No Hardcoded Phone Numbers
check "N10: No Hardcoded Phone Numbers" \
    grep -Ein "\"\\+1[0-9]{10}\"|\\x27\\+1[0-9]{10}\\x27" "${FILES[@]}"

# N11: No Hardcoded Twilio Credentials
check "N11: No Hardcoded Twilio Credentials" \
    grep -Ein "ACCOUNT_SID\\s*=\\s*['\"]AC|AUTH_TOKEN\\s*=\\s*['\"][a-f0-9]{32}" "${FILES[@]}"

printf '\n%s\n' "## SHOULD Rules"

# S1: START/UNSTOP Keywords Handled
warn "S1: START/UNSTOP Keywords Handled" \
    bash -c 'strip_comments() {
  grep -v "^\s*//" "$1" 2>/dev/null | grep -v "^\s*#" | grep -v "^\s*\*"
}
found=0
for f in "$@"; do
  if strip_comments "$f" | grep -qEi "START|UNSTOP"; then
    found=1
    break
  fi
done
[[ $found -eq 0 ]] && echo "No START/UNSTOP handling"' _ "${FILES[@]}"

# S2: HELP Keyword Response
warn "S2: HELP Keyword Response" \
    bash -c 'strip_comments() {
  grep -v "^\s*//" "$1" 2>/dev/null | grep -v "^\s*#" | grep -v "^\s*\*"
}
found=0
for f in "$@"; do
  if strip_comments "$f" | grep -qEi "HELP.*response|help.?message|HELP.*reply"; then
    found=1
    break
  fi
done
[[ $found -eq 0 ]] && echo "No HELP response"' _ "${FILES[@]}"

# S3: Temporary Errors Retry with Backoff
warn "S3: Temporary Errors Retry with Backoff" \
    bash -c 'strip_comments() {
  grep -v "^\s*//" "$1" 2>/dev/null | grep -v "^\s*#" | grep -v "^\s*\*"
}
found=0
for f in "$@"; do
  if strip_comments "$f" | grep -qEi "30003|30017|backoff|exponential|retry.*delay"; then
    found=1
    break
  fi
done
[[ $found -eq 0 ]] && echo "No retry backoff"' _ "${FILES[@]}"

# S4: Rate Limit Errors Handled
warn "S4: Rate Limit Errors Handled" \
    bash -c 'strip_comments() {
  grep -v "^\s*//" "$1" 2>/dev/null | grep -v "^\s*#" | grep -v "^\s*\*"
}
found=0
for f in "$@"; do
  if strip_comments "$f" | grep -qEi "30022|30023|30027|rate.?limit|daily.?cap"; then
    found=1
    break
  fi
done
[[ $found -eq 0 ]] && echo "No rate limit handling"' _ "${FILES[@]}"

# S5: Business Name in Messages
warn "S5: Business Name in Messages" \
    bash -c 'strip_comments() {
  grep -v "^\s*//" "$1" 2>/dev/null | grep -v "^\s*#" | grep -v "^\s*\*"
}
found=0
for f in "$@"; do
  if strip_comments "$f" | grep -qEi "business.?name|brand|company.*:"; then
    found=1
    break
  fi
done
[[ $found -eq 0 ]] && echo "No business name in messages"' _ "${FILES[@]}"

# S6: Opt-Out Confirmation Message
warn "S6: Opt-Out Confirmation Message" \
    bash -c 'strip_comments() {
  grep -v "^\s*//" "$1" 2>/dev/null | grep -v "^\s*#" | grep -v "^\s*\*"
}
found=0
for f in "$@"; do
  if strip_comments "$f" | grep -qEi "unsubscribed|opt.?out.*confirm|OPT_OUT_CONFIRMED"; then
    found=1
    break
  fi
done
[[ $found -eq 0 ]] && echo "No opt-out confirmation"' _ "${FILES[@]}"

# S7: Double Opt-In Flow
warn "S7: Double Opt-In Flow" \
    bash -c 'strip_comments() {
  grep -v "^\s*//" "$1" 2>/dev/null | grep -v "^\s*#" | grep -v "^\s*\*"
}
found=0
for f in "$@"; do
  if strip_comments "$f" | grep -qEi "double.?opt|PENDING.*OPTED_IN|confirm.*yes|reply.*yes"; then
    found=1
    break
  fi
done
[[ $found -eq 0 ]] && echo "No double opt-in"' _ "${FILES[@]}"

# S8: Message Logging for Audit
warn "S8: Message Logging for Audit" \
    bash -c 'strip_comments() {
  grep -v "^\s*//" "$1" 2>/dev/null | grep -v "^\s*#" | grep -v "^\s*\*"
}
found=0
for f in "$@"; do
  if strip_comments "$f" | grep -qEi "log.*message|audit|sms_log|message.*log"; then
    found=1
    break
  fi
done
[[ $found -eq 0 ]] && echo "No message logging"' _ "${FILES[@]}"

# S9: Consent Timestamps Tracked
warn "S9: Consent Timestamps Tracked" \
    bash -c 'strip_comments() {
  grep -v "^\s*//" "$1" 2>/dev/null | grep -v "^\s*#" | grep -v "^\s*\*"
}
found=0
for f in "$@"; do
  if strip_comments "$f" | grep -qEi "opted_in_at|opted_out_at|consent.*time|timestamp"; then
    found=1
    break
  fi
done
[[ $found -eq 0 ]] && echo "No consent timestamps"' _ "${FILES[@]}"

printf '\n%s\n' "═══════════════════════════════════════════"
printf '  PASS: %d  FAIL: %d  WARN: %d\n' "$PASS" "$FAIL" "$WARN"
if [[ $FAIL -eq 0 ]]; then
    green "  RESULT: PASS"
else
    red "  RESULT: FAIL"
fi
printf '%s\n' "═══════════════════════════════════════════"

exit "$FAIL"
