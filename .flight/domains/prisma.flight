# prisma.flight - Prisma ORM patterns for TypeScript/Next.js
# Source: Official Prisma docs, multi-tenant best practices, error handling patterns

domain: prisma
version: 1.1.0
schema_version: 2
description: >
  Prisma ORM patterns for TypeScript/Next.js applications with multi-tenant SaaS focus.
  Covers schema design, query patterns, N+1 prevention, error handling, connection management,
  and orgId-scoped data access for tenant isolation.

file_patterns:
  - "**/*.ts"
  - "**/*.tsx"
  - "**/schema.prisma"

exclude_patterns:
  - "**/node_modules/**"
  - "**/dist/**"
  - "**/build/**"
  - "**/.git/**"
  - "**/*.d.ts"
  - "**/prisma/migrations/**"

provenance:
  last_full_audit: "2026-01-20"
  audited_by: "flight-research"
  next_audit_due: "2026-07-20"

  sources_consulted:
    - url: "https://www.prisma.io/docs/orm/prisma-client/queries"
      accessed: "2026-01-20"
      note: "Prisma Client query documentation"
    - url: "https://www.prisma.io/docs/orm/reference/error-reference"
      accessed: "2026-01-20"
      note: "Prisma error codes reference"
    - url: "https://www.prisma.io/docs/orm/prisma-client/debugging-and-troubleshooting/handling-exceptions-and-errors"
      accessed: "2026-01-20"
      note: "Exception handling patterns"
    - url: "https://www.prisma.io/docs/orm/prisma-client/using-raw-sql/raw-queries"
      accessed: "2026-01-20"
      note: "Raw SQL and injection prevention"
    - url: "https://www.prisma.io/docs/orm/prisma-client/queries/query-optimization-performance"
      accessed: "2026-01-20"
      note: "Query optimization and N+1 prevention"
    - url: "https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections"
      accessed: "2026-01-20"
      note: "Connection management and pooling"

  coverage:
    apis_covered:
      - "Query methods (findMany, findFirst, findUnique, create, update, delete)"
      - "Error handling (P2002, P2003, P2025, P2014)"
      - "Raw SQL ($queryRaw, $executeRaw)"
      - "Transactions ($transaction)"
      - "Relation loading (include, select)"
      - "Multi-tenant patterns (orgId scoping)"
      - "Connection pooling and singleton pattern"
    known_gaps:
      - "Prisma Accelerate configuration"
      - "Prisma Pulse (real-time subscriptions)"
      - "Prisma Migrate vs db push workflows"
      - "Complex aggregation queries"
      - "Middleware patterns"

# ===========================================================================
# RULES
# ===========================================================================
# Prisma-SPECIFIC rules for multi-tenant Next.js/TypeScript applications.
# These catch common AI mistakes with Prisma queries, error handling, and
# connection management.
#
# ID format: {severity_prefix}{number}
#   N = NEVER (check - fails build)
#   M = MUST (check - currently implemented as warn)
#   S = SHOULD (warn - advisory)
#   G = GUIDANCE (not checked)
# ===========================================================================

rules:

  # =========================================================================
  # NEVER - Security and correctness violations (validator will reject)
  # =========================================================================

  N1:
    title: Queries Without orgId (Multi-tenant)
    severity: NEVER
    mechanical: false
    provenance:
      last_verified: "2026-01-20"
      confidence: high
      re_verify_after: "2027-01-20"
      sources:
        - url: "https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting"
          accessed: "2026-01-20"
          quote: "Use where to filter records based on field values"
    description: >
      All data queries must include orgId for tenant isolation. Queries without
      orgId can leak data between tenants in multi-tenant applications.
    note: |
      In multi-tenant SaaS, the organization is the tenant boundary:
      - Data belongs to organizations, not individual users
      - Users can access data in orgs they belong to
      - Always filter by orgId

      BAD:  prisma.post.findMany()
      BAD:  prisma.post.findMany({ where: { published: true } })
      GOOD: prisma.post.findMany({ where: { orgId } })
      GOOD: prisma.post.findMany({ where: { orgId, published: true } })
    examples:
      bad:
        - "prisma.post.findMany()"
        - "prisma.post.findMany({ where: { published: true } })"
      good:
        - "prisma.post.findMany({ where: { orgId } })"
        - "prisma.post.findMany({ where: { orgId, published: true } })"

  N2:
    title: $queryRawUnsafe with User Input
    severity: NEVER
    mechanical: true
    provenance:
      last_verified: "2026-01-20"
      confidence: high
      re_verify_after: "2027-01-20"
      sources:
        - url: "https://www.prisma.io/docs/orm/prisma-client/using-raw-sql/raw-queries"
          accessed: "2026-01-20"
          quote: "Using $queryRawUnsafe with user input is vulnerable to SQL injection"
    description: >
      $queryRawUnsafe bypasses parameterization. Using it with user input
      creates SQL injection vulnerabilities. Use $queryRaw with tagged
      templates instead.
    check:
      type: grep
      pattern: '\$queryRawUnsafe|\$executeRawUnsafe'
      flags: -En
    note: |
      $queryRawUnsafe and $executeRawUnsafe are vulnerable to SQL injection
      when used with user input. Use the safe versions with tagged templates:

      BAD:  prisma.$queryRawUnsafe(`SELECT * FROM users WHERE id = '${userId}'`)
      GOOD: prisma.$queryRaw`SELECT * FROM users WHERE id = ${userId}`

      The tagged template version creates prepared statements that are safe
      from SQL injection. Only use *Unsafe methods for trusted, hardcoded queries.
    examples:
      bad:
        - "prisma.$queryRawUnsafe(`SELECT * FROM users WHERE id = '${userId}'`)"
        - "prisma.$executeRawUnsafe(`DELETE FROM posts WHERE id = ${id}`)"
      good:
        - "prisma.$queryRaw`SELECT * FROM users WHERE id = ${userId}`"
        - "prisma.$executeRaw`DELETE FROM posts WHERE id = ${id}`"

  N3:
    title: N+1 Query Pattern
    severity: NEVER
    mechanical: false
    provenance:
      last_verified: "2026-01-20"
      confidence: high
      re_verify_after: "2027-01-20"
      sources:
        - url: "https://www.prisma.io/docs/orm/prisma-client/queries/query-optimization-performance"
          accessed: "2026-01-20"
          quote: "Solving the n+1 problem: Use include to return all relations"
    description: >
      Fetching related data in loops instead of using include creates N+1 queries.
      This causes severe performance issues as the number of records grows.
    note: |
      The N+1 problem occurs when you query in a loop:

      BAD:
        const users = await prisma.user.findMany()
        for (const user of users) {
          const posts = await prisma.post.findMany({ where: { userId: user.id } })
        }

      GOOD:
        const users = await prisma.user.findMany({
          include: { posts: true }
        })

      Use include or select with nested relations to fetch related data
      in a single query.
    examples:
      bad:
        - |
          const users = await prisma.user.findMany()
          for (const user of users) {
            const posts = await prisma.post.findMany({ where: { userId: user.id } })
          }
      good:
        - |
          const users = await prisma.user.findMany({
            include: { posts: true }
          })

  N4:
    title: Unhandled Prisma Errors
    severity: NEVER
    mechanical: false
    provenance:
      last_verified: "2026-01-20"
      confidence: high
      re_verify_after: "2027-01-20"
      sources:
        - url: "https://www.prisma.io/docs/orm/prisma-client/debugging-and-troubleshooting/handling-exceptions-and-errors"
          accessed: "2026-01-20"
          quote: "Prisma Client throws a PrismaClientKnownRequestError exception if the query engine returns a known error"
    description: >
      Prisma throws specific error codes (P2002, P2025, etc.) that need handling.
      Generic catch blocks hide the actual error and provide poor user experience.
    note: |
      Always handle specific Prisma error codes:

      import { PrismaClientKnownRequestError } from '@prisma/client/runtime/library'

      try {
        await prisma.user.create({ data })
      } catch (e) {
        if (e instanceof PrismaClientKnownRequestError) {
          if (e.code === 'P2002') throw new Error('Email already exists')
          if (e.code === 'P2025') throw new Error('Record not found')
        }
        throw e
      }

      Common error codes:
      - P2002: Unique constraint violation
      - P2003: Foreign key constraint violation
      - P2025: Record not found (update/delete)
      - P2014: Required relation violation
    examples:
      bad:
        - |
          try {
            await prisma.user.create({ data })
          } catch (e) {
            throw new Error('Database error')
          }
      good:
        - |
          import { PrismaClientKnownRequestError } from '@prisma/client/runtime/library'

          try {
            await prisma.user.create({ data })
          } catch (e) {
            if (e instanceof PrismaClientKnownRequestError) {
              if (e.code === 'P2002') throw new Error('Email already exists')
              if (e.code === 'P2025') throw new Error('Record not found')
            }
            throw e
          }

  N5:
    title: New PrismaClient Per Request
    severity: NEVER
    mechanical: false
    provenance:
      last_verified: "2026-01-20"
      confidence: high
      re_verify_after: "2027-01-20"
      sources:
        - url: "https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections"
          accessed: "2026-01-20"
          quote: "Creating too many instances of PrismaClient can exhaust your database connections"
    description: >
      Creating PrismaClient instances per request exhausts database connections.
      Use a singleton pattern to reuse the client across requests.
    note: |
      Creating PrismaClient per request exhausts connection pool.
      Use the singleton pattern:

      // lib/prisma.ts
      import { PrismaClient } from '@prisma/client'

      const globalForPrisma = globalThis as { prisma?: PrismaClient }

      export const prisma = globalForPrisma.prisma ?? new PrismaClient()

      if (process.env.NODE_ENV !== 'production') {
        globalForPrisma.prisma = prisma
      }

      Then import from lib/prisma.ts everywhere.
    examples:
      bad:
        - |
          export async function handler() {
            const prisma = new PrismaClient()
            // ...
          }
      good:
        - |
          import { PrismaClient } from '@prisma/client'

          const globalForPrisma = globalThis as { prisma?: PrismaClient }
          export const prisma = globalForPrisma.prisma ?? new PrismaClient()
          if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma

  N6:
    title: Fetching All Fields When Not Needed
    severity: NEVER
    mechanical: false
    description: >
      Fetching all fields when only some are needed wastes bandwidth and memory.
      Use select to fetch only required fields, especially for large tables.
    note: |
      Use select to fetch specific fields:

      BAD:
        const users = await prisma.user.findMany()  // fetches everything

      GOOD:
        const users = await prisma.user.findMany({
          select: { id: true, name: true, email: true }
        })

      This is especially important for:
      - Large text/JSON fields
      - Tables with many columns
      - High-traffic endpoints

  N7:
    title: Missing Unique Constraint Handling
    severity: NEVER
    mechanical: false
    provenance:
      last_verified: "2026-01-20"
      confidence: high
      re_verify_after: "2027-01-20"
      sources:
        - url: "https://www.prisma.io/docs/orm/reference/error-reference#p2002"
          accessed: "2026-01-20"
          quote: "Unique constraint failed on the {constraint}"
    description: >
      create() without handling unique violations crashes on duplicate data.
      Either use upsert or catch P2002 errors.
    note: |
      create() throws P2002 on unique constraint violations.
      Handle this with upsert or catch:

      // Using upsert (preferred for idempotent operations)
      await prisma.user.upsert({
        where: { email },
        update: {},  // or update with new data
        create: { email, name }
      })

      // Or catch P2002
      try {
        await prisma.user.create({ data: { email, name } })
      } catch (e) {
        if (e instanceof PrismaClientKnownRequestError && e.code === 'P2002') {
          throw new Error('User with this email already exists')
        }
        throw e
      }
    examples:
      bad:
        - "await prisma.user.create({ data: { email } })"
      good:
        - |
          await prisma.user.upsert({
            where: { email },
            update: {},
            create: { email, name }
          })

  # =========================================================================
  # MUST - Important patterns (validator warns)
  # =========================================================================

  M1:
    title: Use include for Relations
    severity: MUST
    mechanical: false
    description: >
      Fetch related data in a single query using include instead of
      separate queries. This prevents N+1 problems and improves performance.
    note: |
      Use include to fetch related data:

      const userWithPosts = await prisma.user.findUnique({
        where: { id },
        include: {
          posts: true,
          profile: true
        }
      })

      Or use select for fine-grained control:

      const userWithPosts = await prisma.user.findUnique({
        where: { id },
        include: {
          posts: {
            select: { id: true, title: true }
          }
        }
      })

  M2:
    title: Handle P2002 (Unique Constraint)
    severity: MUST
    mechanical: false
    description: >
      Unique constraint violations must have user-friendly error messages.
      Don't expose raw database errors to users.
    note: |
      P2002 means a unique constraint was violated. Handle it:

      try {
        await prisma.user.create({ data })
      } catch (e) {
        if (e instanceof PrismaClientKnownRequestError) {
          if (e.code === 'P2002') {
            // e.meta.target contains the field(s) that caused the violation
            const field = (e.meta?.target as string[])?.[0] ?? 'field'
            throw new Error(`A record with this ${field} already exists`)
          }
        }
        throw e
      }

  M3:
    title: Handle P2025 (Record Not Found)
    severity: MUST
    mechanical: false
    description: >
      Record not found errors from update/delete need handling.
      Provide clear feedback when the record doesn't exist.
    note: |
      P2025 occurs when update/delete can't find the record:

      try {
        await prisma.post.update({
          where: { id },
          data: { title: 'New Title' }
        })
      } catch (e) {
        if (e instanceof PrismaClientKnownRequestError) {
          if (e.code === 'P2025') {
            throw new Error('Post not found')
          }
        }
        throw e
      }

      Or use updateMany which returns count instead of throwing:

      const { count } = await prisma.post.updateMany({
        where: { id, orgId },
        data: { title: 'New Title' }
      })
      if (count === 0) throw new Error('Post not found')

  M4:
    title: Singleton Client Pattern
    severity: MUST
    mechanical: false
    provenance:
      last_verified: "2026-01-20"
      confidence: high
      re_verify_after: "2027-01-20"
      sources:
        - url: "https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/nextjs-prisma-client-dev-practices"
          accessed: "2026-01-20"
          quote: "Use a single instance of PrismaClient and store it on the globalThis object"
    description: >
      Use the global singleton pattern for PrismaClient, not per-request
      instantiation. This is critical for connection pool management.
    note: |
      Create a singleton in lib/prisma.ts:

      import { PrismaClient } from '@prisma/client'

      const globalForPrisma = globalThis as { prisma?: PrismaClient }

      export const prisma = globalForPrisma.prisma ?? new PrismaClient()

      if (process.env.NODE_ENV !== 'production') {
        globalForPrisma.prisma = prisma
      }

      The globalThis pattern prevents hot reload from creating new instances.

  M5:
    title: Type Generated Client
    severity: MUST
    mechanical: false
    description: >
      Run `prisma generate` after schema changes to regenerate the typed client.
      Stale types cause runtime errors and type mismatches.
    note: |
      After any schema.prisma change:

      1. npx prisma generate  # Regenerate client
      2. npx prisma db push   # Or prisma migrate dev

      Add to package.json for CI:
      {
        "scripts": {
          "postinstall": "prisma generate"
        }
      }

      This ensures the client is always in sync with the schema.

  M6:
    title: Include orgId in Schema
    severity: MUST
    mechanical: false
    provenance:
      last_verified: "2026-01-20"
      confidence: high
      re_verify_after: "2027-01-20"
      sources:
        - url: "https://www.prisma.io/docs/orm/prisma-schema/data-model/relations"
          accessed: "2026-01-20"
          quote: "Define relations between models using relation fields"
    description: >
      All tenant-scoped models must have an orgId field for multi-tenant
      data isolation. This is the foundation of tenant security.
    note: |
      Add orgId to all tenant-scoped models:

      model Post {
        id        String   @id @default(cuid())
        orgId     String   // REQUIRED for multi-tenant
        title     String
        content   String
        org       Organization @relation(fields: [orgId], references: [id])

        @@index([orgId])
      }

      The @@index([orgId]) improves query performance for tenant-filtered queries.
    examples:
      good:
        - |
          model Post {
            id        String   @id @default(cuid())
            orgId     String
            title     String
            org       Organization @relation(fields: [orgId], references: [id])

            @@index([orgId])
          }

  # =========================================================================
  # SHOULD - Best practices (advisory)
  # =========================================================================

  S1:
    title: Use select Over include When Possible
    severity: SHOULD
    mechanical: false
    description: >
      select returns only specified fields, include returns all fields of
      related models. Use select for better performance when you don't
      need all fields.
    note: |
      include fetches all fields of the relation:

      // Fetches ALL post fields
      prisma.user.findMany({ include: { posts: true } })

      select fetches only specified fields:

      // Fetches only id and title
      prisma.user.findMany({
        include: {
          posts: {
            select: { id: true, title: true }
          }
        }
      })

  S2:
    title: Use Transactions for Multi-Step Operations
    severity: SHOULD
    mechanical: false
    description: >
      Use transactions when multiple operations must succeed or fail together.
      This ensures data consistency.
    note: |
      Use $transaction for atomic operations:

      // Sequential transaction (simple)
      await prisma.$transaction([
        prisma.post.create({ data: post1 }),
        prisma.post.create({ data: post2 }),
      ])

      // Interactive transaction (complex logic)
      await prisma.$transaction(async (tx) => {
        const user = await tx.user.create({ data: userData })
        await tx.post.create({ data: { ...postData, userId: user.id } })
        return user
      })

      Transactions rollback all operations if any fails.

  S3:
    title: Enable Query Logging in Development
    severity: SHOULD
    mechanical: false
    description: >
      Enable query logging in development to identify slow queries and N+1
      problems early.
    note: |
      Enable logging in PrismaClient:

      const prisma = new PrismaClient({
        log: [
          { level: 'query', emit: 'event' },
          { level: 'error', emit: 'stdout' },
          { level: 'warn', emit: 'stdout' },
        ],
      })

      // Log queries with duration
      prisma.$on('query', (e) => {
        console.log(`Query: ${e.query}`)
        console.log(`Duration: ${e.duration}ms`)
      })

      This helps identify:
      - N+1 query patterns
      - Slow queries
      - Missing indexes

  S4:
    title: Use Prisma Error Types
    severity: SHOULD
    mechanical: false
    description: >
      Import and check PrismaClientKnownRequestError for proper error handling.
      This enables specific error messages for different failure modes.
    note: |
      Import error types from Prisma:

      import {
        PrismaClientKnownRequestError,
        PrismaClientValidationError,
      } from '@prisma/client/runtime/library'

      try {
        await prisma.user.create({ data })
      } catch (e) {
        if (e instanceof PrismaClientKnownRequestError) {
          // Database-level errors (P2xxx codes)
          console.log('Error code:', e.code)
          console.log('Meta:', e.meta)
        }
        if (e instanceof PrismaClientValidationError) {
          // Query validation errors (wrong types, missing fields)
        }
        throw e
      }

  # =========================================================================
  # GUIDANCE - Design principles (not mechanically checked)
  # =========================================================================

  G1:
    title: Common Error Codes
    severity: GUIDANCE
    mechanical: false
    description: >
      Reference for common Prisma error codes and their meanings.
    note: |
      Common Prisma error codes:

      P2002 - Unique constraint violation
        "Unique constraint failed on the {constraint}"
        Cause: Duplicate value for unique field

      P2003 - Foreign key constraint violation
        "Foreign key constraint failed on the field: {field_name}"
        Cause: Referenced record doesn't exist

      P2025 - Record not found
        "An operation failed because it depends on one or more records
         that were required but not found."
        Cause: update/delete on non-existent record

      P2014 - Required relation violation
        "The change you are trying to make would violate the required
         relation '{relation_name}'"
        Cause: Breaking a required relation

      P2024 - Connection pool timeout
        "Timed out fetching a new connection from the connection pool"
        Cause: Too many connections, pool exhausted

  G2:
    title: Multi-tenant Schema Pattern
    severity: GUIDANCE
    mechanical: false
    description: >
      Recommended schema pattern for multi-tenant applications.
    note: |
      model Organization {
        id        String   @id @default(cuid())
        clerkOrgId String  @unique  // If using Clerk
        name      String
        slug      String   @unique
        createdAt DateTime @default(now())
        posts     Post[]
        members   Membership[]
      }

      model User {
        id          String   @id @default(cuid())
        clerkUserId String   @unique  // If using Clerk
        email       String   @unique
        name        String?
        memberships Membership[]
      }

      model Membership {
        id     String       @id @default(cuid())
        orgId  String
        userId String
        role   String       // admin, member, etc.
        org    Organization @relation(fields: [orgId], references: [id])
        user   User         @relation(fields: [userId], references: [id])

        @@unique([orgId, userId])
      }

      model Post {
        id        String       @id @default(cuid())
        orgId     String       // REQUIRED for tenant isolation
        userId    String?      // Optional author attribution
        title     String
        content   String
        org       Organization @relation(fields: [orgId], references: [id])

        @@index([orgId])
      }

  G3:
    title: Singleton Pattern for Next.js
    severity: GUIDANCE
    mechanical: false
    description: >
      Standard singleton pattern for PrismaClient in Next.js applications.
    note: |
      // lib/prisma.ts
      import { PrismaClient } from '@prisma/client'

      const globalForPrisma = globalThis as { prisma?: PrismaClient }

      export const prisma = globalForPrisma.prisma ?? new PrismaClient({
        log: process.env.NODE_ENV === 'development'
          ? ['query', 'error', 'warn']
          : ['error'],
      })

      if (process.env.NODE_ENV !== 'production') {
        globalForPrisma.prisma = prisma
      }

      Why this works:
      - globalThis persists across hot reloads in development
      - Production creates one instance per serverless function
      - Prevents connection pool exhaustion

  G4:
    title: Connection Pool Configuration
    severity: GUIDANCE
    mechanical: false
    description: >
      Connection pool settings for different environments.
    note: |
      Configure connection pool in DATABASE_URL:

      # Development (local)
      DATABASE_URL="postgresql://user:pass@localhost:5432/db?connection_limit=5"

      # Serverless (Vercel, etc.)
      DATABASE_URL="postgresql://user:pass@host:5432/db?connection_limit=1&pool_timeout=10"

      # With Prisma Accelerate (recommended for serverless)
      DATABASE_URL="prisma://accelerate.prisma-data.net/?api_key=xxx"

      Key parameters:
      - connection_limit: Max connections per instance (low for serverless)
      - pool_timeout: How long to wait for connection (seconds)
      - connect_timeout: Connection establishment timeout

# ===========================================================================
# INFO CHECKS - Statistics for reporting (not pass/fail)
# ===========================================================================

info:
  prisma_imports:
    pattern: 'from .@prisma/client'
    flags: -oE
    label: "Prisma imports"

  prisma_queries:
    pattern: 'prisma\.[a-z]+\.(findMany|findFirst|findUnique|create|update|delete)'
    flags: -cE
    label: "Prisma queries"

  include_usage:
    pattern: 'include:\s*\{'
    flags: -cE
    label: "include usage"

  raw_queries:
    pattern: '\$queryRaw|\$executeRaw'
    flags: -cE
    label: "Raw queries"

  transactions:
    pattern: '\$transaction'
    flags: -cE
    label: "Transactions"

# ===========================================================================
# ANTI-PATTERNS - Quick reference table (documentation only)
# ===========================================================================

anti_patterns:
  - pattern: "Queries without orgId"
    description: "Data leaks between tenants"
    fix: "Always include orgId in where clause"

  - pattern: "$queryRawUnsafe with user input"
    description: "SQL injection vulnerability"
    fix: "Use $queryRaw with tagged templates"

  - pattern: "N+1 queries"
    description: "Query in loop causes N+1 problem"
    fix: "Use include or select for relations"

  - pattern: "Generic error handling"
    description: "Loses error context"
    fix: "Handle specific Prisma error codes"

  - pattern: "new PrismaClient per request"
    description: "Connection pool exhaustion"
    fix: "Use singleton pattern"

  - pattern: "Missing orgId in schema"
    description: "No tenant isolation possible"
    fix: "Add orgId field to all tenant data models"

  - pattern: ".create without unique handling"
    description: "Crashes on duplicate data"
    fix: "Use upsert or catch P2002"

