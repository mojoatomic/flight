# javascript.flight - JavaScript Hygiene Domain
# Source: Migrated from javascript.md and javascript.validate.sh

domain: javascript
version: 1.2.0
schema_version: 2
language: javascript
description: >
  Code quality patterns that prevent common mistakes in JavaScript/Node.js projects.
  JavaScript-specific patterns while code-hygiene covers universal patterns.

provenance:
  last_full_audit: "2026-01-16"
  audited_by: "flight-research"
  next_audit_due: "2026-07-16"

  sources_consulted:
    - url: "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide"
      accessed: "2026-01-16"
      note: "MDN JavaScript Guide - authoritative JS reference"
    - url: "https://google.github.io/styleguide/jsguide.html"
      accessed: "2026-01-16"
      note: "Google JavaScript Style Guide"
    - url: "https://github.com/airbnb/javascript"
      accessed: "2026-01-16"
      note: "Airbnb JavaScript Style Guide - widely adopted community standard"
    - url: "https://eslint.org/docs/latest/rules/"
      accessed: "2026-01-16"
      note: "ESLint rules documentation - codified best practices"

  coverage:
    apis_covered:
      - "Variable naming patterns"
      - "Boolean handling"
      - "Function naming"
      - "Console usage"
      - "Constants"
      - "var vs let/const scoping"
      - "Strict equality operators"
      - "Async/await patterns"
    known_gaps:
      - "ES modules vs CommonJS not covered"
      - "Framework-specific patterns in separate domains"
      - "Floating promises (hard to validate mechanically)"

file_patterns:
  - "**/*.js"
  - "**/*.mjs"
  - "**/*.cjs"

exclude_patterns:
  - "**/node_modules/**"
  - "**/dist/**"
  - "**/build/**"
  - "**/.next/**"
  - "**/.git/**"

# ===========================================================================
# RULES
# ===========================================================================
# JavaScript-SPECIFIC rules. Universal code hygiene rules are in code-hygiene.flight.
#
# ID format: {severity_prefix}{number}
#   N = NEVER (check - fails build)
#   S = SHOULD (warn - advisory)
#   G = GUIDANCE (not checked)
# ===========================================================================

rules:

  # =========================================================================
  # NEVER - JavaScript anti-patterns (validator will reject)
  # =========================================================================

  N1:
    title: Generic Variable Names
    severity: NEVER
    mechanical: true
    provenance:
      last_verified: "2026-01-16"
      confidence: high
      re_verify_after: "2027-01-16"
      sources:
        - url: "https://github.com/airbnb/javascript#naming--descriptive"
          accessed: "2026-01-16"
          quote: "Avoid single letter names. Be descriptive with your naming."
    description: >
      Never use generic names like data, result, temp, info, item, value, obj, thing,
      stuff, foo, bar, baz, tmp, ret, val. Use domain-specific names instead.
    check:
      type: ast
      query: |
        (variable_declarator
          name: (identifier) @violation
          (#match? @violation "^(data|result|temp|info|item|value|obj|thing|stuff|tmp|ret|val)$"))
    note: |
      Generic names provide no context about what the variable holds. Domain-specific
      names make code self-documenting and easier to understand.
    examples:
      bad:
        - "const data = fetchUser();"
        - "const result = processOrder();"
        - "const temp = calculateTotal();"
      good:
        - "const user = fetchUser();"
        - "const processedOrder = processOrder();"
        - "const invoiceTotal = calculateTotal();"

  N2:
    title: Redundant Conditional Returns
    severity: NEVER
    mechanical: true
    provenance:
      last_verified: "2026-01-16"
      confidence: high
      re_verify_after: "2027-01-16"
      sources:
        - url: "https://eslint.org/docs/latest/rules/no-else-return"
          accessed: "2026-01-16"
          quote: "If an if block contains a return statement, the else block becomes unnecessary."
    description: >
      Never write 'if (condition) return true; else return false' or equivalent.
      Return the condition directly.
    check:
      type: ast
      query: |
        (if_statement
          consequence: [(statement_block (return_statement (true))) (return_statement (true))]
          alternative: [(else_clause [(statement_block (return_statement (false))) (return_statement (false))])] @violation)
        (if_statement
          consequence: [(statement_block (return_statement (false))) (return_statement (false))]
          alternative: [(else_clause [(statement_block (return_statement (true))) (return_statement (true))])] @violation)
    note: |
      Redundant conditionals add unnecessary code. The condition itself is already
      a boolean expression that can be returned directly.
    examples:
      bad:
        - "if (condition) return true; else return false;"
        - "if (condition) { return true; } return false;"
      good:
        - "return condition;"

  N3:
    title: Ternary Returning Boolean Literals
    severity: NEVER
    mechanical: true
    provenance:
      last_verified: "2026-01-16"
      confidence: high
      re_verify_after: "2027-01-16"
      sources:
        - url: "https://eslint.org/docs/latest/rules/no-unneeded-ternary"
          accessed: "2026-01-16"
          quote: "Disallow ternary operators when simpler alternatives exist."
    description: >
      Never write 'condition ? true : false'. The condition is already boolean.
    check:
      type: ast
      query: |
        (ternary_expression
          consequence: [(true) (false)]
          alternative: [(true) (false)]) @violation
    note: |
      A ternary that returns true/false is redundant. Use ternaries for non-boolean
      value selection, not boolean coercion.
    examples:
      bad:
        - "return isValid ? true : false;"
        - "const result = hasPermission ? true : false;"
      good:
        - "return isValid;"
        - "const result = hasPermission;"
        - "const status = isActive ? 'active' : 'inactive';  // OK: non-boolean"

  N4:
    title: Redundant Boolean Comparisons
    severity: NEVER
    mechanical: true
    provenance:
      last_verified: "2026-01-16"
      confidence: high
      re_verify_after: "2027-01-16"
      sources:
        - url: "https://eslint.org/docs/latest/rules/no-extra-boolean-cast"
          accessed: "2026-01-16"
          quote: "Disallow unnecessary boolean casts."
    description: >
      Never write '=== true', '=== false', '!== true', or '!== false'.
      Use the boolean directly.
    check:
      type: ast
      query: |
        (binary_expression
          operator: ["===" "!=="]
          right: [(true) (false)]) @violation
    note: |
      Comparing to boolean literals is redundant. Use the variable directly
      or with ! for negation.
    examples:
      bad:
        - "if (x === true) { ... }"
        - "if (y === false) { ... }"
        - "if (z !== true) { ... }"
      good:
        - "if (x) { ... }"
        - "if (!y) { ... }"
        - "if (!z) { ... }"

  N5:
    title: Magic Number Calculations
    severity: NEVER
    mechanical: true
    provenance:
      last_verified: "2026-01-16"
      confidence: high
      re_verify_after: "2027-01-16"
      sources:
        - url: "https://eslint.org/docs/latest/rules/no-magic-numbers"
          accessed: "2026-01-16"
          quote: "Magic numbers are numbers that occur multiple times in code without clear meaning."
    description: >
      Never compute at runtime what can be a constant. Pre-calculate time values
      and other derived constants.
    check:
      type: ast
      query: |
        (binary_expression
          left: (binary_expression
            left: (number)
            right: (number))
          right: (number)) @violation
    note: |
      Runtime calculations like 60 * 60 * 1000 are harder to read than named constants.
      Pre-calculate and use descriptive constant names like MS_PER_HOUR = 3600000.
    examples:
      bad:
        - "const timeout = 60 * 60 * 1000;"
        - "const days = 24 * 60 * 60;"
        - "const interval = 7 * 24 * 60 * 60 * 1000;"
      good:
        - "const MS_PER_HOUR = 3600000;"
        - "const SECONDS_PER_DAY = 86400;"
        - "const MS_PER_WEEK = 604800000;"

  N6:
    title: Generic Function Names
    severity: NEVER
    mechanical: true
    provenance:
      last_verified: "2026-01-16"
      confidence: high
      re_verify_after: "2027-01-16"
      sources:
        - url: "https://google.github.io/styleguide/jsguide.html#naming-method-names"
          accessed: "2026-01-16"
          quote: "Method names are typically verbs or verb phrases... should clearly describe what the method does."
    description: >
      Never use generic verbs like handle, process, do, run, execute, manage
      combined with generic nouns without specific context.
    check:
      type: ast
      query: |
        (function_declaration
          name: (identifier) @violation
          (#match? @violation "^(handle|process|do|run|execute|manage)(Data|Item|Value|Info|Result|Object)$"))
    note: |
      Function names should describe what they do specifically. 'handleData' tells
      nothing about what handling occurs. 'validateUserInput' is clear.
    examples:
      bad:
        - "function handleData(data) { ... }"
        - "function processItem(item) { ... }"
        - "function doValue(value) { ... }"
      good:
        - "function validateUserInput(input) { ... }"
        - "function transformOrderToInvoice(order) { ... }"
        - "function calculateShippingCost(order) { ... }"

  N7:
    title: Single-Letter Variables
    severity: NEVER
    mechanical: true
    provenance:
      last_verified: "2026-01-16"
      confidence: high
      re_verify_after: "2027-01-16"
      sources:
        - url: "https://github.com/airbnb/javascript#naming--descriptive"
          accessed: "2026-01-16"
          quote: "Avoid single letter names. Be descriptive with your naming."
    description: >
      Never use single-letter variables except i, j, k as loop counters.
    check:
      type: ast
      query: |
        (variable_declarator
          name: (identifier) @violation
          (#match? @violation "^[a-hln-z]$"))
    note: |
      Single-letter variables provide no context. Even short loops benefit from
      descriptive names like 'index' or 'user'.
    examples:
      bad:
        - "const x = getUser();"
        - "const n = calculateTotal();"
        - "let a = [];"
      good:
        - "const user = getUser();"
        - "const total = calculateTotal();"
        - "let items = [];"
        - "for (let i = 0; i < items.length; i++) { ... }  // OK: loop counter"

  N8:
    title: console.log in Source Files
    severity: NEVER
    mechanical: true
    provenance:
      last_verified: "2026-01-16"
      confidence: high
      re_verify_after: "2027-01-16"
      sources:
        - url: "https://eslint.org/docs/latest/rules/no-console"
          accessed: "2026-01-16"
          quote: "In JavaScript that is designed to be executed in the browser, it's considered a best practice to avoid using methods on console."
    description: >
      Never leave console.log statements in production source files.
      Test files are excluded from this rule.
    check:
      type: ast
      query: |
        (call_expression
          function: (member_expression
            object: (identifier) @obj
            property: (property_identifier) @prop)
          (#eq? @obj "console")
          (#eq? @prop "log")) @violation
    note: |
      console.log is for debugging. Production code should use proper logging
      infrastructure. Test files may use console.log for debugging.
      Note: Test file exclusion should be handled at file discovery level.
    examples:
      bad:
        - "// src/user.js"
        - "console.log('user:', user);"
        - "console.log('debug: processing order');"
      good:
        - "// Use proper logging"
        - "logger.debug('Processing order', { orderId });"

  N9:
    title: var Declaration
    severity: NEVER
    mechanical: true
    provenance:
      last_verified: "2026-01-16"
      confidence: high
      re_verify_after: "2027-01-16"
      sources:
        - url: "https://eslint.org/docs/latest/rules/no-var"
          accessed: "2026-01-16"
          quote: "ECMAScript 6 allows programmers to create variables with block scope using let and const... Using let and const where appropriate makes code easier to understand."
    description: >
      Never use var. Use const for values that won't be reassigned, let for values
      that will. Block scoping and temporal dead zone prevent common bugs.
    check:
      type: ast
      query: |
        (variable_declaration) @violation
    note: |
      var is function-scoped and hoisted, leading to confusing behavior.
      let and const are block-scoped with temporal dead zone, catching errors earlier.
    examples:
      bad:
        - "var count = 0;"
        - "var user = getUser();"
        - "for (var i = 0; i < 10; i++) { ... }"
      good:
        - "const user = getUser();"
        - "let count = 0;"
        - "for (let i = 0; i < 10; i++) { ... }"

  N10:
    title: Loose Equality
    severity: NEVER
    mechanical: true
    provenance:
      last_verified: "2026-01-16"
      confidence: high
      re_verify_after: "2027-01-16"
      sources:
        - url: "https://eslint.org/docs/latest/rules/eqeqeq"
          accessed: "2026-01-16"
          quote: "It is considered good practice to use the type-safe equality operators === and !== instead of their regular counterparts."
    description: >
      Never use == or !=. Use === and !== to avoid type coercion bugs.
      Type coercion rules are complex and lead to unexpected behavior.
    check:
      type: ast
      query: |
        (binary_expression
          operator: ["==" "!="]) @violation
    note: |
      == performs type coercion with surprising rules: "0" == false is true,
      null == undefined is true. Use === for predictable comparisons.
    examples:
      bad:
        - "if (x == null) { ... }"
        - "if (count != 0) { ... }"
        - "if (status == 'active') { ... }"
      good:
        - "if (x === null || x === undefined) { ... }"
        - "if (count !== 0) { ... }"
        - "if (status === 'active') { ... }"

  N11:
    title: eval() Usage
    severity: NEVER
    mechanical: true
    provenance:
      last_verified: "2026-01-25"
      confidence: high
      re_verify_after: "2026-07-25"
      sources:
        - url: "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval#never_use_direct_eval!"
          accessed: "2026-01-25"
          quote: "Never use direct eval()! eval() is a dangerous function, which executes the code it's passed with the privileges of the caller."
    description: >
      Never use eval() to execute arbitrary code. It allows code injection attacks
      if any part of the input is user-controlled, and prevents JavaScript engine
      optimizations.
    check:
      type: ast
      query: |
        (call_expression
          function: (identifier) @fn
          (#eq? @fn "eval")) @violation
    note: |
      eval() executes arbitrary JavaScript code with full privileges. Even for
      non-malicious use cases, there are safer alternatives like JSON.parse()
      for data, or Function() constructor for dynamic code (though still risky).
    examples:
      bad:
        - "const result = eval(userInput);"
        - "eval('var x = ' + data);"
      good:
        - "const data = JSON.parse(jsonString);"
        - "const fn = new Function('return ' + expression);  // Still risky"

  N12:
    title: innerHTML Assignment
    severity: NEVER
    mechanical: true
    provenance:
      last_verified: "2026-01-25"
      confidence: high
      re_verify_after: "2026-07-25"
      sources:
        - url: "https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML#security_considerations"
          accessed: "2026-01-25"
          quote: "It is not uncommon to see innerHTML used to insert text into a web page. There is potential for this to become an attack vector on a site, creating a potential security risk."
    description: >
      Never assign to innerHTML with user-controlled content. This creates XSS
      vulnerabilities. Use textContent for text or DOM methods for elements.
    check:
      type: ast
      query: |
        (assignment_expression
          left: (member_expression
            property: (property_identifier) @prop)
          (#eq? @prop "innerHTML")) @violation
    note: |
      innerHTML parses and executes HTML, including script tags and event handlers.
      Use textContent for text (escapes HTML), or createElement/appendChild for
      structured content.
    examples:
      bad:
        - "element.innerHTML = userInput;"
        - "div.innerHTML = '<span>' + name + '</span>';"
      good:
        - "element.textContent = userInput;"
        - "const span = document.createElement('span');"
        - "span.textContent = name;"
        - "div.appendChild(span);"

  N13:
    title: document.write() Usage
    severity: NEVER
    mechanical: true
    provenance:
      last_verified: "2026-01-25"
      confidence: high
      re_verify_after: "2026-07-25"
      sources:
        - url: "https://developer.mozilla.org/en-US/docs/Web/API/Document/write#notes"
          accessed: "2026-01-25"
          quote: "Use of document.write() is strongly discouraged... It can block page rendering and cause synchronous reflows."
    description: >
      Never use document.write(). It overwrites the entire document if called
      after page load, creates XSS vulnerabilities, and blocks page rendering.
    check:
      type: ast
      query: |
        (call_expression
          function: (member_expression
            object: (identifier) @obj
            property: (property_identifier) @method)
          (#eq? @obj "document")
          (#match? @method "^(write|writeln)$")) @violation
    note: |
      document.write() is a legacy API that should not be used in modern code.
      If called after page load, it completely replaces the document. Use
      DOM manipulation methods instead.
    examples:
      bad:
        - "document.write('<h1>' + title + '</h1>');"
        - "document.writeln(userContent);"
      good:
        - "const h1 = document.createElement('h1');"
        - "h1.textContent = title;"
        - "document.body.appendChild(h1);"

  # =========================================================================
  # SHOULD - Best practices (validator warns)
  # =========================================================================

  S1:
    title: Await in Loops
    severity: SHOULD
    mechanical: true
    provenance:
      last_verified: "2026-01-16"
      confidence: high
      re_verify_after: "2027-01-16"
      sources:
        - url: "https://eslint.org/docs/latest/rules/no-await-in-loop"
          accessed: "2026-01-16"
          quote: "Performing an operation on each element of an iterable is a common task. However, performing await inside of a loop is an indication that the program is not taking full advantage of the parallelization benefits of async/await."
    description: >
      Avoid await inside loops. Sequential awaits are slow when operations
      are independent. Use Promise.all() for parallel execution.
    check:
      type: ast
      query: |
        (for_statement
          body: (statement_block
            (expression_statement
              (await_expression) @violation)))
        (for_in_statement
          body: (statement_block
            (expression_statement
              (await_expression) @violation)))
        (while_statement
          body: (statement_block
            (expression_statement
              (await_expression) @violation)))
    note: |
      Each await in a loop waits for completion before the next iteration.
      If operations are independent, Promise.all() runs them in parallel.
      Note: This AST query catches direct await in loops but may miss deeply nested cases.
    examples:
      bad:
        - |
          for (const user of users) {
            await sendEmail(user);  // Sequential - slow!
          }
      good:
        - |
          await Promise.all(users.map(user => sendEmail(user)));

  # =========================================================================
  # GUIDANCE - Best practices (not mechanically checked)
  # =========================================================================

  G1:
    title: Domain-Specific Names
    severity: GUIDANCE
    mechanical: false
    description: >
      Use vocabulary from the problem domain. Names should reflect business
      concepts, not implementation details.
    guidance: |
      // Domain-specific naming
      const customerOrder = fetchOrder(orderId);
      const invoiceTotal = calculateInvoiceTotal(lineItems);
      const isPaymentComplete = payment.status === 'complete';

      // Avoid generic names even when 'technically correct'
      // BAD: const obj = fetchOrder(orderId);
      // GOOD: const customerOrder = fetchOrder(orderId);

  G2:
    title: Boolean Prefixes
    severity: GUIDANCE
    mechanical: false
    description: >
      Use is, has, can, should, will prefixes for boolean variables.
    guidance: |
      const isActive = user.status === 'active';
      const hasPermission = user.roles.includes('admin');
      const canEdit = hasPermission && !document.isLocked;
      const shouldRetry = attempts < MAX_RETRIES;
      const willExpire = expiryDate < Date.now();

  G3:
    title: Async Function Naming
    severity: GUIDANCE
    mechanical: false
    description: >
      Consider Async suffix or verb prefixes for async functions to make
      async nature clear at call sites.
    guidance: |
      // Option 1: Async suffix
      async function fetchUserAsync(id) { ... }

      // Option 2: Verb prefix that implies async
      async function loadUserData(id) { ... }
      async function fetchOrder(orderId) { ... }

  G4:
    title: Plural Collections
    severity: GUIDANCE
    mechanical: false
    description: >
      Arrays and collections should use plural names.
    guidance: |
      const users = await fetchUsers();
      const validOrders = orders.filter(isValidOrder);
      const lineItems = order.items;

      // BAD: const user = await fetchUsers();  // confusing!
      // GOOD: const users = await fetchUsers();

  G5:
    title: Constants Uppercase
    severity: GUIDANCE
    mechanical: false
    description: >
      Use UPPER_SNAKE_CASE for true constants (values that never change).
    guidance: |
      const MAX_RETRIES = 3;
      const DEFAULT_TIMEOUT_MS = 5000;
      const API_BASE_URL = 'https://api.example.com';

      // Pre-calculated time constants
      const MS_PER_SECOND = 1000;
      const MS_PER_MINUTE = 60000;
      const MS_PER_HOUR = 3600000;
      const MS_PER_DAY = 86400000;

  G6:
    title: Descriptive Error Messages
    severity: GUIDANCE
    mechanical: false
    description: >
      Error messages should state what went wrong and what was expected.
    guidance: |
      // BAD
      throw new Error('Invalid input');
      throw new Error('Failed');

      // GOOD
      throw new Error(`Expected orderId to be a string, got ${typeof orderId}`);
      throw new Error(`User ${userId} not found in database`);
      throw new Error(`Payment failed: ${response.errorCode} - ${response.message}`);

info_metrics:
  - name: "Boolean-prefixed variables"
    pattern: '\b(is|has|can|should|will)[A-Z]'
  - name: "UPPER_CASE constants"
    pattern: 'const\s+[A-Z][A-Z_]+\s*='

anti_patterns:
  - pattern: "const data = ..."
    problem: "Generic name"
    fix: "Use domain term"
  - pattern: "function handleX()"
    problem: "Vague verb"
    fix: "Describe action"
  - pattern: "if (x) return true"
    problem: "Redundant"
    fix: "return x"
  - pattern: "60 * 60 * 1000"
    problem: "Magic calc"
    fix: "Pre-computed constant"
  - pattern: "x === true"
    problem: "Redundant"
    fix: "x"
  - pattern: "items.map(i => ...)"
    problem: "Generic 'i'"
    fix: "items.map(item => ...)"
  - pattern: "const temp = ..."
    problem: "Temporary smell"
    fix: "Name by purpose"
  - pattern: "var x = ..."
    problem: "Function scope, hoisting"
    fix: "Use const or let"
  - pattern: "x == y"
    problem: "Type coercion bugs"
    fix: "Use === or !=="
  - pattern: "for (...) { await ... }"
    problem: "Sequential when parallel possible"
    fix: "Use Promise.all()"
