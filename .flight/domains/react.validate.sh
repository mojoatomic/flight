#!/usr/bin/env bash
# react.validate.sh - Production React patterns for functional components, hooks, and state management
# Generated by flight-domain-compile from react.flight
set -euo pipefail

# Script location for sourcing helpers
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Default: common file patterns
DEFAULT_PATTERNS="**/*.jsx **/*.tsx"
PASS=0
FAIL=0
WARN=0

red() { printf '\033[31m%s\033[0m\n' "$1"; }
green() { printf '\033[32m%s\033[0m\n' "$1"; }
yellow() { printf '\033[33m%s\033[0m\n' "$1"; }

check() {
    local name="$1"
    shift
    local result
    result=$("$@" 2>/dev/null) || true
    if [[ -z "$result" ]]; then
        green "✅ $name"
        ((PASS++)) || true
    else
        red "❌ $name"
        printf '%s\n' "$result" | head -10 | sed 's/^/   /'
        ((FAIL++)) || true
    fi
}

warn() {
    local name="$1"
    shift
    local result
    result=$("$@" 2>/dev/null) || true
    if [[ -z "$result" ]]; then
        green "✅ $name"
        ((PASS++)) || true
    else
        yellow "⚠️  $name"
        printf '%s\n' "$result" | head -5 | sed 's/^/   /'
        ((WARN++)) || true
    fi
}

printf '%s\n' "═══════════════════════════════════════════"
printf '%s\n' "  REACT Domain Validation"
printf '%s\n' "═══════════════════════════════════════════"
printf '\n'

# Source exclusions helper if available
if [[ -f "$SCRIPT_DIR/../exclusions.sh" ]]; then
    source "$SCRIPT_DIR/../exclusions.sh"
    FLIGHT_HAS_EXCLUSIONS=true
else
    FLIGHT_HAS_EXCLUSIONS=false
fi

# Handle arguments or use defaults
if [[ $# -gt 0 ]]; then
    FILES=("$@")
elif [[ "$FLIGHT_HAS_EXCLUSIONS" == true ]]; then
    # Use exclusions-aware file discovery
    mapfile -t FILES < <(flight_get_files "*.jsx" "*.tsx")
else
    # Fallback: use find (works on bash 3.2+, no globstar needed)
    mapfile -t FILES < <(find . -type f \( -name "*.jsx" -o -name "*.tsx" \) -not -path "*/node_modules/*" -not -path "*/.git/*" -not -path "*/dist/*" -not -path "*/build/*" 2>/dev/null | sort)
fi

if [[ ${#FILES[@]} -eq 0 ]]; then
    yellow "No files found matching default patterns"
    printf '%s\n' "  Patterns: **/*.jsx **/*.tsx..."
    printf '\n'
    green "  RESULT: SKIP (no files)"
    exit 0
fi

printf 'Files: %d\n\n' "${#FILES[@]}"

printf '\n%s\n' "## NEVER Rules"

# N1: Inline Objects in JSX Props
check "N1: Inline Objects in JSX Props" \
    grep -En "=[{][{]|=\\{\\s*\\{" "${FILES[@]}"

# N2: Inline Functions in JSX Props
check "N2: Inline Functions in JSX Props" \
    grep -En "onClick=\\{.*=>|onChange=\\{.*=>|onSubmit=\\{.*=>|onBlur=\\{.*=>|onFocus=\\{.*=>" "${FILES[@]}"

# N3: Index as Key
check "N3: Index as Key" \
    grep -En "key=\\{.*index|key=\\{i\\}|key=\\{idx\\}" "${FILES[@]}"

# N4: Direct State Mutation
check "N4: Direct State Mutation" \
    bash -c '# Exclude navigation methods: router.push, history.push, navigate
grep -En '"'"'\.push\(|\.splice\(|\.pop\(|\.shift\(|\.unshift\('"'"' "$@" 2>/dev/null | \
grep -v '"'"'router\.push\|history\.push\|navigate\.'"'"' || true' _ "${FILES[@]}"

# N5: Missing Dependency Arrays
check "N5: Missing Dependency Arrays" \
    bash -c 'grep -Pzo '"'"'useEffect\(\s*\(\)\s*=>\s*\{[^}]*[a-zA-Z]+[^}]*\},\s*\[\]\)'"'"' "$@" 2>/dev/null | head -5 || true' _ "${FILES[@]}"

# N6: Conditional Hooks
check "N6: Conditional Hooks" \
    grep -En "if.*\\{[^}]*(useState|useEffect|useMemo|useCallback|useRef)" "${FILES[@]}"

# N7: Generic Component Names
check "N7: Generic Component Names" \
    grep -En "function\\s+\\w+\\(\\s*\\{\\s*(data|info|item|value)\\s*\\}" "${FILES[@]}"

# N8: Export Default (except Next.js special files)
check "N8: Export Default (except Next.js special files)" \
    bash -c 'for f in "$@"; do
    basename=$(basename "$f")
    # Skip Next.js special files that require export default
    if [[ "$basename" =~ ^(page|layout|loading|error|not-found|template|default|main)\.(tsx|jsx|ts|js)$ ]]; then
        continue
    fi
    grep -En '"'"'^export default'"'"' "$f" 2>/dev/null || true
done' _ "${FILES[@]}"

# N9: Props Named data/info/item/value
check "N9: Props Named data/info/item/value" \
    bash -c 'grep -En '"'"'\{\s*(data|info|item|value)\s*\}'"'"' "$@" | grep -v '"'"'const\|let\|var'"'"' || true' _ "${FILES[@]}"

# N10: Console.log in Components
check "N10: Console.log in Components" \
    grep -En "console\\.(log|warn|error)" "${FILES[@]}"

# N11: Ternary Returning Boolean Literals
check "N11: Ternary Returning Boolean Literals" \
    grep -En "\\?\\s*true\\s*:\\s*false|\\?\\s*false\\s*:\\s*true" "${FILES[@]}"

# N12: Redundant Boolean Comparisons
check "N12: Redundant Boolean Comparisons" \
    grep -En "===\\s*true|===\\s*false|!==\\s*true|!==\\s*false" "${FILES[@]}"

printf '\n%s\n' "## SHOULD Rules"

# S1: Handle Loading State
warn "S1: Handle Loading State" \
    bash -c 'for f in "$@"; do
  if grep -q '"'"'fetch\|useQuery\|useSWR\|useEffect.*async'"'"' "$f"; then
    if ! grep -q '"'"'isLoading\|loading'"'"' "$f"; then
      echo "$f: has async but no loading state"
    fi
  fi
done' _ "${FILES[@]}"

# S2: Handle Error State
warn "S2: Handle Error State" \
    bash -c 'for f in "$@"; do
  if grep -q '"'"'fetch\|useQuery\|useSWR\|useEffect.*async'"'"' "$f"; then
    if ! grep -q '"'"'error\|Error'"'"' "$f"; then
      echo "$f: has async but no error handling"
    fi
  fi
done' _ "${FILES[@]}"

# S3: Boolean Props Use Prefix
warn "S3: Boolean Props Use Prefix" \
    grep -En "^\\s*(loading|visible|active)=" "${FILES[@]}"

# S4: useCallback for Handlers
warn "S4: useCallback for Handlers" \
    bash -c 'for f in "$@"; do
  if grep -q '"'"'const handle'"'"' "$f"; then
    if ! grep -q '"'"'useCallback'"'"' "$f"; then
      handlers=$(grep -c '"'"'const handle'"'"' "$f")
      if [ "$handlers" -gt 0 ]; then
        echo "$f: $handlers handlers without useCallback"
      fi
    fi
  fi
done' _ "${FILES[@]}"

printf '\n%s\n' "## Info"

COMPONENTS=$( (grep -lE "^export (async )?function [A-Z]|^export const [A-Z].* = " "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  Components found: %s\n' "$COMPONENTS"

HOOKS_USED=$( (grep -ohE "use[A-Z][a-zA-Z]+" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  Hooks used: %s\n' "$HOOKS_USED"

CUSTOM_HOOKS=$( (grep -lE "^export function use[A-Z]" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  Custom hooks: %s\n' "$CUSTOM_HOOKS"

printf '\n%s\n' "═══════════════════════════════════════════"
printf '  PASS: %d  FAIL: %d  WARN: %d\n' "$PASS" "$FAIL" "$WARN"
if [[ $FAIL -eq 0 ]]; then
    green "  RESULT: PASS"
else
    red "  RESULT: FAIL"
fi
printf '%s\n' "═══════════════════════════════════════════"

exit "$FAIL"
