#!/usr/bin/env bash
# python.validate.sh - Production Python patterns for clean, maintainable, type-safe code
# Generated by flight-domain-compile from python.flight
set -euo pipefail

# Script location for sourcing helpers
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Default: common file patterns
DEFAULT_PATTERNS="**/*.py"
PASS=0
FAIL=0
WARN=0

red() { printf '\033[31m%s\033[0m\n' "$1"; }
green() { printf '\033[32m%s\033[0m\n' "$1"; }
yellow() { printf '\033[33m%s\033[0m\n' "$1"; }

check() {
    local name="$1"
    shift
    local result
    result=$("$@" 2>/dev/null) || true
    if [[ -z "$result" ]]; then
        green "✅ $name"
        ((PASS++)) || true
    else
        red "❌ $name"
        printf '%s\n' "$result" | head -10 | sed 's/^/   /'
        ((FAIL++)) || true
    fi
}

warn() {
    local name="$1"
    shift
    local result
    result=$("$@" 2>/dev/null) || true
    if [[ -z "$result" ]]; then
        green "✅ $name"
        ((PASS++)) || true
    else
        yellow "⚠️  $name"
        printf '%s\n' "$result" | head -5 | sed 's/^/   /'
        ((WARN++)) || true
    fi
}

printf '%s\n' "═══════════════════════════════════════════"
printf '%s\n' "  PYTHON Domain Validation"
printf '%s\n' "═══════════════════════════════════════════"
printf '\n'

# Source exclusions helper if available
if [[ -f "$SCRIPT_DIR/../exclusions.sh" ]]; then
    source "$SCRIPT_DIR/../exclusions.sh"
    FLIGHT_HAS_EXCLUSIONS=true
else
    FLIGHT_HAS_EXCLUSIONS=false
fi

# Handle arguments or use defaults
if [[ $# -gt 0 ]]; then
    FILES=("$@")
elif [[ "$FLIGHT_HAS_EXCLUSIONS" == true ]]; then
    # Use exclusions-aware file discovery
    mapfile -t FILES < <(flight_get_files "*.py")
else
    # Fallback: use find (works on bash 3.2+, no globstar needed)
    mapfile -t FILES < <(find . -type f \( -name "*.py" \) -not -path "*/node_modules/*" -not -path "*/.git/*" -not -path "*/dist/*" -not -path "*/build/*" 2>/dev/null | sort)
fi

if [[ ${#FILES[@]} -eq 0 ]]; then
    yellow "No files found matching default patterns"
    printf '%s\n' "  Patterns: **/*.py..."
    printf '\n'
    green "  RESULT: SKIP (no files)"
    exit 0
fi

printf 'Files: %d\n\n' "${#FILES[@]}"

printf '\n%s\n' "## NEVER Rules"

# N1: Bare except:
check "N1: Bare except:" \
    grep -En "^\\s*except\\s*:" "${FILES[@]}"

# N2: except Exception: pass
check "N2: except Exception: pass" \
    bash -c 'for f in "$@"; do
  awk '"'"'/except\s+(Exception|BaseException)/ { getline; if (/^\s*pass\s*$/) print FILENAME":"NR-1": except with pass" }'"'"' "$f"
done' _ "${FILES[@]}"

# N3: Mutable Default Arguments
check "N3: Mutable Default Arguments" \
    grep -En "def .+\\(.*=\\s*(\\[\\]|\\{\\}|set\\(\\))" "${FILES[@]}"

# N4: from x import *
check "N4: from x import *" \
    grep -En "^from .+ import \\*" "${FILES[@]}"

# N5: type(x) == for Type Checking
check "N5: type(x) == for Type Checking" \
    grep -En "type\\(.+\\)\\s*==|==\\s*type\\(" "${FILES[@]}"

# N6: Generic Variable Names at Module Level
check "N6: Generic Variable Names at Module Level" \
    grep -En "^(data|temp|result|info|obj)\\s*=" "${FILES[@]}"

# N7: print() Outside __main__
check "N7: print() Outside __main__" \
    bash -c 'for f in "$@"; do
  awk '"'"'
  /__name__.*__main__/ { in_main=1 }
  /^[^ ]/ && in_main { in_main=0 }
  /print\(/ && !in_main && !/# noqa/ { print FILENAME":"NR": "$0 }
  '"'"' "$f"
done | head -10' _ "${FILES[@]}"

# N8: Hardcoded Absolute Paths
check "N8: Hardcoded Absolute Paths" \
    grep -En "['\"]/(home|usr|var|etc|tmp)/|['\"][A-Z]:\\\\" "${FILES[@]}"

# N9: Deeply Nested Conditionals
check "N9: Deeply Nested Conditionals" \
    bash -c 'for f in "$@"; do
  awk '"'"'
  /^\s+if / {
    spaces = length($0) - length(gensub(/^\s+/, "", "g", $0))
    if (spaces > 16) {
      print FILENAME":"NR": deeply nested ("int(spaces/4)" levels)"
    }
  }
  '"'"' "$f"
done | head -5' _ "${FILES[@]}"

printf '\n%s\n' "## SHOULD Rules"

# S1: String += Patterns
warn "S1: String += Patterns" \
    grep -En "\\+=\\s*['\"]|\\+=.*str\\(" "${FILES[@]}"

# S2: Magic Numbers in Logic
warn "S2: Magic Numbers in Logic" \
    grep -En "if .+ [<>=]+ [0-9]{2,}|while .+ [<>=]+ [0-9]{2,}|sleep\\([0-9]{2,}\\)" "${FILES[@]}"

# S3: Type Hints on Public Functions
warn "S3: Type Hints on Public Functions" \
    bash -c 'for f in "$@"; do
  grep -n '"'"'^def [a-z]'"'"' "$f" | grep -v '"'"'\->'"'"' | grep -v '"'"'__'"'"' | head -3
done' _ "${FILES[@]}"

# S4: if __name__ == __main__ Guard
warn "S4: if __name__ == __main__ Guard" \
    bash -c 'for f in "$@"; do
  if grep -q '"'"'^def main'"'"' "$f"; then
    if ! grep -q '"'"'__name__.*__main__'"'"' "$f"; then
      echo "$f: has main() but no __name__ guard"
    fi
  fi
done' _ "${FILES[@]}"

# S5: Use pathlib for File Operations
warn "S5: Use pathlib for File Operations" \
    bash -c 'for f in "$@"; do
  if grep -q '"'"'os.path'"'"' "$f"; then
    if ! grep -q '"'"'pathlib'"'"' "$f"; then
      echo "$f: uses os.path, consider pathlib"
    fi
  fi
done' _ "${FILES[@]}"

# S6: Use logging Module
warn "S6: Use logging Module" \
    bash -c 'for f in "$@"; do
  if [ $(wc -l < "$f") -gt 50 ]; then
    if ! grep -q '"'"'import logging\|from logging'"'"' "$f"; then
      echo "$f: large file without logging"
    fi
  fi
done' _ "${FILES[@]}"

# S7: Docstrings on Public Functions
warn "S7: Docstrings on Public Functions" \
    bash -c 'for f in "$@"; do
  awk '"'"'
  /^def [a-z][a-z_]+\(/ {
    fname=$0; getline;
    if ($0 !~ /"""/ && $0 !~ /\x27\x27\x27/) {
      print FILENAME":"NR-1": "fname" - no docstring"
    }
  }
  '"'"' "$f" | head -3
done' _ "${FILES[@]}"

printf '\n%s\n' "═══════════════════════════════════════════"
printf '  PASS: %d  FAIL: %d  WARN: %d\n' "$PASS" "$FAIL" "$WARN"
if [[ $FAIL -eq 0 ]]; then
    green "  RESULT: PASS"
else
    red "  RESULT: FAIL"
fi
printf '%s\n' "═══════════════════════════════════════════"

exit "$FAIL"
