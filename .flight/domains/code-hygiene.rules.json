{
  "domain": "code-hygiene",
  "version": "1.1.0",
  "file_patterns": [
    "**/*.js",
    "**/*.ts",
    "**/*.tsx",
    "**/*.jsx",
    "**/*.py",
    "**/*.go",
    "**/*.rs",
    "**/*.java",
    "**/*.c",
    "**/*.cpp",
    "**/*.h"
  ],
  "exclude_patterns": [
    "**/node_modules/**",
    "**/vendor/**",
    "**/target/**",
    "**/.git/**",
    "**/dist/**",
    "**/build/**"
  ],
  "provenance": {
    "last_full_audit": "2026-01-16",
    "audited_by": "flight-research",
    "next_audit_due": "2026-07-16"
  },
  "rules": [
    {
      "id": "M1",
      "title": "Boolean Variables Use Proper Prefixes",
      "severity": "MUST",
      "type": "grep",
      "pattern": "(const|let|var)\\s+[a-z]+\\s*=\\s*(true|false)\\s*;",
      "query": null,
      "message": "Boolean variables and functions should use is/has/can/should/will/was/did/does prefixes to clearly indicate they return a boolean.",
      "provenance": {
        "last_verified": "2026-01-16",
        "confidence": "high",
        "re_verify_after": "2027-01-16"
      }
    },
    {
      "id": "M2",
      "title": "Collections Use Plural Names",
      "severity": "MUST",
      "type": "grep",
      "pattern": "(const|let|var)\\s+(user|item|order|product|result|file|row|record|entry)\\s*=\\s*\\[",
      "query": null,
      "message": "Arrays, lists, sets, and other collections should use plural names. Singular names should be used for single items.",
      "provenance": {
        "last_verified": "2026-01-16",
        "confidence": "high",
        "re_verify_after": "2027-01-16"
      }
    },
    {
      "id": "M3",
      "title": "Constants Use UPPER_SNAKE_CASE",
      "severity": "MUST",
      "type": "grep",
      "pattern": "const\\s+[a-z][a-zA-Z]*\\s*=\\s*[0-9]+\\s*;",
      "query": null,
      "message": "Constants (values that never change) should use UPPER_SNAKE_CASE to distinguish them from mutable variables.",
      "provenance": {
        "last_verified": "2026-01-16",
        "confidence": "high",
        "re_verify_after": "2027-01-16"
      }
    },
    {
      "id": "M4",
      "title": "Error Messages Include Context",
      "severity": "MUST",
      "type": "grep",
      "pattern": "throw\\s+new\\s+Error\\(['\"][^'\"]{0,15}['\"]|raise\\s+.*Exception\\(['\"][^'\"]{0,15}['\"]",
      "query": null,
      "message": "Error messages should include enough context to understand what failed and why. Generic messages like \"Invalid\" or \"Failed\" are useless.",
      "provenance": {
        "last_verified": "2026-01-16",
        "confidence": "high",
        "re_verify_after": "2027-01-16"
      }
    },
    {
      "id": "M5",
      "title": "Function Names Are Verb Phrases",
      "severity": "MUST",
      "type": "grep",
      "pattern": "^(export\\s+)?(async\\s+)?function\\s+[a-z]+\\s*\\(",
      "query": null,
      "message": "Function names should start with a verb that describes the action. Noun-only names don't describe what the function does.",
      "provenance": {
        "last_verified": "2026-01-16",
        "confidence": "high",
        "re_verify_after": "2027-01-16"
      }
    },
    {
      "id": "N10_js",
      "title": "snake_case Declaration in JavaScript/TypeScript",
      "severity": "NEVER",
      "type": "ast",
      "language": "typescript",
      "pattern": null,
      "query": "; Flag snake_case variable declarations\n(variable_declarator\n  name: (identifier) @violation\n  (#match? @violation \"^[a-z]+_[a-z]\"))\n\n; Flag snake_case function declarations\n(function_declaration\n  name: (identifier) @violation\n  (#match? @violation \"^[a-z]+_[a-z]\"))\n\n; Flag snake_case method definitions\n(method_definition\n  name: (property_identifier) @violation\n  (#match? @violation \"^[a-z]+_[a-z]\"))\n\n; Flag snake_case arrow function variable declarations\n(lexical_declaration\n  (variable_declarator\n    name: (identifier) @violation\n    value: (arrow_function))\n  (#match? @violation \"^[a-z]+_[a-z]\"))",
      "message": "JavaScript and TypeScript declarations should use camelCase, not snake_case. This checks variable declarations, function names, and method names. Property access and object literals (e.g., API responses) are NOT checked.",
      "provenance": {
        "last_verified": "2026-01-20",
        "confidence": "high",
        "re_verify_after": "2027-01-20"
      }
    },
    {
      "id": "N10_py",
      "title": "camelCase Declaration in Python",
      "severity": "NEVER",
      "type": "ast",
      "language": "python",
      "pattern": null,
      "query": "; Flag camelCase function definitions\n(function_definition\n  name: (identifier) @violation\n  (#match? @violation \"^[a-z]+[A-Z]\"))\n\n; Flag camelCase in simple assignments (top-level variables)\n(assignment\n  left: (identifier) @violation\n  (#match? @violation \"^[a-z]+[A-Z]\"))",
      "message": "Python declarations should use snake_case, not camelCase (PEP 8). This checks function definitions and variable assignments. Class names (PascalCase) are NOT flagged.",
      "provenance": {
        "last_verified": "2026-01-20",
        "confidence": "high",
        "re_verify_after": "2027-01-20"
      }
    },
    {
      "id": "N1",
      "title": "Generic Variable Names",
      "severity": "NEVER",
      "type": "grep",
      "pattern": "^\\s*(const|let|var|)\\s*(data|result|temp|tmp|info|item|value|val|obj|thing|stuff|ret|res|output|input|payload)\\s*=",
      "query": null,
      "message": "Do not use generic names like data, result, temp, item, value, obj. The name should describe WHAT it holds, not THAT it holds something.",
      "provenance": {
        "last_verified": "2026-01-16",
        "confidence": "high",
        "re_verify_after": "2027-01-16"
      }
    },
    {
      "id": "N2",
      "title": "Redundant Conditional Returns",
      "severity": "NEVER",
      "type": "grep",
      "pattern": "if\\s*\\([^)]+\\)\\s*return\\s+(true|false)\\s*;\\s*(else\\s*)?(return\\s+(true|false))?",
      "query": null,
      "message": "Do not use if/else to return boolean literals. Return the condition directly.",
      "provenance": {
        "last_verified": "2026-01-16",
        "confidence": "high",
        "re_verify_after": "2027-01-16"
      }
    },
    {
      "id": "N3",
      "title": "Ternary Returning Boolean Literals",
      "severity": "NEVER",
      "type": "grep",
      "pattern": "\\?\\s*true\\s*:\\s*false|\\?\\s*false\\s*:\\s*true",
      "query": null,
      "message": "Do not use ternary operator to return true/false. Use the condition directly.",
      "provenance": {
        "last_verified": "2026-01-16",
        "confidence": "high",
        "re_verify_after": "2027-01-16"
      }
    },
    {
      "id": "N4",
      "title": "Redundant Boolean Comparisons",
      "severity": "NEVER",
      "type": "grep",
      "pattern": "===?\\s*true|===?\\s*false|!==?\\s*true|!==?\\s*false",
      "query": null,
      "message": "Do not compare booleans to true/false. Use the boolean directly.",
      "provenance": {
        "last_verified": "2026-01-16",
        "confidence": "high",
        "re_verify_after": "2027-01-16"
      }
    },
    {
      "id": "N5",
      "title": "Magic Number Calculations",
      "severity": "NEVER",
      "type": "grep",
      "pattern": "60\\s*\\*\\s*60|24\\s*\\*\\s*60|1000\\s*\\*\\s*60|7\\s*\\*\\s*24|1024\\s*\\*\\s*1024",
      "query": null,
      "message": "Do not use raw arithmetic for time/size calculations. Define named constants.",
      "provenance": {
        "last_verified": "2026-01-16",
        "confidence": "high",
        "re_verify_after": "2027-01-16"
      }
    },
    {
      "id": "N6",
      "title": "Generic Function Names",
      "severity": "NEVER",
      "type": "grep",
      "pattern": "function\\s+(handleData|processItem|processItems|doSomething|getData|setData|updateValue|handleEvent|processResult|transformData|handleInput|processInput)\\s*\\(|def\\s+(handle_data|process_item|do_something|get_data|set_data|update_value|handle_event|process_result|transform_data)\\s*\\(",
      "query": null,
      "message": "Function names should include the domain noun they operate on. Avoid handleData, processItem, doSomething, etc.",
      "provenance": {
        "last_verified": "2026-01-16",
        "confidence": "high",
        "re_verify_after": "2027-01-16"
      }
    },
    {
      "id": "N7",
      "title": "Single-Letter Variables Outside Loops",
      "severity": "NEVER",
      "type": "grep",
      "pattern": "^\\s*(const|let|var|)\\s+[a-hk-wyz]\\s*=",
      "query": null,
      "message": "Single-letter variables are only acceptable as loop counters (i, j, k) or in very short lambdas. Otherwise use descriptive names.",
      "provenance": {
        "last_verified": "2026-01-16",
        "confidence": "high",
        "re_verify_after": "2027-01-16"
      }
    },
    {
      "id": "N8",
      "title": "Console/Print Debugging in Production Code",
      "severity": "NEVER",
      "type": "grep",
      "pattern": "console\\.(log|warn|error)\\s*\\(|print\\s*\\(|System\\.out\\.print|println!\\s*\\(|fmt\\.Print",
      "query": null,
      "message": "Do not leave console.log, print, or similar debugging statements in production code. Use a proper logging framework.",
      "provenance": {
        "last_verified": "2026-01-16",
        "confidence": "high",
        "re_verify_after": "2027-01-16"
      }
    },
    {
      "id": "N9",
      "title": "Negated Boolean Names",
      "severity": "NEVER",
      "type": "grep",
      "pattern": "(is|has|can|should|will)(Not|No)[A-Z]",
      "query": null,
      "message": "Avoid boolean names with negative prefixes (isNot, hasNo, cannot). They lead to confusing double negatives like !isNotValid.",
      "provenance": {
        "last_verified": "2026-01-16",
        "confidence": "high",
        "re_verify_after": "2027-01-16"
      }
    },
    {
      "id": "N12",
      "title": "Hardcoded API Keys",
      "severity": "NEVER",
      "type": "grep",
      "pattern": "(api[_-]?key|apikey|api[_-]?secret|secret[_-]?key)\\s*[=:]\\s*['\"][a-zA-Z0-9_\\-]{16,}['\"]",
      "query": null,
      "message": "Do not hardcode API keys, tokens, or secrets in source code. Use environment variables or secret management systems instead.",
      "provenance": {
        "last_verified": "2026-01-25",
        "confidence": "high",
        "re_verify_after": "2026-07-25"
      }
    },
    {
      "id": "N13",
      "title": "Hardcoded Passwords and Secrets",
      "severity": "NEVER",
      "type": "grep",
      "pattern": "(password|passwd|pwd|db_pass|database_password|auth_token|bearer_token)\\s*[=:]\\s*['\"][^'\"]{8,}['\"]",
      "query": null,
      "message": "Do not hardcode passwords, database credentials, or authentication tokens in source code. These must come from environment variables or secret stores.",
      "provenance": {
        "last_verified": "2026-01-25",
        "confidence": "high",
        "re_verify_after": "2026-07-25"
      }
    }
  ]
}