{
  "domain": "rust",
  "version": "1.1.0",
  "file_patterns": [
    "**/*.rs"
  ],
  "exclude_patterns": [
    "**/target/**",
    "**/.git/**"
  ],
  "provenance": {
    "last_full_audit": "2026-01-20",
    "audited_by": "flight-research",
    "next_audit_due": "2026-07-20"
  },
  "rules": [
    {
      "id": "M1",
      "title": "Use ? Operator for Error Propagation",
      "severity": "MUST",
      "type": "grep",
      "pattern": "match\\s+\\w+\\s*\\{[^}]*Ok\\s*\\(\\s*\\w+\\s*\\)\\s*=>\\s*\\w+\\s*,",
      "query": null,
      "message": "Prefer the ? operator over match/unwrap chains for error propagation. It's more concise and idiomatic.",
      "provenance": {
        "last_verified": "2026-01-20",
        "confidence": "high",
        "re_verify_after": "2027-01-20"
      }
    },
    {
      "id": "M2",
      "title": "Clone Abuse - Cloning to Satisfy Borrow Checker",
      "severity": "MUST",
      "type": "grep",
      "pattern": "&\\w+\\.clone\\(\\)|\\.clone\\(\\)\\s*\\)",
      "query": null,
      "message": "Do not clone just to satisfy the borrow checker. This indicates a design issue. Restructure code, use references, or use Rc/Arc if shared ownership is needed.",
      "provenance": {
        "last_verified": "2026-01-20",
        "confidence": "high",
        "re_verify_after": "2027-01-20"
      }
    },
    {
      "id": "M3",
      "title": "String Parameter When &str Would Work",
      "severity": "MUST",
      "type": "grep",
      "pattern": "fn\\s+\\w+\\s*\\([^)]*:\\s*&?String[^)]*(,|\\))|fn\\s+\\w+\\s*<[^>]*>\\s*\\([^)]*:\\s*&?String",
      "query": null,
      "message": "Function parameters should use &str instead of String or &String when the function only reads the string. This accepts both String and &str.",
      "provenance": {
        "last_verified": "2026-01-20",
        "confidence": "high",
        "re_verify_after": "2027-01-20"
      }
    },
    {
      "id": "M4",
      "title": "Vec Parameter When Slice Would Work",
      "severity": "MUST",
      "type": "grep",
      "pattern": "fn\\s+\\w+\\s*\\([^)]*:\\s*&Vec<[^>]+>[^)]*(,|\\))",
      "query": null,
      "message": "Function parameters should use &[T] instead of &Vec<T> when the function only reads the vector. Slices are more general.",
      "provenance": {
        "last_verified": "2026-01-20",
        "confidence": "high",
        "re_verify_after": "2027-01-20"
      }
    },
    {
      "id": "M5",
      "title": "Box<T> When T Would Work",
      "severity": "MUST",
      "type": "grep",
      "pattern": "Box<(String|Vec<|HashMap<|HashSet<)",
      "query": null,
      "message": "Avoid unnecessary Box<T> allocations. Use Box only for recursive types, trait objects, or when you need stable addresses.",
      "provenance": {
        "last_verified": "2026-01-20",
        "confidence": "high",
        "re_verify_after": "2027-01-20"
      }
    },
    {
      "id": "M6",
      "title": "println! in Library Code",
      "severity": "MUST",
      "type": "grep",
      "pattern": "println!\\s*\\(|print!\\s*\\(|eprintln!\\s*\\(|eprint!\\s*\\(",
      "query": null,
      "message": "Libraries should not use println!/print!/eprintln! for output. Use the log or tracing crate for configurable logging.",
      "provenance": {
        "last_verified": "2026-01-20",
        "confidence": "high",
        "re_verify_after": "2027-01-20"
      }
    },
    {
      "id": "N1",
      "title": "Unsafe Block Without Safety Comment",
      "severity": "NEVER",
      "type": "ast",
      "language": "rust",
      "pattern": null,
      "query": "(unsafe_block) @violation",
      "message": "All unsafe blocks must have a SAFETY comment explaining why the unsafe code is sound. Document what invariants must be upheld.",
      "provenance": {
        "last_verified": "2026-01-20",
        "confidence": "high",
        "re_verify_after": "2027-01-20"
      }
    },
    {
      "id": "N2",
      "title": "mem::transmute Usage",
      "severity": "NEVER",
      "type": "ast",
      "language": "rust",
      "pattern": null,
      "query": "(call_expression\n  function: [\n    (scoped_identifier\n      name: (identifier) @fn)\n    (generic_function\n      function: (scoped_identifier\n        name: (identifier) @fn))\n  ]\n  (#eq? @fn \"transmute\")) @violation",
      "message": "Avoid mem::transmute - it's extremely dangerous and almost never needed. Use safer alternatives like from_ne_bytes, as casts, or pointer casts.",
      "provenance": {
        "last_verified": "2026-01-20",
        "confidence": "high",
        "re_verify_after": "2027-01-20"
      }
    },
    {
      "id": "N3",
      "title": "Panic in Library Code",
      "severity": "NEVER",
      "type": "grep",
      "pattern": "panic!\\s*\\(|todo!\\s*\\(|unimplemented!\\s*\\(",
      "query": null,
      "message": "Libraries should not panic on recoverable errors. Return Result or Option instead. Panics should only occur for programmer errors (invariant violations).",
      "provenance": {
        "last_verified": "2026-01-20",
        "confidence": "high",
        "re_verify_after": "2027-01-20"
      }
    },
    {
      "id": "N4",
      "title": ".unwrap() in Production Code",
      "severity": "NEVER",
      "type": "grep",
      "pattern": "\\.unwrap\\(\\s*\\)",
      "query": null,
      "message": "Do not use .unwrap() in production code. Use ?, .expect() with a message, or proper error handling. Unwrap hides the failure reason.",
      "provenance": {
        "last_verified": "2026-01-20",
        "confidence": "high",
        "re_verify_after": "2027-01-20"
      }
    },
    {
      "id": "N5",
      "title": ".expect() Without Descriptive Message",
      "severity": "NEVER",
      "type": "grep",
      "pattern": "\\.expect\\s*\\(\\s*\"\"\\s*\\)|\\.expect\\s*\\(\\s*\\)",
      "query": null,
      "message": "When using .expect(), always provide a descriptive message explaining why the value should be present. Empty or generic messages defeat the purpose.",
      "provenance": {
        "last_verified": "2026-01-20",
        "confidence": "high",
        "re_verify_after": "2027-01-20"
      }
    },
    {
      "id": "N6",
      "title": "Raw Pointer Arithmetic Without Bounds Check",
      "severity": "NEVER",
      "type": "grep",
      "pattern": "\\.offset\\s*\\(|\\.add\\s*\\(|\\.sub\\s*\\(|\\.wrapping_offset\\s*\\(",
      "query": null,
      "message": "Raw pointer arithmetic (offset, add, sub) requires bounds checking. Going out of bounds is undefined behavior even without dereferencing.",
      "provenance": {
        "last_verified": "2026-01-20",
        "confidence": "high",
        "re_verify_after": "2027-01-20"
      }
    },
    {
      "id": "N7",
      "title": "mem::forget Without Clear Justification",
      "severity": "NEVER",
      "type": "grep",
      "pattern": "mem::forget\\s*\\(|std::mem::forget\\s*\\(",
      "query": null,
      "message": "mem::forget prevents destructors from running, causing resource leaks. Almost always indicates a design problem. Use ManuallyDrop if needed.",
      "provenance": {
        "last_verified": "2026-01-20",
        "confidence": "high",
        "re_verify_after": "2027-01-20"
      }
    },
    {
      "id": "S1",
      "title": "Use Iterators Over Manual Loops",
      "severity": "SHOULD",
      "type": "grep",
      "pattern": "for\\s+\\w+\\s+in\\s+0\\s*\\.\\.\\s*\\w+\\.len\\(\\)",
      "query": null,
      "message": "Prefer iterator methods (map, filter, fold) over manual for loops when appropriate. They're often more readable and optimizable.",
      "provenance": {
        "last_verified": "2026-01-20",
        "confidence": "high",
        "re_verify_after": "2027-01-20"
      }
    },
    {
      "id": "S2",
      "title": "Use if let for Single-Arm Matches",
      "severity": "SHOULD",
      "type": "grep",
      "pattern": "match\\s+\\w+\\s*\\{[^}]*_\\s*=>\\s*\\{\\s*\\}[^}]*\\}",
      "query": null,
      "message": "Use if let instead of match when you only care about one pattern. It's more concise and clearly expresses intent.",
      "provenance": {
        "last_verified": "2026-01-20",
        "confidence": "high",
        "re_verify_after": "2027-01-20"
      }
    },
    {
      "id": "S5",
      "title": "Avoid Wildcard Imports",
      "severity": "SHOULD",
      "type": "grep",
      "pattern": "^use\\s+[^;]+::\\*;",
      "query": null,
      "message": "Avoid use foo::* imports in production code. They make it unclear where names come from and can cause conflicts when dependencies update.",
      "provenance": {
        "last_verified": "2026-01-20",
        "confidence": "high",
        "re_verify_after": "2027-01-20"
      }
    },
    {
      "id": "S6",
      "title": "Use snake_case for Functions and Variables",
      "severity": "SHOULD",
      "type": "grep",
      "pattern": "(let|fn)\\s+[a-z]+[A-Z][a-zA-Z]*\\s*[=:(]",
      "query": null,
      "message": "Rust conventions require snake_case for functions, methods, variables, and modules. CamelCase is for types and traits only.",
      "provenance": {
        "last_verified": "2026-01-20",
        "confidence": "high",
        "re_verify_after": "2027-01-20"
      }
    },
    {
      "id": "S7",
      "title": "Avoid Large Stack Allocations",
      "severity": "SHOULD",
      "type": "grep",
      "pattern": "\\[\\s*[a-z0-9_]+\\s*;\\s*[0-9]{4,}\\s*\\]",
      "query": null,
      "message": "Avoid large structs (>1KB) on the stack. Use Box for large data to prevent stack overflow in deeply recursive code.",
      "provenance": {
        "last_verified": "2026-01-20",
        "confidence": "medium",
        "re_verify_after": "2026-07-20"
      }
    },
    {
      "id": "S8",
      "title": "Prefer From/Into Over as for Type Conversions",
      "severity": "SHOULD",
      "type": "grep",
      "pattern": "\\s+as\\s+(u8|u16|u32|i8|i16|i32)\\s*[;,)\\]]",
      "query": null,
      "message": "Use From/Into traits for type conversions instead of 'as' casts when possible. From/Into are checked and more explicit about conversion intent.",
      "provenance": {
        "last_verified": "2026-01-20",
        "confidence": "high",
        "re_verify_after": "2027-01-20"
      }
    }
  ]
}