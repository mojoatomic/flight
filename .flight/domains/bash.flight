# bash.flight - Production shell script patterns
# Source: Migrated from bash.md and bash.validate.sh

domain: bash
version: 1.1.0
schema_version: 2
description: >
  Production shell script patterns. Safe, portable, maintainable.
  Enforces quoting, strict mode, error handling, and security best practices.

# ===========================================================================
# PROVENANCE - Schema v2 audit trail
# ===========================================================================
provenance:
  last_full_audit: "2026-01-16"
  audited_by: "flight-research"
  next_audit_due: "2026-07-16"
  sources_consulted:
    - url: "https://google.github.io/styleguide/shellguide.html"
      accessed: "2026-01-16"
      note: "Google Shell Style Guide"
    - url: "https://www.shellcheck.net/wiki/"
      accessed: "2026-01-16"
      note: "ShellCheck Wiki - static analysis rules"
    - url: "https://mywiki.wooledge.org/BashPitfalls"
      accessed: "2026-01-16"
      note: "Bash Pitfalls - common mistakes"
    - url: "https://www.gnu.org/software/bash/manual/bash.html"
      accessed: "2026-01-16"
      note: "GNU Bash Manual"
  coverage:
    apis_covered:
      - "Variable quoting and expansion"
      - "Command substitution"
      - "Test constructs"
      - "Function declarations"
      - "Error handling (set -e, traps)"
      - "File operations safety"
      - "Security patterns (temp files, eval)"
    known_gaps:
      - "Process substitution patterns"
      - "Advanced signal handling"
      - "Bash 5.x specific features"
      - "Associative array patterns"

file_patterns:
  - "**/*.sh"

exclude_patterns:
  - "**/node_modules/**"
  - "**/dist/**"
  - "**/build/**"
  - "**/.git/**"
  - "**/vendor/**"

suppression:
  comment: "# shellcheck"
  guidance: |
    ShellCheck directives suppress specific warnings.
    Example: # shellcheck disable=SC2086

# ===========================================================================
# RULES
# ===========================================================================
# Bash/Shell-SPECIFIC rules. Universal code hygiene rules are in
# code-hygiene.flight.
#
# ID format: {severity_prefix}{number}
#   N = NEVER (check - fails build)
#   M = MUST (check - fails build)
#   S = SHOULD (warn - advisory)
#   G = GUIDANCE (not checked)
# ===========================================================================

rules:

  # =========================================================================
  # NEVER - Shell scripting anti-patterns (validator will reject)
  # =========================================================================

  N1:
    title: Unquoted Variables in Commands
    severity: NEVER
    mechanical: false
    description: >
      Unquoted variables undergo word splitting and glob expansion.
      This breaks on filenames with spaces and can match unintended files.
    provenance:
      last_verified: "2026-01-16"
      confidence: high
      re_verify_after: "2027-01-16"
      sources:
        - url: "https://www.shellcheck.net/wiki/SC2086"
          accessed: "2026-01-16"
          quote: "Double quote to prevent globbing and word splitting"
        - url: "https://mywiki.wooledge.org/BashPitfalls#pf1"
          accessed: "2026-01-16"
          quote: "for f in $(ls *.mp3) - Word-splitting and glob expansion"
    note: |
      Word splitting: $var with spaces becomes multiple arguments.
      Glob expansion: $var with * matches files.
      Always quote: "$var"
    examples:
      bad:
        - "rm $files"
        - "cp $src $dest"
      good:
        - 'rm "$files"'
        - 'cp "$src" "$dest"'

  N2:
    title: Unquoted $(cmd) Substitution
    severity: NEVER
    mechanical: false
    description: >
      Unquoted command substitution has the same word splitting and
      glob expansion issues as unquoted variables.
    provenance:
      last_verified: "2026-01-16"
      confidence: high
      re_verify_after: "2027-01-16"
      sources:
        - url: "https://www.shellcheck.net/wiki/SC2046"
          accessed: "2026-01-16"
          quote: "Quote this to prevent word splitting"
        - url: "https://google.github.io/styleguide/shellguide.html#quoting"
          accessed: "2026-01-16"
          quote: "Always quote strings containing variables, command substitutions"
    note: |
      The output of $(cmd) can contain spaces or glob characters.
      Always quote: "$(cmd)"
    examples:
      bad:
        - |
          result=$(get_path)
          cd $result
      good:
        - |
          result="$(get_path)"
          cd "$result"

  N3:
    title: Parsing ls Output
    severity: NEVER
    mechanical: false
    description: >
      Parsing ls output breaks on filenames with spaces, newlines, or
      special characters. Use globs or find instead.
    provenance:
      last_verified: "2026-01-16"
      confidence: high
      re_verify_after: "2027-01-16"
      sources:
        - url: "https://www.shellcheck.net/wiki/SC2012"
          accessed: "2026-01-16"
          quote: "Use find instead of ls to better handle non-alphanumeric filenames"
        - url: "https://mywiki.wooledge.org/ParsingLs"
          accessed: "2026-01-16"
          quote: "Parsing ls is fraught with peril"
    note: |
      ls output is for humans, not scripts. Filenames can contain
      any character except / and NUL. Use glob patterns or find -print0.
    examples:
      bad:
        - "for f in $(ls *.txt); do"
        - "for f in `ls`; do"
      good:
        - "for f in *.txt; do"
        - "for f in *; do"
        - |
          find . -name "*.txt" -print0 | while IFS= read -r -d '' f; do

  N4:
    title: Backticks for Command Substitution
    severity: NEVER
    mechanical: false
    description: >
      Backticks are the old style command substitution. They can't nest
      easily and are harder to read than $().
    provenance:
      last_verified: "2026-01-16"
      confidence: high
      re_verify_after: "2027-01-16"
      sources:
        - url: "https://www.shellcheck.net/wiki/SC2006"
          accessed: "2026-01-16"
          quote: "Use $(...) notation instead of legacy backticks"
        - url: "https://google.github.io/styleguide/shellguide.html#command-substitution"
          accessed: "2026-01-16"
          quote: "Use $(command) instead of backticks"
    note: |
      $() can nest: $(cmd1 $(cmd2))
      Backticks require escaping: `cmd1 \`cmd2\``
    examples:
      bad:
        - "result=`command`"
      good:
        - "result=$(command)"

  N5:
    title: Single Brackets [ ] in Bash
    severity: NEVER
    mechanical: false
    description: >
      In bash scripts, use [[ ]] instead of [ ]. Single brackets require
      quoting and don't support pattern matching or regex.
    provenance:
      last_verified: "2026-01-16"
      confidence: high
      re_verify_after: "2027-01-16"
      sources:
        - url: "https://google.github.io/styleguide/shellguide.html#test----and--"
          accessed: "2026-01-16"
          quote: "[[ ... ]] is preferred over [ ... ], test and /usr/bin/["
        - url: "https://mywiki.wooledge.org/BashFAQ/031"
          accessed: "2026-01-16"
          quote: "[[ is a bash keyword similar to (but more powerful than) ["
    note: |
      [[ ]] is safer: no word splitting on variables.
      [[ ]] supports: regex (=~), pattern matching (*), logical operators (&&, ||).
    examples:
      bad:
        - '[ -z $var ]'
        - '[ $var = "foo" ]'
      good:
        - '[[ -z "$var" ]]'
        - '[[ "$var" = "foo" ]]'
        - '[[ "$string" =~ ^[0-9]+$ ]]'

  N6:
    title: "'function' Keyword"
    severity: NEVER
    mechanical: false
    description: >
      The 'function' keyword is bash-specific and not POSIX compliant.
      Use the portable name() { } syntax.
    provenance:
      last_verified: "2026-01-16"
      confidence: high
      re_verify_after: "2027-01-16"
      sources:
        - url: "https://google.github.io/styleguide/shellguide.html#function-names"
          accessed: "2026-01-16"
          quote: "Use the function keyword and parentheses together: function foo() {"
        - url: "https://www.shellcheck.net/wiki/SC2112"
          accessed: "2026-01-16"
          quote: "'function' keyword is non-standard"
    note: |
      'function foo {' is bash-only.
      'foo() {' works in bash, sh, dash, and other shells.
    examples:
      bad:
        - |
          function do_something {
              ...
          }
      good:
        - |
          do_something() {
              ...
          }

  N7:
    title: Bare 'cd' Without Error Handling
    severity: NEVER
    mechanical: false
    description: >
      cd can fail (permissions, path doesn't exist). Without error handling,
      the script continues in the wrong directory.
    provenance:
      last_verified: "2026-01-16"
      confidence: high
      re_verify_after: "2027-01-16"
      sources:
        - url: "https://www.shellcheck.net/wiki/SC2164"
          accessed: "2026-01-16"
          quote: "Use 'cd ... || exit' or 'cd ... || return' in case cd fails"
        - url: "https://mywiki.wooledge.org/BashPitfalls#pf27"
          accessed: "2026-01-16"
          quote: "cd /some/path - cd can fail"
    note: |
      If cd fails and script continues, subsequent commands run in
      the wrong directory. rm -rf * could delete the wrong files.
    examples:
      bad:
        - |
          cd "$some_dir"
          rm -rf *  # Runs in wrong dir if cd failed!
      good:
        - 'cd "$some_dir" || exit 1'
        - 'cd "$some_dir" || { echo "Failed to cd"; exit 1; }'

  N8:
    title: Useless Cat
    severity: NEVER
    mechanical: false
    description: >
      cat file | cmd creates an extra process. Most commands can read
      files directly or via stdin redirection.
    provenance:
      last_verified: "2026-01-16"
      confidence: high
      re_verify_after: "2027-01-16"
      sources:
        - url: "https://www.shellcheck.net/wiki/SC2002"
          accessed: "2026-01-16"
          quote: "Useless cat. Consider 'cmd < file' or 'cmd file' instead"
        - url: "https://en.wikipedia.org/wiki/Cat_(Unix)#Useless_use_of_cat"
          accessed: "2026-01-16"
          quote: "Useless use of cat - using cat when not necessary"
    note: |
      cat file | grep is 2 processes. grep pattern file is 1 process.
      For stdin: cmd < file
    examples:
      bad:
        - "cat file.txt | grep 'pattern'"
        - "cat file.txt | wc -l"
      good:
        - "grep 'pattern' file.txt"
        - "wc -l < file.txt"

  N9:
    title: eval Usage
    severity: NEVER
    mechanical: false
    description: >
      eval executes arbitrary code. With user input, this is command injection.
      Use arrays for dynamic commands.
    provenance:
      last_verified: "2026-01-16"
      confidence: high
      re_verify_after: "2027-01-16"
      sources:
        - url: "https://mywiki.wooledge.org/BashFAQ/048"
          accessed: "2026-01-16"
          quote: "eval is evil... it can execute arbitrary code"
        - url: "https://www.shellcheck.net/wiki/SC2086"
          accessed: "2026-01-16"
          quote: "Variables in eval should be quoted to prevent word splitting"
    note: |
      eval "$cmd" with user input = remote code execution.
      Use arrays: cmd_args=("$prog" "$arg"); "${cmd_args[@]}"
    examples:
      bad:
        - 'eval "$user_command"'
      good:
        - |
          cmd_args=("$program" "$arg1" "$arg2")
          "${cmd_args[@]}"

  N10:
    title: Hardcoded /tmp Files
    severity: NEVER
    mechanical: false
    description: >
      Hardcoded temp paths are predictable and create race conditions.
      Use mktemp for unique, secure temporary files.
    provenance:
      last_verified: "2026-01-16"
      confidence: high
      re_verify_after: "2027-01-16"
      sources:
        - url: "https://www.shellcheck.net/wiki/SC2087"
          accessed: "2026-01-16"
          quote: "Use mktemp to create temporary files"
        - url: "https://cwe.mitre.org/data/definitions/377.html"
          accessed: "2026-01-16"
          quote: "CWE-377: Insecure Temporary File"
    note: |
      /tmp/myscript.tmp is predictable. Attacker can create symlink
      before your script runs. mktemp creates unique names safely.
    examples:
      bad:
        - 'tmp_file="/tmp/myscript.tmp"'
      good:
        - 'tmp_file=$(mktemp)'

  N11:
    title: curl|bash Remote Code Execution
    severity: NEVER
    mechanical: false
    description: >
      Piping remote scripts directly to bash executes untrusted code.
      Download, inspect, then execute.
    provenance:
      last_verified: "2026-01-16"
      confidence: high
      re_verify_after: "2027-01-16"
      sources:
        - url: "https://www.idontplaydarts.com/2016/04/detecting-curl-pipe-bash-server-side/"
          accessed: "2026-01-16"
          quote: "curl | bash is dangerous - partial downloads can execute"
        - url: "https://owasp.org/www-community/attacks/Code_Injection"
          accessed: "2026-01-16"
          quote: "Code injection is the exploitation of a computer bug"
    note: |
      curl | bash executes whatever the server sends.
      Partial downloads can execute incomplete scripts.
      Download to file, inspect, then run.
    examples:
      bad:
        - "curl -fsSL https://example.com/install.sh | bash"
      good:
        - |
          curl -fsSL https://example.com/install.sh -o install.sh
          less install.sh  # review
          ./install.sh

  N12:
    title: Unquoted Array Expansion
    severity: NEVER
    mechanical: false
    description: >
      ${arr[*]} joins array elements into a single string.
      Use "${arr[@]}" to preserve separate elements.
    provenance:
      last_verified: "2026-01-16"
      confidence: high
      re_verify_after: "2027-01-16"
      sources:
        - url: "https://www.shellcheck.net/wiki/SC2145"
          accessed: "2026-01-16"
          quote: "Argument mixes string and array. Use * or separate lines"
        - url: "https://mywiki.wooledge.org/BashGuide/Arrays"
          accessed: "2026-01-16"
          quote: "${array[@]} expands each element as separate word"
    note: |
      ${arr[*]} = "a b c" (one string)
      "${arr[@]}" = "a" "b" "c" (three strings)
    examples:
      bad:
        - 'echo ${arr[*]}'
      good:
        - 'echo "${arr[@]}"'

  # =========================================================================
  # MUST - Required patterns (validator will reject)
  # =========================================================================

  M1:
    title: Shebang Required
    severity: MUST
    mechanical: false
    description: >
      Every script must have a shebang declaring the interpreter.
      This ensures the script runs with the intended shell.
    provenance:
      last_verified: "2026-01-16"
      confidence: high
      re_verify_after: "2027-01-16"
      sources:
        - url: "https://google.github.io/styleguide/shellguide.html#file-header"
          accessed: "2026-01-16"
          quote: "Start each file with a description of its contents"
        - url: "https://www.shellcheck.net/wiki/SC2148"
          accessed: "2026-01-16"
          quote: "Tips depend on target shell and target is not specified"
    note: |
      Without shebang, the system default shell runs the script.
      #!/bin/bash for bash features, #!/bin/sh for POSIX compatibility.
    examples:
      good:
        - "#!/bin/bash"
        - "#!/bin/sh"
        - "#!/usr/bin/env bash"

  M2:
    title: Strict Mode Required
    severity: MUST
    mechanical: false
    description: >
      Scripts must enable strict mode with set -euo pipefail.
      This catches errors early instead of silently continuing.
    provenance:
      last_verified: "2026-01-16"
      confidence: high
      re_verify_after: "2027-01-16"
      sources:
        - url: "https://www.gnu.org/software/bash/manual/html_node/The-Set-Builtin.html"
          accessed: "2026-01-16"
          quote: "-e: Exit immediately if a pipeline... returns non-zero"
        - url: "https://google.github.io/styleguide/shellguide.html#s7.1-errexit"
          accessed: "2026-01-16"
          quote: "Always use set -e"
    note: |
      -e: Exit on any command failure
      -u: Error on undefined variables
      -o pipefail: Pipeline fails if any command fails
    examples:
      good:
        - |
          #!/bin/bash
          set -euo pipefail

  # =========================================================================
  # SHOULD - Best practices (validator warns)
  # =========================================================================

  S1:
    title: Safe Path Pattern Before cd
    severity: SHOULD
    mechanical: false
    description: >
      When using cd, either use pushd/popd or capture the original directory
      to ensure relative paths still work after directory change.
    provenance:
      last_verified: "2026-01-16"
      confidence: high
      re_verify_after: "2027-01-16"
      sources:
        - url: "https://google.github.io/styleguide/shellguide.html#changing-directories"
          accessed: "2026-01-16"
          quote: "Use pushd and popd when changing directories"
        - url: "https://mywiki.wooledge.org/BashPitfalls#pf27"
          accessed: "2026-01-16"
          quote: "Paths relative to original directory break after cd"
    note: |
      Relative paths break after cd. Either:
      1. Use pushd/popd to restore directory
      2. Capture pwd before cd
      3. Convert relative paths to absolute with realpath
    examples:
      good:
        - |
          pushd "$target_dir" > /dev/null
          # ... do work
          popd > /dev/null
        - |
          original_dir="$(pwd)"
          cd "$project_dir"
          cat "$original_dir/config.json"

  S2:
    title: Functions Should Use 'local'
    severity: SHOULD
    mechanical: false
    description: >
      Variables assigned in functions should use 'local' to avoid
      polluting the global namespace.
    provenance:
      last_verified: "2026-01-16"
      confidence: high
      re_verify_after: "2027-01-16"
      sources:
        - url: "https://google.github.io/styleguide/shellguide.html#local-variables"
          accessed: "2026-01-16"
          quote: "Declare function-specific variables with local"
        - url: "https://www.shellcheck.net/wiki/SC2155"
          accessed: "2026-01-16"
          quote: "Declare and assign separately to avoid masking return values"
    note: |
      Without local, function variables are global. This causes
      subtle bugs when function names collide with outer scope.
    examples:
      bad:
        - |
          process_file() {
              result="processed"  # Global!
          }
      good:
        - |
          process_file() {
              local result="processed"
          }

  S3:
    title: mktemp Needs Cleanup Trap
    severity: SHOULD
    mechanical: false
    description: >
      Scripts using mktemp should set up a trap to clean up temp files
      on exit, even if the script fails.
    provenance:
      last_verified: "2026-01-16"
      confidence: high
      re_verify_after: "2027-01-16"
      sources:
        - url: "https://www.gnu.org/software/bash/manual/html_node/Bourne-Shell-Builtins.html#index-trap"
          accessed: "2026-01-16"
          quote: "trap is used to specify cleanup actions for signals and exit"
        - url: "https://mywiki.wooledge.org/BashFAQ/062"
          accessed: "2026-01-16"
          quote: "Use trap to clean up temporary files"
    note: |
      Without trap, temp files accumulate on failures.
      trap 'rm -f "$tmp"' EXIT runs on normal exit and signals.
    examples:
      good:
        - |
          tmp_file=$(mktemp)
          trap 'rm -f "$tmp_file"' EXIT

  S4:
    title: Constants Should Use readonly
    severity: SHOULD
    mechanical: false
    description: >
      Script constants (UPPER_CASE variables) should use readonly
      to prevent accidental modification.
    provenance:
      last_verified: "2026-01-16"
      confidence: high
      re_verify_after: "2027-01-16"
      sources:
        - url: "https://google.github.io/styleguide/shellguide.html#constants-and-environment-variable-names"
          accessed: "2026-01-16"
          quote: "Constants and environment variable names should be all caps"
        - url: "https://www.gnu.org/software/bash/manual/html_node/Bourne-Shell-Builtins.html#index-readonly"
          accessed: "2026-01-16"
          quote: "readonly prevents the value from being changed"
    note: |
      readonly prevents accidental reassignment.
      Makes script intent clearer.
    examples:
      bad:
        - 'VERSION="1.0.0"'
      good:
        - 'readonly VERSION="1.0.0"'

  S5:
    title: Read Loops Need 'IFS= read -r'
    severity: SHOULD
    mechanical: false
    description: >
      Read loops should use 'IFS= read -r' to preserve whitespace
      and backslashes in input.
    provenance:
      last_verified: "2026-01-16"
      confidence: high
      re_verify_after: "2027-01-16"
      sources:
        - url: "https://www.shellcheck.net/wiki/SC2162"
          accessed: "2026-01-16"
          quote: "read without -r will mangle backslashes"
        - url: "https://mywiki.wooledge.org/BashFAQ/001"
          accessed: "2026-01-16"
          quote: "Use IFS= read -r line for robust line reading"
    note: |
      Without IFS=, leading/trailing whitespace is stripped.
      Without -r, backslashes are interpreted as escapes.
    examples:
      bad:
        - "while read line; do"
      good:
        - "while IFS= read -r line; do"

  S6:
    title: Lines Under 100 Characters
    severity: SHOULD
    mechanical: false
    description: >
      Keep lines under 100 characters for readability.
      Use backslash continuation for long commands.
    provenance:
      last_verified: "2026-01-16"
      confidence: medium
      re_verify_after: "2026-07-16"
      sources:
        - url: "https://google.github.io/styleguide/shellguide.html#line-length"
          accessed: "2026-01-16"
          quote: "Maximum line length is 80 characters"
    note: |
      Long lines are hard to read and review.
      Break at logical points with backslash.
    examples:
      good:
        - |
          long_command \
              --option1 \
              --option2

  S7:
    title: Prefer printf Over echo
    severity: SHOULD
    mechanical: false
    description: >
      printf behavior is consistent across systems. echo behavior
      varies (escapes, options) between shells and platforms.
    provenance:
      last_verified: "2026-01-16"
      confidence: high
      re_verify_after: "2027-01-16"
      sources:
        - url: "https://www.shellcheck.net/wiki/SC2059"
          accessed: "2026-01-16"
          quote: "Don't use variables in the printf format string"
        - url: "https://mywiki.wooledge.org/BashPitfalls#pf22"
          accessed: "2026-01-16"
          quote: "echo's behavior varies between implementations"
    note: |
      echo "$var" may interpret escapes or options.
      printf '%s\n' "$var" is always literal.
    examples:
      bad:
        - 'echo "$user_input"'
        - 'echo -e "tab:\there"'
      good:
        - "printf '%s\\n' \"$user_input\""

  # =========================================================================
  # GUIDANCE - Design patterns (not mechanically checked)
  # =========================================================================

  G1:
    title: Script Template
    severity: GUIDANCE
    mechanical: false
    description: >
      Standard template for production shell scripts with error handling,
      argument parsing, and cleanup.
    note: |
      #!/bin/bash
      # script-name.sh - Brief description
      set -euo pipefail

      readonly SCRIPT_NAME="${0##*/}"
      readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

      log() { printf '%s %s\n' "$(date '+%Y-%m-%d %H:%M:%S')" "$*"; }
      error() { log "ERROR: $*" >&2; }
      die() { error "$*"; exit 1; }

      cleanup() {
          local exit_code=$?
          # cleanup code here
          exit "$exit_code"
      }
      trap cleanup EXIT

      usage() {
          cat <<EOF
      Usage: $SCRIPT_NAME [OPTIONS] <input>

      Options:
          -h, --help      Show this help
          -v, --verbose   Verbose output
      EOF
      }

      main() {
          local verbose=false

          while [[ $# -gt 0 ]]; do
              case "$1" in
                  -h|--help) usage; exit 0 ;;
                  -v|--verbose) verbose=true; shift ;;
                  -*) die "Unknown option: $1" ;;
                  *) break ;;
              esac
          done

          [[ $# -ge 1 ]] || { usage; exit 1; }
          local input="$1"

          [[ -f "$input" ]] || die "File not found: $input"

          $verbose && log "Processing $input"
          process_file "$input"
      }

      main "$@"

  G2:
    title: Safe File Operations
    severity: GUIDANCE
    mechanical: false
    description: >
      Patterns for safe temporary files, directory changes, and file reading.
    note: |
      # Safe temporary files
      tmp_file=$(mktemp) || die "Failed to create temp file"
      trap 'rm -f "$tmp_file"' EXIT

      # Safe directory change
      pushd "$target_dir" > /dev/null || die "Cannot cd to $target_dir"
      # ... do work
      popd > /dev/null

      # Safe file reading
      while IFS= read -r line; do
          process_line "$line"
      done < "$input_file"

      # Safe find iteration
      while IFS= read -r -d '' file; do
          process_file "$file"
      done < <(find "$dir" -type f -name "*.txt" -print0)

  G3:
    title: Colored Output
    severity: GUIDANCE
    mechanical: false
    description: >
      Pattern for terminal-aware colored output that degrades
      gracefully when not connected to a terminal.
    note: |
      if [[ -t 1 ]]; then
          readonly RED=$'\033[31m'
          readonly GREEN=$'\033[32m'
          readonly YELLOW=$'\033[33m'
          readonly RESET=$'\033[0m'
      else
          readonly RED='' GREEN='' YELLOW='' RESET=''
      fi

      success() { printf '%s✓ %s%s\n' "$GREEN" "$*" "$RESET"; }
      warning() { printf '%s⚠ %s%s\n' "$YELLOW" "$*" "$RESET"; }
      fail() { printf '%s✗ %s%s\n' "$RED" "$*" "$RESET"; }

  G4:
    title: ShellCheck Codes Reference
    severity: GUIDANCE
    mechanical: false
    description: >
      Common ShellCheck error codes and their fixes.
    note: |
      Run: shellcheck script.sh

      Common codes:
      | Code   | Issue                          | Fix                    |
      |--------|--------------------------------|------------------------|
      | SC2086 | Unquoted variable              | Quote it: "$var"       |
      | SC2046 | Unquoted command substitution  | "$(cmd)"               |
      | SC2006 | Backticks                      | Use $()                |
      | SC2012 | Parsing ls                     | Use globs or find      |
      | SC2155 | Declare and assign separately  | local var; var=$(cmd)  |
      | SC2164 | cd without error check         | cd dir || exit 1       |

# ===========================================================================
# INFO CHECKS - Statistics for reporting (not pass/fail)
# ===========================================================================

info:
  functions:
    pattern: '^[a-zA-Z_]+\(\)'
    flags: -cE
    label: "Functions"
    aggregate: sum

  readonly_usage:
    pattern: 'readonly '
    flags: -c
    label: "Readonly"
    aggregate: sum

  local_usage:
    pattern: 'local '
    flags: -c
    label: "Local"
    aggregate: sum

  traps:
    pattern: 'trap '
    flags: -c
    label: "Traps"
    aggregate: sum

# ===========================================================================
# ANTI-PATTERNS - Quick reference table (documentation only)
# ===========================================================================

anti_patterns:
  - pattern: "$var unquoted"
    description: "Word splitting, globs"
    fix: '"$var"'

  - pattern: "[ ] test"
    description: "Word splitting, limited"
    fix: "[[ ]]"

  - pattern: "Backticks"
    description: "Can't nest, hard to read"
    fix: "$()"

  - pattern: "cd dir alone"
    description: "Continues if fails"
    fix: "cd dir || exit 1"

  - pattern: "for f in $(ls)"
    description: "Breaks on spaces"
    fix: "for f in *"

  - pattern: "cat f | grep"
    description: "Useless cat"
    fix: "grep pattern f"

  - pattern: "function f {"
    description: "Not POSIX"
    fix: "f() {"

  - pattern: "Global in functions"
    description: "Side effects"
    fix: "local"

  - pattern: "No set -e"
    description: "Ignores errors"
    fix: "set -euo pipefail"

  - pattern: "Predictable /tmp"
    description: "Race condition"
    fix: "mktemp"

  - pattern: "curl | bash"
    description: "Remote code execution"
    fix: "Download, inspect, run"

# ===========================================================================
# SOURCES
# ===========================================================================

sources:
  - title: "Google Shell Style Guide"
    url: "https://google.github.io/styleguide/shellguide.html"

  - title: "ShellCheck Wiki"
    url: "https://www.shellcheck.net/wiki/"

  - title: "Bash Pitfalls"
    url: "https://mywiki.wooledge.org/BashPitfalls"
