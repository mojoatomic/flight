#!/bin/bash
# docker.validate.sh - Dockerfile and container image best practices
# Generated by flight-domain-compile from docker.flight
set -euo pipefail

# Script location for sourcing helpers
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Default: common file patterns
DEFAULT_PATTERNS="**/Dockerfile **/Dockerfile.* **/*.dockerfile"
PASS=0
FAIL=0
WARN=0

red() { printf '\033[31m%s\033[0m\n' "$1"; }
green() { printf '\033[32m%s\033[0m\n' "$1"; }
yellow() { printf '\033[33m%s\033[0m\n' "$1"; }

check() {
    local name="$1"
    shift
    local result
    result=$("$@" 2>/dev/null) || true
    if [[ -z "$result" ]]; then
        green "✅ $name"
        ((PASS++)) || true
    else
        red "❌ $name"
        printf '%s\n' "$result" | head -10 | sed 's/^/   /'
        ((FAIL++)) || true
    fi
}

warn() {
    local name="$1"
    shift
    local result
    result=$("$@" 2>/dev/null) || true
    if [[ -z "$result" ]]; then
        green "✅ $name"
        ((PASS++)) || true
    else
        yellow "⚠️  $name"
        printf '%s\n' "$result" | head -5 | sed 's/^/   /'
        ((WARN++)) || true
    fi
}

printf '%s\n' "═══════════════════════════════════════════"
printf '%s\n' "  DOCKER Domain Validation"
printf '%s\n' "═══════════════════════════════════════════"
printf '\n'

# Source exclusions helper if available
if [[ -f "$SCRIPT_DIR/../exclusions.sh" ]]; then
    source "$SCRIPT_DIR/../exclusions.sh"
    FLIGHT_HAS_EXCLUSIONS=true
else
    FLIGHT_HAS_EXCLUSIONS=false
fi

# Handle arguments or use defaults
if [[ $# -gt 0 ]]; then
    FILES=("$@")
elif [[ "$FLIGHT_HAS_EXCLUSIONS" == true ]]; then
    # Use exclusions-aware file discovery
    mapfile -t FILES < <(flight_get_files "Dockerfile" "Dockerfile.*" "*.dockerfile")
else
    # Fallback: glob expansion without exclusions
    shopt -s nullglob globstar
    FILES=($DEFAULT_PATTERNS)
    shopt -u nullglob globstar
fi

if [[ ${#FILES[@]} -eq 0 ]]; then
    yellow "No files found matching default patterns"
    printf '%s\n' "  Patterns: **/Dockerfile **/Dockerfile.* **/*.dockerfile..."
    printf '\n'
    green "  RESULT: SKIP (no files)"
    exit 0
fi

printf 'Files: %d\n\n' "${#FILES[@]}"

printf '\n%s\n' "## NEVER Rules"

# N1: Running as Root User
check "N1: Running as Root User" \
    bash -c 'for f in "$@"; do
  if ! grep -qE "^USER\s+" "$f" 2>/dev/null; then
    echo "$f: no USER directive found (container runs as root)"
  elif grep -qE "^USER\s+(root|0)\s*$" "$f" 2>/dev/null; then
    grep -HnE "^USER\s+(root|0)\s*$" "$f"
  fi
done | grep -v "flight:ok"' _ "${FILES[@]}"

# N2: Secrets in Build Args or Environment
check "N2: Secrets in Build Args or Environment" \
    bash -c 'grep -Ein "(ARG|ENV)\\s+\\w*(PASSWORD|SECRET|API_KEY|PRIVATE_KEY|TOKEN|CREDENTIAL|AUTH)\\w*\\s*=" "$@" | grep -v "flight:ok"' _ "${FILES[@]}"

# N3: ADD for Remote URLs
check "N3: ADD for Remote URLs" \
    bash -c 'grep -Ein "^ADD\\s+https?://" "$@" | grep -v "flight:ok"' _ "${FILES[@]}"

# N4: Privileged Operations in Dockerfile
check "N4: Privileged Operations in Dockerfile" \
    bash -c 'grep -Ein "--privileged|--cap-add|SYS_ADMIN|NET_ADMIN|ALL" "$@" | grep -v "flight:ok"' _ "${FILES[@]}"

# N5: Hardcoded Passwords or Keys
check "N5: Hardcoded Passwords or Keys" \
    bash -c 'grep -Ein "(password|passwd|secret|api_key|apikey|private_key|token)\\s*[=:]\\s*[\"\\047][^\"\\047]+[\"\\047]" "$@" | grep -v "flight:ok"' _ "${FILES[@]}"

printf '\n%s\n' "## MUST Rules"

# M1: Use Absolute WORKDIR
check "M1: Use Absolute WORKDIR" \
    bash -c 'grep -En "^WORKDIR\\s+[^/]" "$@" | grep -v "flight:ok"' _ "${FILES[@]}"

# M2: Pin Base Image Versions
check "M2: Pin Base Image Versions" \
    bash -c 'for f in "$@"; do
  grep -HnE "^FROM\s+[^:@\s]+\s*$|^FROM\s+[^@\s]+:latest(\s|$)" "$f" 2>/dev/null | \
    grep -v "flight:ok"
done' _ "${FILES[@]}"

# M3: Use COPY Instead of ADD for Local Files
check "M3: Use COPY Instead of ADD for Local Files" \
    bash -c 'for f in "$@"; do
  grep -HnE "^ADD\s+[^h][^\s]+\s+" "$f" 2>/dev/null | \
    grep -vE "\.(tar|tar\.gz|tgz|tar\.bz2|tar\.xz)\s" | \
    grep -v "flight:ok"
done' _ "${FILES[@]}"

# M4: MAINTAINER is Deprecated
check "M4: MAINTAINER is Deprecated" \
    bash -c 'grep -Ein "^MAINTAINER\\s+" "$@" | grep -v "flight:ok"' _ "${FILES[@]}"

# M5: Use JSON Notation for CMD and ENTRYPOINT
check "M5: Use JSON Notation for CMD and ENTRYPOINT" \
    bash -c 'for f in "$@"; do
  grep -HnE "^(CMD|ENTRYPOINT)\s+[^\[]" "$f" 2>/dev/null | \
    grep -v "flight:ok"
done' _ "${FILES[@]}"

# M6: Set SHELL Pipefail Before RUN with Pipes
check "M6: Set SHELL Pipefail Before RUN with Pipes" \
    bash -c 'for f in "$@"; do
  if grep -qE "^RUN\s+.*\|" "$f" 2>/dev/null; then
    if ! grep -qE "^SHELL\s+.*pipefail" "$f" 2>/dev/null; then
      echo "$f: RUN commands use pipes but SHELL pipefail not set"
    fi
  fi
done | grep -v "flight:ok"' _ "${FILES[@]}"

# M7: Invalid EXPOSE Port
check "M7: Invalid EXPOSE Port" \
    bash -c 'for f in "$@"; do
  grep -HnE "^EXPOSE\s+" "$f" 2>/dev/null | while read -r line; do
    linenum=$(echo "$line" | cut -d: -f2)
    ports=$(echo "$line" | sed '"'"'s/.*EXPOSE\s*//'"'"' | grep -oE '"'"'[0-9]+'"'"')
    for port in $ports; do
      if [ "$port" -lt 1 ] || [ "$port" -gt 65535 ]; then
        echo "$line"
      fi
    done
  done
done | grep -v "flight:ok"' _ "${FILES[@]}"

printf '\n%s\n' "## SHOULD Rules"

# S1: Pin Package Versions in apt-get
warn "S1: Pin Package Versions in apt-get" \
    bash -c 'for f in "$@"; do
  grep -HnE "apt-get\s+install.*\s[a-z][a-z0-9+-]+(\s|$)" "$f" 2>/dev/null | \
    grep -vE "=[0-9]|flight:ok"
done' _ "${FILES[@]}"

# S2: Clean Package Cache in Same Layer
warn "S2: Clean Package Cache in Same Layer" \
    bash -c 'for f in "$@"; do
  grep -HnE "^RUN\s+.*apt-get\s+install" "$f" 2>/dev/null | \
    grep -vE "rm\s+-rf\s+/var/lib/apt|flight:ok"
done' _ "${FILES[@]}"

# S3: Use Multi-Stage Builds
warn "S3: Use Multi-Stage Builds" \
    bash -c 'for f in "$@"; do
  if grep -qE "gcc|make|npm\s+install|pip\s+install|go\s+build|cargo\s+build" "$f" 2>/dev/null; then
    from_count=$(grep -cE "^FROM\s+" "$f" 2>/dev/null || echo 0)
    if [ "$from_count" -lt 2 ]; then
      echo "$f: build tools detected but no multi-stage build (single FROM)"
    fi
  fi
done | grep -v "flight:ok"' _ "${FILES[@]}"

# S4: Order Layers for Caching
warn "S4: Order Layers for Caching" \
    bash -c 'for f in "$@"; do
  copy_all_line=$(grep -nE "^COPY\s+\.\s+" "$f" 2>/dev/null | head -1 | cut -d: -f1)
  copy_pkg_line=$(grep -nE "^COPY\s+package" "$f" 2>/dev/null | head -1 | cut -d: -f1)
  if [ -n "$copy_all_line" ] && [ -n "$copy_pkg_line" ]; then
    if [ "$copy_all_line" -lt "$copy_pkg_line" ]; then
      echo "$f:$copy_all_line: COPY . before COPY package* (poor cache efficiency)"
    fi
  fi
done | grep -v "flight:ok"' _ "${FILES[@]}"

# S5: Use .dockerignore
warn "S5: Use .dockerignore" \
    bash -c 'for f in "$@"; do
  dir=$(dirname "$f")
  if [ ! -f "$dir/.dockerignore" ]; then
    echo "$f: no .dockerignore found in $dir"
  fi
done | grep -v "flight:ok"' _ "${FILES[@]}"

# S6: Define HEALTHCHECK
warn "S6: Define HEALTHCHECK" \
    bash -c 'for f in "$@"; do
  if ! grep -qE "^HEALTHCHECK\s+" "$f" 2>/dev/null; then
    if grep -qE "^(CMD|ENTRYPOINT)\s+" "$f" 2>/dev/null; then
      echo "$f: no HEALTHCHECK defined for service image"
    fi
  fi
done | grep -v "flight:ok"' _ "${FILES[@]}"

# S7: Combine RUN Commands
warn "S7: Combine RUN Commands" \
    bash -c 'for f in "$@"; do
  run_count=$(grep -cE "^RUN\s+" "$f" 2>/dev/null || echo 0)
  if [ "$run_count" -gt 10 ]; then
    echo "$f: $run_count RUN commands (consider combining)"
  fi
done | grep -v "flight:ok"' _ "${FILES[@]}"

# S8: Use Specific COPY Targets
warn "S8: Use Specific COPY Targets" \
    bash -c 'for f in "$@"; do
  grep -HnE "^COPY\s+\.\s+" "$f" 2>/dev/null | \
    grep -v "flight:ok"
done' _ "${FILES[@]}"

# S9: Avoid apt-get upgrade
warn "S9: Avoid apt-get upgrade" \
    bash -c 'grep -Ein "apt-get\\s+(upgrade|dist-upgrade)" "$@" | grep -v "flight:ok"' _ "${FILES[@]}"

printf '\n%s\n' "## Info"

FROM_COUNT=$( (grep -c "^FROM\s+" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  FROM instructions (stages): %s\n' "$FROM_COUNT"

LAYER_COUNT=$( (grep -c "^(RUN|COPY|ADD)\s+" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  Layer-creating instructions: %s\n' "$LAYER_COUNT"

EXPOSE_COUNT=$( (grep -c "^EXPOSE\s+" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  EXPOSE directives: %s\n' "$EXPOSE_COUNT"

ENV_COUNT=$( (grep -c "^ENV\s+" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  ENV directives: %s\n' "$ENV_COUNT"

ARG_COUNT=$( (grep -c "^ARG\s+" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  ARG directives: %s\n' "$ARG_COUNT"

printf '\n%s\n' "═══════════════════════════════════════════"
printf '  PASS: %d  FAIL: %d  WARN: %d\n' "$PASS" "$FAIL" "$WARN"
if [[ $FAIL -eq 0 ]]; then
    green "  RESULT: PASS"
else
    red "  RESULT: FAIL"
fi
printf '%s\n' "═══════════════════════════════════════════"

exit "$FAIL"
