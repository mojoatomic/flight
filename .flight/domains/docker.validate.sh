#!/usr/bin/env bash
# docker.validate.sh - Dockerfile and container image best practices
# Generated by flight-domain-compile from docker.flight
set -euo pipefail

# Script location for sourcing helpers
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Default: common file patterns
DEFAULT_PATTERNS="**/Dockerfile **/Dockerfile.* **/*.dockerfile"
PASS=0
FAIL=0
WARN=0

red() { printf '\033[31m%s\033[0m\n' "$1"; }
green() { printf '\033[32m%s\033[0m\n' "$1"; }
yellow() { printf '\033[33m%s\033[0m\n' "$1"; }

check() {
    local name="$1"
    shift
    local result
    result=$("$@" 2>/dev/null) || true
    if [[ -z "$result" ]]; then
        green "✅ $name"
        ((PASS++)) || true
    else
        red "❌ $name"
        # Use subshell to prevent SIGPIPE from killing script with pipefail
        (printf '%s\n' "$result" | head -10 | sed 's/^/   /') || true
        ((FAIL++)) || true
    fi
}

warn() {
    local name="$1"
    shift
    local result
    result=$("$@" 2>/dev/null) || true
    if [[ -z "$result" ]]; then
        green "✅ $name"
        ((PASS++)) || true
    else
        yellow "⚠️  $name"
        # Use subshell to prevent SIGPIPE from killing script with pipefail
        (printf '%s\n' "$result" | head -5 | sed 's/^/   /') || true
        ((WARN++)) || true
    fi
}

printf '%s\n' "═══════════════════════════════════════════"
printf '%s\n' "  DOCKER Domain Validation"
printf '%s\n' "═══════════════════════════════════════════"
printf '\n'

# Source exclusions helper if available
if [[ -f "$SCRIPT_DIR/../exclusions.sh" ]]; then
    source "$SCRIPT_DIR/../exclusions.sh"
    FLIGHT_HAS_EXCLUSIONS=true
else
    FLIGHT_HAS_EXCLUSIONS=false
fi

# Handle arguments or use defaults
if [[ $# -gt 0 ]]; then
    FILES=("$@")
elif [[ "$FLIGHT_HAS_EXCLUSIONS" == true ]]; then
    # Use exclusions-aware file discovery
    mapfile -t FILES < <(flight_get_files "Dockerfile" "Dockerfile.*" "*.dockerfile")
else
    # Fallback: use find (works on bash 3.2+, no globstar needed)
    # Redirect stdin from /dev/null to prevent hanging in piped contexts (curl | bash)
    mapfile -t FILES < <(find . -type f \( -name "Dockerfile" -o -name "Dockerfile.*" -o -name "*.dockerfile" \) -not -path "*/node_modules/*" -not -path "*/.git/*" -not -path "*/dist/*" -not -path "*/build/*" < /dev/null 2>/dev/null | sort)
fi

if [[ ${#FILES[@]} -eq 0 ]]; then
    yellow "No files found matching default patterns"
    printf '%s\n' "  Patterns: **/Dockerfile **/Dockerfile.* **/*.dockerfile..."
    printf '\n'
    green "  RESULT: SKIP (no files)"
    exit 0
fi

printf 'Files: %d\n\n' "${#FILES[@]}"

printf '\n%s\n' "## NEVER Rules"

# N1: Running as Root User
check "N1: Running as Root User" \
    bash -c '
for f in "$@"; do
    if ! grep -qE "^USER\\s+(?!root|0\\s*\$)" "$f" 2>/dev/null; then
        echo "$f: no non-root USER directive found (container runs as root)"
    fi
done
' _ "${FILES[@]}"

# N2: Secrets in Build Args or Environment
check "N2: Secrets in Build Args or Environment" \
    grep -Ein "(ARG|ENV)\\s+\\w*(PASSWORD|SECRET|API_KEY|PRIVATE_KEY|TOKEN|CREDENTIAL|AUTH)\\w*\\s*=" "${FILES[@]}"

# N3: ADD for Remote URLs
check "N3: ADD for Remote URLs" \
    grep -Ein "^ADD\\s+https?://" "${FILES[@]}"

# N4: Privileged Operations in Dockerfile
check "N4: Privileged Operations in Dockerfile" \
    grep -Ein "--privileged|--cap-add|SYS_ADMIN|NET_ADMIN|ALL" "${FILES[@]}"

# N5: Hardcoded Passwords or Keys
check "N5: Hardcoded Passwords or Keys" \
    grep -Ein "(password|passwd|secret|api_key|apikey|private_key|token)\\s*[=:]\\s*[\"\\047][^\"\\047]+[\"\\047]" "${FILES[@]}"

printf '\n%s\n' "## MUST Rules"

# M1: Use Absolute WORKDIR
check "M1: Use Absolute WORKDIR" \
    grep -En "^WORKDIR\\s+[^/]" "${FILES[@]}"

# M2: Pin Base Image Versions
check "M2: Pin Base Image Versions" \
    grep -En "^FROM\\s+[^:@\\s]+\\s*\$|^FROM\\s+[^@\\s]+:latest(\\s|\$)" "${FILES[@]}"

# M3: Use COPY Instead of ADD for Local Files
check "M3: Use COPY Instead of ADD for Local Files" \
    bash -c '(grep -En "^ADD\\s+[^h][^\\s]+\\s+" "$@" | grep -v "\\.(tar|tar\\.gz|tgz|tar\\.bz2|tar\\.xz)\\s") || true' _ "${FILES[@]}"

# M4: MAINTAINER is Deprecated
check "M4: MAINTAINER is Deprecated" \
    grep -Ein "^MAINTAINER\\s+" "${FILES[@]}"

# M5: Use JSON Notation for CMD and ENTRYPOINT
check "M5: Use JSON Notation for CMD and ENTRYPOINT" \
    grep -En "^(CMD|ENTRYPOINT)\\s+[^\\[]" "${FILES[@]}"

# M6: Set SHELL Pipefail Before RUN with Pipes
check "M6: Set SHELL Pipefail Before RUN with Pipes" \
    bash -c '
for f in "$@"; do
    trigger_lines=$(grep -nE "^RUN\\s+.*\\|" "$f" 2>/dev/null)
    if [[ -n "$trigger_lines" ]]; then
        if ! grep -qE "^SHELL\\s+.*pipefail" "$f" 2>/dev/null; then
            echo "$trigger_lines" | while IFS= read -r line; do
                linenum="${line%%:*}"
                echo "$f:$linenum: RUN commands use pipes but SHELL pipefail not set"
            done
        fi
    fi
done
' _ "${FILES[@]}"

printf '\n%s\n' "## SHOULD Rules"

# S1: Pin Package Versions in apt-get
warn "S1: Pin Package Versions in apt-get" \
    bash -c '(grep -En "apt-get\\s+install.*\\s[a-z][a-z0-9+-]+(\\s|\$)" "$@" | grep -v "=[0-9]") || true' _ "${FILES[@]}"

# S2: Clean Package Cache in Same Layer
warn "S2: Clean Package Cache in Same Layer" \
    bash -c '(grep -En "^RUN\\s+.*apt-get\\s+install" "$@" | grep -v "rm\\s+-rf\\s+/var/lib/apt") || true' _ "${FILES[@]}"

# S6: Define HEALTHCHECK
warn "S6: Define HEALTHCHECK" \
    bash -c '
for f in "$@"; do
    trigger_lines=$(grep -nE "^(CMD|ENTRYPOINT)\\s+" "$f" 2>/dev/null)
    if [[ -n "$trigger_lines" ]]; then
        if ! grep -qE "^HEALTHCHECK\\s+" "$f" 2>/dev/null; then
            echo "$trigger_lines" | while IFS= read -r line; do
                linenum="${line%%:*}"
                echo "$f:$linenum: no HEALTHCHECK defined for service image"
            done
        fi
    fi
done
' _ "${FILES[@]}"

# S8: Use Specific COPY Targets
warn "S8: Use Specific COPY Targets" \
    grep -En "^COPY\\s+\\.\\s+" "${FILES[@]}"

# S9: Avoid apt-get upgrade
warn "S9: Avoid apt-get upgrade" \
    grep -Ein "apt-get\\s+(upgrade|dist-upgrade)" "${FILES[@]}"

printf '\n%s\n' "## Info"

FROM_COUNT=$( (grep -c "^FROM\s+" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  FROM instructions (stages): %s\n' "$FROM_COUNT"

LAYER_COUNT=$( (grep -c "^(RUN|COPY|ADD)\s+" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  Layer-creating instructions: %s\n' "$LAYER_COUNT"

EXPOSE_COUNT=$( (grep -c "^EXPOSE\s+" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  EXPOSE directives: %s\n' "$EXPOSE_COUNT"

ENV_COUNT=$( (grep -c "^ENV\s+" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  ENV directives: %s\n' "$ENV_COUNT"

ARG_COUNT=$( (grep -c "^ARG\s+" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  ARG directives: %s\n' "$ARG_COUNT"

printf '\n%s\n' "═══════════════════════════════════════════"
printf '  PASS: %d  FAIL: %d  WARN: %d\n' "$PASS" "$FAIL" "$WARN"
if [[ $FAIL -eq 0 ]]; then
    green "  RESULT: PASS"
else
    red "  RESULT: FAIL"
fi
printf '%s\n' "═══════════════════════════════════════════"

exit "$FAIL"
