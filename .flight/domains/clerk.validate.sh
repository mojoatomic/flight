#!/bin/bash
# clerk.validate.sh - Clerk authentication and multi-tenant organization patterns for SaaS applications using TypeScript/Next
# Generated by flight-domain-compile from clerk.flight
set -euo pipefail

# Default: common file patterns
DEFAULT_PATTERNS="**/*.ts **/*.tsx"
PASS=0
FAIL=0
WARN=0

red() { printf '\033[31m%s\033[0m\n' "$1"; }
green() { printf '\033[32m%s\033[0m\n' "$1"; }
yellow() { printf '\033[33m%s\033[0m\n' "$1"; }

check() {
    local name="$1"
    shift
    local result
    result=$("$@" 2>/dev/null) || true
    if [[ -z "$result" ]]; then
        green "✅ $name"
        ((PASS++)) || true
    else
        red "❌ $name"
        printf '%s\n' "$result" | head -10 | sed 's/^/   /'
        ((FAIL++)) || true
    fi
}

warn() {
    local name="$1"
    shift
    local result
    result=$("$@" 2>/dev/null) || true
    if [[ -z "$result" ]]; then
        green "✅ $name"
        ((PASS++)) || true
    else
        yellow "⚠️  $name"
        printf '%s\n' "$result" | head -5 | sed 's/^/   /'
        ((WARN++)) || true
    fi
}

printf '%s\n' "═══════════════════════════════════════════"
printf '%s\n' "  CLERK Domain Validation"
printf '%s\n' "═══════════════════════════════════════════"
printf '\n'

# Handle arguments or use defaults
if [[ $# -gt 0 ]]; then
    FILES=("$@")
else
    shopt -s nullglob globstar
    FILES=($DEFAULT_PATTERNS)
    shopt -u nullglob globstar
fi

if [[ ${#FILES[@]} -eq 0 ]]; then
    yellow "No files found matching default patterns"
    printf '%s\n' "  Patterns: **/*.ts **/*.tsx..."
    printf '\n'
    green "  RESULT: SKIP (no files)"
    exit 0
fi

printf 'Files: %d\n\n' "${#FILES[@]}"

printf '\n%s\n' "## NEVER Rules"

# N1: Secret Key in Client Code
check "N1: Secret Key in Client Code" \
    bash -c 'for f in "$@"; do
  # Check for secret key in any client-accessible file
  # Skip files that are clearly server-only (api/, server/, actions/)
  if [[ "$f" != *"/api/"* ]] && [[ "$f" != *"/server/"* ]] && [[ "$f" != *".server."* ]] && [[ "$f" != *"/actions/"* ]] && [[ "$f" != *"middleware"* ]]; then
    grep -HnE '"'"'CLERK_SECRET_KEY|secretKey.*clerk'"'"' "$f" 2>/dev/null | grep -v '"'"'flight:ok'"'"'
  fi
done' _ "${FILES[@]}"

# N2: Deprecated authMiddleware
check "N2: Deprecated authMiddleware" \
    grep -En "authMiddleware|from ['\"]@clerk/nextjs['\"].*authMiddleware" "${FILES[@]}"

# N3: auth() in Client Components
check "N3: auth() in Client Components" \
    bash -c 'for f in "$@"; do
  # Check if file is a client component
  if grep -q "'"'"'use client'"'"'" "$f" 2>/dev/null; then
    # Flag if importing auth from server
    if grep -qE "from ['"'"'\"]@clerk/nextjs/server['"'"'\"]" "$f" 2>/dev/null; then
      grep -Hn "from ['"'"'\"]@clerk/nextjs/server['"'"'\"]" "$f" | grep -v '"'"'flight:ok'"'"'
    fi
  fi
done' _ "${FILES[@]}"

# N4: Synchronous auth() Call in Next.js 15+
check "N4: Synchronous auth() Call in Next.js 15+" \
    bash -c 'for f in "$@"; do
  # Find auth() calls that aren'"'"'t awaited or in async context
  # Look for patterns like: const { userId } = auth() without await
  grep -HnE "const\s*\{[^}]*\}\s*=\s*auth\(\)" "$f" 2>/dev/null | \
    grep -v "await" | grep -v '"'"'flight:ok'"'"'
done' _ "${FILES[@]}"

# N5: Hardcoded Clerk Keys
check "N5: Hardcoded Clerk Keys" \
    grep -En "pk_test_[a-zA-Z0-9]+|pk_live_[a-zA-Z0-9]+|sk_test_[a-zA-Z0-9]+|sk_live_[a-zA-Z0-9]+" "${FILES[@]}"

# N6: Missing Webhook Signature Verification
check "N6: Missing Webhook Signature Verification" \
    bash -c 'for f in "$@"; do
  # Check webhook handler files
  if [[ "$f" == *"webhook"* ]] && [[ "$f" == *"/api/"* ]]; then
    # Must have svix verification
    if ! grep -qE "Webhook|verifyWebhook|svix-id|svix-timestamp|svix-signature" "$f" 2>/dev/null; then
      if ! grep -q "flight:ok" "$f" 2>/dev/null; then
        echo "$f: webhook handler without signature verification"
      fi
    fi
  fi
done' _ "${FILES[@]}"

# N7: Using userId When orgId is Required
check "N7: Using userId When orgId is Required" \
    bash -c 'for f in "$@"; do
  # Skip test files
  if [[ "$f" == *".test."* ]] || [[ "$f" == *".spec."* ]]; then
    continue
  fi
  # In server files that query data
  if [[ "$f" == *"/api/"* ]] || [[ "$f" == *"/actions/"* ]] || [[ "$f" == *".server."* ]]; then
    # Flag if using userId for data filtering without orgId
    # Covers Prisma (where: { userId }) and Drizzle (eq(*.userId, ...))
    if grep -qE "where.*userId|userId.*=|eq\(.*userId" "$f" 2>/dev/null; then
      if ! grep -qE "orgId|organizationId" "$f" 2>/dev/null; then
        grep -Hn "userId" "$f" 2>/dev/null | head -3 | grep -v '"'"'flight:ok'"'"'
      fi
    fi
  fi
done' _ "${FILES[@]}"

# N8: Missing Organization Context in Protected Routes
check "N8: Missing Organization Context in Protected Routes" \
    bash -c 'for f in "$@"; do
  # Check API routes and server actions
  if [[ "$f" == *"/api/"* ]] || [[ "$f" == *"/actions/"* ]]; then
    # If file uses auth() but doesn'"'"'t check orgId
    if grep -q "await auth()" "$f" 2>/dev/null; then
      if grep -qE "userId\s*\}" "$f" 2>/dev/null; then
        if ! grep -qE "orgId|organizationId|!.*org" "$f" 2>/dev/null; then
          if ! grep -q "flight:ok" "$f" 2>/dev/null; then
            echo "$f: auth check without orgId verification"
          fi
        fi
      fi
    fi
  fi
done' _ "${FILES[@]}"

# N9: Missing Null Checks for Auth Values
check "N9: Missing Null Checks for Auth Values" \
    bash -c 'for f in "$@"; do
  # Check files using auth()
  if grep -q "await auth()" "$f" 2>/dev/null; then
    # Find destructured values being used directly without checks
    if grep -qE "\{ userId \}|\{ orgId \}" "$f" 2>/dev/null; then
      # Check if there'"'"'s a null check before usage
      if grep -qE "userId\!|orgId\!" "$f" 2>/dev/null; then
        if ! grep -qE "if.*!.*userId|if.*!.*orgId|userId\s*\?\?" "$f" 2>/dev/null; then
          grep -Hn "userId\!|orgId\!" "$f" | grep -v '"'"'flight:ok'"'"'
        fi
      fi
    fi
  fi
done' _ "${FILES[@]}"

printf '\n%s\n' "## MUST Rules"

# M1: ClerkProvider at Root
check "M1: ClerkProvider at Root" \
    bash -c '# Check if any layout file has ClerkProvider
for f in "$@"; do
  if [[ "$f" == *"layout"* ]]; then
    if grep -q "ClerkProvider" "$f" 2>/dev/null; then
      exit 0  # Found it, pass
    fi
  fi
done
# If we get here, no layout has ClerkProvider
echo "No ClerkProvider found in layout files"' _ "${FILES[@]}"

# M2: Middleware Matcher Configuration
check "M2: Middleware Matcher Configuration" \
    bash -c 'for f in "$@"; do
  if [[ "$f" == *"middleware"* ]]; then
    if grep -q "clerkMiddleware" "$f" 2>/dev/null; then
      if ! grep -q "matcher" "$f" 2>/dev/null; then
        echo "$f: clerkMiddleware without matcher config"
      fi
    fi
  fi
done' _ "${FILES[@]}"

# M3: Use createRouteMatcher for Route Protection
check "M3: Use createRouteMatcher for Route Protection" \
    bash -c 'for f in "$@"; do
  if [[ "$f" == *"middleware"* ]]; then
    if grep -q "clerkMiddleware" "$f" 2>/dev/null; then
      # Check if using auth.protect() without createRouteMatcher
      if grep -q "auth\.protect\|auth()\.protect" "$f" 2>/dev/null; then
        if ! grep -q "createRouteMatcher" "$f" 2>/dev/null; then
          echo "$f: using auth.protect without createRouteMatcher"
        fi
      fi
    fi
  fi
done' _ "${FILES[@]}"

# M4: Validate Organization Slug in Routes
check "M4: Validate Organization Slug in Routes" \
    bash -c 'for f in "$@"; do
  # Check route files with orgSlug parameter
  if [[ "$f" == *"[orgSlug]"* ]] || [[ "$f" == *"[slug]"* ]]; then
    # Should have validation against auth orgSlug
    if ! grep -qE "orgSlug.*===|slug.*===|validateSlug|params\.orgSlug" "$f" 2>/dev/null; then
      if ! grep -q "flight:ok" "$f" 2>/dev/null; then
        echo "$f: org slug route without slug validation"
      fi
    fi
  fi
done' _ "${FILES[@]}"

# M5: Include orgId in Database Queries
check "M5: Include orgId in Database Queries" \
    bash -c 'for f in "$@"; do
  # Check data access files
  if [[ "$f" == *"/api/"* ]] || [[ "$f" == *"/actions/"* ]] || [[ "$f" == *".server."* ]]; then
    # If file has database queries (Prisma or Drizzle)
    if grep -qE "findMany|findFirst|findUnique|select.*from|query\.|\.insert\(|\.update\(|\.delete\(" "$f" 2>/dev/null; then
      # Should have orgId in where clause
      if ! grep -qE "orgId|organization_id|organizationId" "$f" 2>/dev/null; then
        if ! grep -q "flight:ok" "$f" 2>/dev/null; then
          echo "$f: database query without orgId filter"
        fi
      fi
    fi
  fi
done' _ "${FILES[@]}"

# M6: Handle Organization Switching
check "M6: Handle Organization Switching" \
    bash -c 'for f in "$@"; do
  # Check client files using organization hooks
  if grep -q "'"'"'use client'"'"'" "$f" 2>/dev/null; then
    if grep -qE "useOrganization|OrganizationSwitcher" "$f" 2>/dev/null; then
      # Should handle org changes
      if ! grep -qE "onOrganizationSelect|organization\.id.*useEffect|router\.refresh|revalidate" "$f" 2>/dev/null; then
        if ! grep -q "flight:ok" "$f" 2>/dev/null; then
          echo "$f: org component without change handling"
        fi
      fi
    fi
  fi
done' _ "${FILES[@]}"

printf '\n%s\n' "## Info"

CLERK_IMPORTS=$( (grep -oE "from .@clerk" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  Clerk imports: %s\n' "$CLERK_IMPORTS"

AUTH_CALLS=$( (grep -cE "await auth\(\)|useAuth\(\)" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  Auth calls: %s\n' "$AUTH_CALLS"

ORG_HOOKS=$( (grep -cE "useOrganization|useOrganizationList" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  Organization hooks: %s\n' "$ORG_HOOKS"

WEBHOOK_HANDLERS=$( (grep -ciE "webhooks?.*clerk|clerk.*webhooks?" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  Webhook handlers: %s\n' "$WEBHOOK_HANDLERS"

printf '\n%s\n' "═══════════════════════════════════════════"
printf '  PASS: %d  FAIL: %d  WARN: %d\n' "$PASS" "$FAIL" "$WARN"
if [[ $FAIL -eq 0 ]]; then
    green "  RESULT: PASS"
else
    red "  RESULT: FAIL"
fi
printf '%s\n' "═══════════════════════════════════════════"

exit "$FAIL"
