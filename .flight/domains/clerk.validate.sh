#!/usr/bin/env bash
# clerk.validate.sh - Clerk authentication and multi-tenant organization patterns for SaaS applications using TypeScript/Next
# Generated by flight-domain-compile from clerk.flight
set -euo pipefail

# Script location for sourcing helpers
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Default: common file patterns
DEFAULT_PATTERNS="**/*.ts **/*.tsx"
PASS=0
FAIL=0
WARN=0

red() { printf '\033[31m%s\033[0m\n' "$1"; }
green() { printf '\033[32m%s\033[0m\n' "$1"; }
yellow() { printf '\033[33m%s\033[0m\n' "$1"; }

check() {
    local name="$1"
    shift
    local result
    result=$("$@" 2>/dev/null) || true
    if [[ -z "$result" ]]; then
        green "✅ $name"
        ((PASS++)) || true
    else
        red "❌ $name"
        # Use subshell to prevent SIGPIPE from killing script with pipefail
        (printf '%s\n' "$result" | head -10 | sed 's/^/   /') || true
        ((FAIL++)) || true
    fi
}

warn() {
    local name="$1"
    shift
    local result
    result=$("$@" 2>/dev/null) || true
    if [[ -z "$result" ]]; then
        green "✅ $name"
        ((PASS++)) || true
    else
        yellow "⚠️  $name"
        # Use subshell to prevent SIGPIPE from killing script with pipefail
        (printf '%s\n' "$result" | head -5 | sed 's/^/   /') || true
        ((WARN++)) || true
    fi
}

printf '%s\n' "═══════════════════════════════════════════"
printf '%s\n' "  CLERK Domain Validation"
printf '%s\n' "═══════════════════════════════════════════"
printf '\n'

# Source exclusions helper if available
if [[ -f "$SCRIPT_DIR/../exclusions.sh" ]]; then
    source "$SCRIPT_DIR/../exclusions.sh"
    FLIGHT_HAS_EXCLUSIONS=true
else
    FLIGHT_HAS_EXCLUSIONS=false
fi

# Handle arguments or use defaults
if [[ $# -gt 0 ]]; then
    FILES=("$@")
elif [[ "$FLIGHT_HAS_EXCLUSIONS" == true ]]; then
    # Use exclusions-aware file discovery
    mapfile -t FILES < <(flight_get_files "*.ts" "*.tsx")
else
    # Fallback: use find (works on bash 3.2+, no globstar needed)
    # Redirect stdin from /dev/null to prevent hanging in piped contexts (curl | bash)
    mapfile -t FILES < <(find . -type f \( -name "*.ts" -o -name "*.tsx" \) -not -path "*/node_modules/*" -not -path "*/.git/*" -not -path "*/dist/*" -not -path "*/build/*" < /dev/null 2>/dev/null | sort)
fi

if [[ ${#FILES[@]} -eq 0 ]]; then
    yellow "No files found matching default patterns"
    printf '%s\n' "  Patterns: **/*.ts **/*.tsx..."
    printf '\n'
    green "  RESULT: SKIP (no files)"
    exit 0
fi

printf 'Files: %d\n\n' "${#FILES[@]}"

printf '\n%s\n' "## NEVER Rules"

# N1: Secret Key in Client Code
# Path filtering for this rule
FILTERED_FILES=()
for __f in "${FILES[@]}"; do
    if [[ "$__f" == *api/* ]] || [[ "$__f" == *server/* ]] || [[ "$__f" == *.server.* ]] || [[ "$__f" == *actions/* ]] || [[ "$__f" == *middleware* ]]; then continue; fi
    FILTERED_FILES+=("$__f")
done
if [[ ${#FILTERED_FILES[@]} -gt 0 ]]; then
    check "N1: Secret Key in Client Code" \
        grep -En "CLERK_SECRET_KEY|secretKey.*clerk" "${FILTERED_FILES[@]}"
else
    green "✅ N1: Secret Key in Client Code (skipped - no matching files after path filter)"
    ((PASS++)) || true
fi

# N2: Deprecated authMiddleware
check "N2: Deprecated authMiddleware" \
    grep -En "authMiddleware|from ['\"]@clerk/nextjs['\"].*authMiddleware" "${FILES[@]}"

# N4: Synchronous auth() Call in Next.js 15+
check "N4: Synchronous auth() Call in Next.js 15+" \
    bash -c '(grep -En "const\\s*\\{[^}]*\\}\\s*=\\s*auth\\(\\)" "$@" | grep -v "await") || true' _ "${FILES[@]}"

# N5: Hardcoded Clerk Keys
check "N5: Hardcoded Clerk Keys" \
    grep -En "pk_test_[a-zA-Z0-9]+|pk_live_[a-zA-Z0-9]+|sk_test_[a-zA-Z0-9]+|sk_live_[a-zA-Z0-9]+" "${FILES[@]}"

# N6: Missing Webhook Signature Verification
# Path filtering for this rule
FILTERED_FILES=()
for __f in "${FILES[@]}"; do
    if ! ( [[ "$__f" == *api/**webhook*/* ]] || [[ "$__f" == *api/*/webhook* ]] ); then continue; fi
    FILTERED_FILES+=("$__f")
done
if [[ ${#FILTERED_FILES[@]} -gt 0 ]]; then
    check "N6: Missing Webhook Signature Verification" \
        bash -c '
for f in "$@"; do
    if ! grep -qE "Webhook|verifyWebhook|svix-id|svix-timestamp|svix-signature" "$f" 2>/dev/null; then
        echo "$f: webhook handler without signature verification"
    fi
done
' _ "${FILTERED_FILES[@]}"
else
    green "✅ N6: Missing Webhook Signature Verification (skipped - no matching files after path filter)"
    ((PASS++)) || true
fi

printf '\n%s\n' "## MUST Rules"

# M2: Middleware Matcher Configuration
# Path filtering for this rule
FILTERED_FILES=()
for __f in "${FILES[@]}"; do
    if ! ( [[ "$__f" == *middleware.ts ]] || [[ "$__f" == *middleware.js ]] ); then continue; fi
    FILTERED_FILES+=("$__f")
done
if [[ ${#FILTERED_FILES[@]} -gt 0 ]]; then
    check "M2: Middleware Matcher Configuration" \
        bash -c '
for f in "$@"; do
    trigger_lines=$(grep -nE "clerkMiddleware" "$f" 2>/dev/null)
    if [[ -n "$trigger_lines" ]]; then
        if ! grep -qE "matcher" "$f" 2>/dev/null; then
            echo "$trigger_lines" | while IFS= read -r line; do
                linenum="${line%%:*}"
                echo "$f:$linenum: clerkMiddleware without matcher config"
            done
        fi
    fi
done
' _ "${FILTERED_FILES[@]}"
else
    green "✅ M2: Middleware Matcher Configuration (skipped - no matching files after path filter)"
    ((PASS++)) || true
fi

# M3: Use createRouteMatcher for Route Protection
# Path filtering for this rule
FILTERED_FILES=()
for __f in "${FILES[@]}"; do
    if ! ( [[ "$__f" == *middleware.ts ]] || [[ "$__f" == *middleware.js ]] ); then continue; fi
    FILTERED_FILES+=("$__f")
done
if [[ ${#FILTERED_FILES[@]} -gt 0 ]]; then
    check "M3: Use createRouteMatcher for Route Protection" \
        bash -c '
for f in "$@"; do
    trigger_lines=$(grep -nE "auth\\.protect|auth\\(\\)\\.protect" "$f" 2>/dev/null)
    if [[ -n "$trigger_lines" ]]; then
        if ! grep -qE "createRouteMatcher" "$f" 2>/dev/null; then
            echo "$trigger_lines" | while IFS= read -r line; do
                linenum="${line%%:*}"
                echo "$f:$linenum: using auth.protect without createRouteMatcher"
            done
        fi
    fi
done
' _ "${FILTERED_FILES[@]}"
else
    green "✅ M3: Use createRouteMatcher for Route Protection (skipped - no matching files after path filter)"
    ((PASS++)) || true
fi

# M4: Validate Organization Slug in Routes
# Path filtering for this rule
FILTERED_FILES=()
for __f in "${FILES[@]}"; do
    if ! ( [[ "$__f" == *[orgSlug]*/* ]] || [[ "$__f" == *[slug]*/* ]] ); then continue; fi
    FILTERED_FILES+=("$__f")
done
if [[ ${#FILTERED_FILES[@]} -gt 0 ]]; then
    check "M4: Validate Organization Slug in Routes" \
        bash -c '
for f in "$@"; do
    if ! grep -qE "orgSlug.*===|slug.*===|validateSlug|params\\.orgSlug" "$f" 2>/dev/null; then
        echo "$f: org slug route without slug validation"
    fi
done
' _ "${FILTERED_FILES[@]}"
else
    green "✅ M4: Validate Organization Slug in Routes (skipped - no matching files after path filter)"
    ((PASS++)) || true
fi

# M6: Handle Organization Switching
check "M6: Handle Organization Switching" \
    bash -c '
for f in "$@"; do
    trigger_lines=$(grep -nE "OrganizationSwitcher" "$f" 2>/dev/null)
    if [[ -n "$trigger_lines" ]]; then
        if ! grep -qE "afterSelectOrganizationUrl|setActive|router\\.(push|replace|refresh)" "$f" 2>/dev/null; then
            echo "$trigger_lines" | while IFS= read -r line; do
                linenum="${line%%:*}"
                echo "$f:$linenum: OrganizationSwitcher without navigation handling"
            done
        fi
    fi
done
' _ "${FILES[@]}"

printf '\n%s\n' "## Info"

CLERK_IMPORTS=$( (grep -oE "from .@clerk" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  Clerk imports: %s\n' "$CLERK_IMPORTS"

AUTH_CALLS=$( (grep -cE "await auth\(\)|useAuth\(\)" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  Auth calls: %s\n' "$AUTH_CALLS"

ORG_HOOKS=$( (grep -cE "useOrganization|useOrganizationList" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  Organization hooks: %s\n' "$ORG_HOOKS"

WEBHOOK_HANDLERS=$( (grep -ciE "webhooks?.*clerk|clerk.*webhooks?" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  Webhook handlers: %s\n' "$WEBHOOK_HANDLERS"

printf '\n%s\n' "═══════════════════════════════════════════"
printf '  PASS: %d  FAIL: %d  WARN: %d\n' "$PASS" "$FAIL" "$WARN"
if [[ $FAIL -eq 0 ]]; then
    green "  RESULT: PASS"
else
    red "  RESULT: FAIL"
fi
printf '%s\n' "═══════════════════════════════════════════"

exit "$FAIL"
