# react.flight - Production React patterns for components and hooks
# Source: Migrated from react.md and react.validate.sh

domain: react
version: 1.1.0
schema_version: 2
description: >
  Production React patterns for functional components, hooks, and state management.
  Prevents common performance issues, broken reconciliation, and Rules of Hooks violations.

file_patterns:
  - "**/*.jsx"
  - "**/*.tsx"

exclude_patterns:
  - "**/node_modules/**"
  - "**/dist/**"
  - "**/build/**"
  - "**/.next/**"
  - "**/.git/**"

provenance:
  last_full_audit: "2026-01-20"
  audited_by: "flight-research"
  next_audit_due: "2026-07-20"

  sources_consulted:
    - url: "https://react.dev/reference/rules/rules-of-hooks"
      accessed: "2026-01-20"
      note: "Official Rules of Hooks documentation"
    - url: "https://react.dev/learn/thinking-in-react"
      accessed: "2026-01-20"
      note: "Thinking in React patterns"
    - url: "https://react.dev/reference/react/useCallback"
      accessed: "2026-01-20"
      note: "useCallback hook documentation"
    - url: "https://react.dev/reference/react/useMemo"
      accessed: "2026-01-20"
      note: "useMemo hook documentation"
    - url: "https://react.dev/learn/rendering-lists#keeping-list-items-in-order-with-key"
      accessed: "2026-01-20"
      note: "Keys and list rendering"

  coverage:
    apis_covered:
      - "Hooks (useState, useEffect, useMemo, useCallback, useRef)"
      - "Rules of Hooks (conditional hooks, dependency arrays)"
      - "Component patterns (naming, props, structure)"
      - "State management (mutation, references)"
      - "Performance (memoization, re-renders)"
    known_gaps:
      - "Server Components (React 19)"
      - "Suspense boundaries"
      - "Error boundaries"
      - "React Router patterns"
      - "State management libraries (Redux, Zustand)"

# ===========================================================================
# RULES
# ===========================================================================
# React-SPECIFIC rules. Universal code hygiene rules (console.log,
# boolean comparisons, generic names) are in code-hygiene.flight.
#
# ID format: {severity_prefix}{number}
#   N = NEVER (check - fails build)
#   S = SHOULD (warn - advisory)
#   G = GUIDANCE (not checked)
# ===========================================================================

rules:

  # =========================================================================
  # NEVER - React anti-patterns (validator will reject)
  # =========================================================================

  N1:
    title: Inline Objects in JSX Props
    severity: NEVER
    mechanical: true
    provenance:
      last_verified: "2026-01-20"
      confidence: high
      re_verify_after: "2027-01-20"
      sources:
        - url: "https://react.dev/reference/react/useMemo"
          accessed: "2026-01-20"
          quote: "useMemo is a React Hook that lets you cache the result of a calculation between re-renders"
    description: >
      Creates new object reference every render, causing unnecessary re-renders
      of child components even when values haven't changed.
    check:
      type: grep
      pattern: '=[{][{]|=\{\s*\{'
      flags: -En
    note: |
      Every render creates a new object: {} !== {}. This breaks React.memo
      and causes children to re-render. Extract to const or useMemo.
    examples:
      bad:
        - "<Component style={{ margin: 10 }} />"
        - "<Component config={{ enabled: true }} />"
      good:
        - |
          const containerStyle = { margin: 10 };
          <Component style={containerStyle} />
        - |
          const config = useMemo(() => ({ enabled: true }), []);
          <Component config={config} />

  N2:
    title: Inline Functions in JSX Props
    severity: NEVER
    mechanical: true
    provenance:
      last_verified: "2026-01-20"
      confidence: high
      re_verify_after: "2027-01-20"
      sources:
        - url: "https://react.dev/reference/react/useCallback"
          accessed: "2026-01-20"
          quote: "useCallback is a React Hook that lets you cache a function definition between re-renders"
    description: >
      Creates new function reference every render, causing unnecessary re-renders
      and breaking React.memo optimization.
    check:
      type: grep
      pattern: 'onClick=\{.*=>|onChange=\{.*=>|onSubmit=\{.*=>|onBlur=\{.*=>|onFocus=\{.*=>'
      flags: -En
    note: |
      Arrow functions in JSX create new references each render.
      Use useCallback for handlers passed to children.
    examples:
      bad:
        - "<Button onClick={() => handleClick(id)} />"
        - "<Input onChange={(e) => setName(e.target.value)} />"
      good:
        - |
          const handleButtonClick = useCallback(() => handleClick(id), [id]);
          <Button onClick={handleButtonClick} />

  N3:
    title: Index as Key
    severity: NEVER
    mechanical: true
    provenance:
      last_verified: "2026-01-20"
      confidence: high
      re_verify_after: "2027-01-20"
      sources:
        - url: "https://react.dev/learn/rendering-lists#keeping-list-items-in-order-with-key"
          accessed: "2026-01-20"
          quote: "Keys tell React which array item each component corresponds to, so that it can match them up later"
    description: >
      Using array index as key breaks React reconciliation on reorder/delete.
      Items get wrong state and animations break.
    check:
      type: grep
      pattern: 'key=\{.*index|key=\{i\}|key=\{idx\}'
      flags: -En
    note: |
      React uses keys to track identity. If key={index} and you delete item 2,
      item 3 becomes index 2 and inherits item 2's state. Use stable IDs.
    examples:
      bad:
        - "items.map((item, index) => <Item key={index} />)"
        - "items.map((item, i) => <Item key={i} />)"
      good:
        - "items.map((item) => <Item key={item.id} />)"
        - "items.map((item) => <Item key={`${item.type}-${item.id}`} />)"

  N4:
    title: Direct State Mutation
    severity: NEVER
    mechanical: true
    provenance:
      last_verified: "2026-01-20"
      confidence: high
      re_verify_after: "2027-01-20"
      sources:
        - url: "https://react.dev/learn/updating-arrays-in-state"
          accessed: "2026-01-20"
          quote: "In React, you should treat arrays in state as read-only"
    description: >
      Never mutate state directly with push/pop/splice. React won't detect
      the change and won't re-render.
    check:
      type: grep
      pattern: '\.push\(|\.splice\(|\.pop\(|\.shift\(|\.unshift\('
      flags: -En
    note: |
      Mutating arrays in place keeps the same reference.
      React compares references, not contents. Create new arrays.
    examples:
      bad:
        - |
          items.push(newItem);
          setItems(items);  // Same reference, no re-render
        - |
          user.name = 'new';
          setUser(user);
      good:
        - "setItems([...items, newItem]);"
        - "setUser({ ...user, name: 'new' });"
        - "setItems(items.filter(i => i.id !== removeId));"

  N5:
    title: Missing Dependency Arrays
    severity: NEVER
    mechanical: true
    provenance:
      last_verified: "2026-01-20"
      confidence: high
      re_verify_after: "2027-01-20"
      sources:
        - url: "https://react.dev/reference/react/useEffect#specifying-reactive-dependencies"
          accessed: "2026-01-20"
          quote: "The list of dependencies must have a constant number of items and be written inline"
    description: >
      useEffect/useMemo/useCallback with empty deps but referencing
      outer variables causes stale closures.
    check:
      type: script
      code: |
        grep -Pzo 'useEffect\(\s*\(\)\s*=>\s*\{[^}]*[a-zA-Z]+[^}]*\},\s*\[\]\)' "$@" 2>/dev/null | head -5 || true
    note: |
      Empty deps [] means "run once". If the callback uses userId but deps is [],
      userId will be stale forever. Add all referenced variables to deps.
    examples:
      bad:
        - "useEffect(() => { fetchData(userId); }, []);  // userId stale"
        - "useEffect(() => { fetchData(userId); });  // runs every render"
      good:
        - "useEffect(() => { fetchData(userId); }, [userId]);"

  N6:
    title: Conditional Hooks
    severity: NEVER
    mechanical: true
    provenance:
      last_verified: "2026-01-20"
      confidence: high
      re_verify_after: "2027-01-20"
      sources:
        - url: "https://react.dev/reference/rules/rules-of-hooks"
          accessed: "2026-01-20"
          quote: "Only call Hooks at the top level. Don't call Hooks inside loops, conditions, or nested functions"
    description: >
      Calling hooks inside conditions/loops breaks Rules of Hooks.
      React tracks hooks by call order which must be stable.
    check:
      type: grep
      pattern: 'if.*\{[^}]*(useState|useEffect|useMemo|useCallback|useRef)'
      flags: -En
    note: |
      Hooks must be called in the same order every render.
      Moving useState inside an if-block changes call order conditionally.
      Instead, call hooks at top level and conditionally use the values.
    examples:
      bad:
        - |
          if (isLoggedIn) {
            const [user] = useState(null);  // Hook inside condition!
          }
      good:
        - |
          const [user] = useState(null);  // Always called
          if (!isLoggedIn) return null;   // Conditional render is fine

  N7:
    title: Generic Component Names
    severity: NEVER
    mechanical: true
    provenance:
      last_verified: "2026-01-20"
      confidence: high
      re_verify_after: "2027-01-20"
      sources:
        - url: "https://react.dev/learn/your-first-component#defining-a-component"
          accessed: "2026-01-20"
          quote: "React component names must start with a capital letter"
    description: >
      Component functions named Item, Card, Component, etc. are too generic.
      Use domain-specific names that describe what the component represents.
    check:
      type: grep
      pattern: 'function\s+\w+\(\s*\{\s*(data|info|item|value)\s*\}'
      flags: -En
    note: |
      Generic names hurt readability and make refactoring harder.
      ProductCard tells you what it is. Item tells you nothing.
    examples:
      bad:
        - "function Item({ data }) { ... }"
        - "function Card({ info }) { ... }"
        - "function Component({ value }) { ... }"
      good:
        - "function ProductCard({ product }) { ... }"
        - "function UserAvatar({ user }) { ... }"
        - "function OrderSummary({ order }) { ... }"

  N8:
    title: Export Default (except Next.js special files)
    severity: NEVER
    mechanical: true
    provenance:
      last_verified: "2026-01-20"
      confidence: medium
      re_verify_after: "2026-07-20"
      sources:
        - url: "https://nextjs.org/docs/app/building-your-application/routing/pages"
          accessed: "2026-01-20"
          quote: "A page is UI that is unique to a route. You can define a page by default exporting a component"
    description: >
      Use named exports for better refactoring support and explicit imports.
      Exception: Next.js App Router special files require export default.
    check:
      type: script
      code: |
        for f in "$@"; do
            basename=$(basename "$f")
            # Skip Next.js special files that require export default
            if [[ "$basename" =~ ^(page|layout|loading|error|not-found|template|default|main)\.(tsx|jsx|ts|js)$ ]]; then
                continue
            fi
            grep -En '^export default' "$f" 2>/dev/null || true
        done
    note: |
      export default allows renaming on import, hiding the real name.
      Named exports keep names consistent across codebase.
      Next.js page.tsx, layout.tsx, etc. MUST use export default per framework.
      Vite main.tsx is the entry point and uses default export pattern by convention.
    examples:
      bad:
        - "export default function UserCard() { ... }"
      good:
        - "export function UserCard() { ... }"
        - |
          // page.tsx - Next.js exception
          export default function HomePage() { ... }
        - |
          // main.tsx - Vite entry point exception
          import { StrictMode } from 'react'
          import { createRoot } from 'react-dom/client'
          import { App } from './App'

          createRoot(document.getElementById('root')!).render(
            <StrictMode>
              <App />
            </StrictMode>
          )

  N9:
    title: Props Named data/info/item/value
    severity: NEVER
    mechanical: true
    provenance:
      last_verified: "2026-01-20"
      confidence: high
      re_verify_after: "2027-01-20"
      sources:
        - url: "https://react.dev/learn/passing-props-to-a-component"
          accessed: "2026-01-20"
          quote: "Props let you think about parent and child components independently"
    description: >
      Generic prop names like data, info, item hide intent.
      Use domain-specific names that describe the prop's purpose.
    check:
      type: script
      code: |
        grep -En '\{\s*(data|info|item|value)\s*\}' "$@" | grep -v 'const\|let\|var' || true
    note: |
      <List data={data}> tells you nothing. <ProductList products={products}>
      tells you exactly what it does. Domain names prevent misuse.
    examples:
      bad:
        - "function List({ data, onItemClick }) { ... }"
        - "const { data } = props;"
      good:
        - "function ProductList({ products, onProductSelect }) { ... }"
        - "const { products } = props;"

  N10:
    title: Console.log in Components
    severity: NEVER
    mechanical: true
    provenance:
      last_verified: "2026-01-20"
      confidence: high
      re_verify_after: "2027-01-20"
      sources:
        - url: "https://react.dev/learn/react-developer-tools"
          accessed: "2026-01-20"
          quote: "Use React Developer Tools to inspect React components"
    description: >
      Console statements in components indicate incomplete development
      or forgotten debugging code. Remove before committing.
    check:
      type: grep
      pattern: 'console\.(log|warn|error)'
      flags: -En
    note: |
      Console.log in components runs on every render, cluttering
      browser console. Use proper logging or React DevTools instead.
    examples:
      bad:
        - "console.log('rendered', props);"
        - "console.log('state:', user);"
      good:
        - "// Use React DevTools for debugging"
        - "// Use proper logging service for production"

  N11:
    title: Ternary Returning Boolean Literals
    severity: NEVER
    mechanical: true
    provenance:
      last_verified: "2026-01-20"
      confidence: high
      re_verify_after: "2027-01-20"
      sources:
        - url: "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator"
          accessed: "2026-01-20"
          quote: "The conditional (ternary) operator is the only JavaScript operator that takes three operands"
    description: >
      condition ? true : false is always redundant.
      The condition is already boolean (or truthy/falsy).
    check:
      type: grep
      pattern: '\?\s*true\s*:\s*false|\?\s*false\s*:\s*true'
      flags: -En
    note: |
      x ? true : false === Boolean(x) === !!x
      x ? false : true === !x
      Just use the simpler form.
    examples:
      bad:
        - "const isActive = status === 'active' ? true : false;"
        - "disabled={isLoading ? true : false}"
      good:
        - "const isActive = status === 'active';"
        - "disabled={isLoading}"

  N12:
    title: Redundant Boolean Comparisons
    severity: NEVER
    mechanical: true
    provenance:
      last_verified: "2026-01-20"
      confidence: high
      re_verify_after: "2027-01-20"
      sources:
        - url: "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Strict_equality"
          accessed: "2026-01-20"
          quote: "The strict equality (===) operator checks whether its two operands are equal"
    description: >
      Comparing to true/false explicitly is redundant.
      Booleans are already truthy/falsy.
    check:
      type: grep
      pattern: '===\s*true|===\s*false|!==\s*true|!==\s*false'
      flags: -En
    note: |
      if (x === true) is the same as if (x).
      if (x === false) is the same as if (!x).
      The explicit comparison adds noise.
    examples:
      bad:
        - "if (isLoading === true) { ... }"
        - "if (isValid === false) { ... }"
      good:
        - "if (isLoading) { ... }"
        - "if (!isValid) { ... }"

  # =========================================================================
  # SHOULD - Best practices (validator warns)
  # =========================================================================

  S1:
    title: Handle Loading State
    severity: SHOULD
    mechanical: true
    provenance:
      last_verified: "2026-01-20"
      confidence: high
      re_verify_after: "2027-01-20"
      sources:
        - url: "https://react.dev/reference/react/Suspense"
          accessed: "2026-01-20"
          quote: "Suspense lets you display a fallback until its children have finished loading"
    description: >
      Components with async operations (fetch, useQuery, useSWR) should
      handle loading state to prevent flash of empty content.
    check:
      type: script
      code: |
        for f in "$@"; do
          if grep -q 'fetch\|useQuery\|useSWR\|useEffect.*async' "$f"; then
            if ! grep -q 'isLoading\|loading' "$f"; then
              echo "$f: has async but no loading state"
            fi
          fi
        done
    note: |
      Users should see a loading indicator, not a blank screen or
      broken layout while data loads.
    examples:
      bad:
        - |
          function UserProfile({ userId }) {
            const { data } = useFetch(`/users/${userId}`);
            return <div>{data.name}</div>;  // Crashes while loading!
          }
      good:
        - |
          function UserProfile({ userId }) {
            const { data, isLoading, error } = useFetch(`/users/${userId}`);
            if (isLoading) return <LoadingSpinner />;
            if (error) return <ErrorMessage error={error} />;
            return <div>{data.name}</div>;
          }

  S2:
    title: Handle Error State
    severity: SHOULD
    mechanical: true
    provenance:
      last_verified: "2026-01-20"
      confidence: high
      re_verify_after: "2027-01-20"
      sources:
        - url: "https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary"
          accessed: "2026-01-20"
          quote: "Error boundaries catch errors during rendering, in lifecycle methods, and in constructors"
    description: >
      Components with async operations should handle error state
      to show meaningful feedback instead of crashing.
    check:
      type: script
      code: |
        for f in "$@"; do
          if grep -q 'fetch\|useQuery\|useSWR\|useEffect.*async' "$f"; then
            if ! grep -q 'error\|Error' "$f"; then
              echo "$f: has async but no error handling"
            fi
          fi
        done
    note: |
      Network requests fail. APIs return errors. Show users what went wrong
      instead of crashing or showing stale data.
    examples:
      good:
        - |
          if (error) return <ErrorMessage error={error} />;

  S3:
    title: Boolean Props Use Prefix
    severity: SHOULD
    mechanical: true
    provenance:
      last_verified: "2026-01-20"
      confidence: high
      re_verify_after: "2027-01-20"
      sources:
        - url: "https://react.dev/learn/passing-props-to-a-component#passing-jsx-as-children"
          accessed: "2026-01-20"
          quote: "When you nest content inside a JSX tag, the parent component will receive that content in a prop called children"
    description: >
      Boolean props should use is/has/can/should prefix for clarity.
      Exception: HTML attributes like disabled, checked, selected.
    check:
      type: grep
      pattern: '^\s*(loading|visible|active)='
      flags: -En
    note: |
      isLoading is clearly boolean. loading could be anything.
      Prefixes make JSX self-documenting.
    examples:
      bad:
        - "<Modal open={true} loading={true} disabled={true} />"
      good:
        - "<Modal isOpen={true} isLoading={true} disabled={true} />"

  S4:
    title: useCallback for Handlers
    severity: SHOULD
    mechanical: true
    provenance:
      last_verified: "2026-01-20"
      confidence: high
      re_verify_after: "2027-01-20"
      sources:
        - url: "https://react.dev/reference/react/useCallback"
          accessed: "2026-01-20"
          quote: "useCallback is a React Hook that lets you cache a function definition between re-renders"
    description: >
      Event handlers defined with const should use useCallback
      when passed to child components to prevent unnecessary re-renders.
    check:
      type: script
      code: |
        for f in "$@"; do
          if grep -q 'const handle' "$f"; then
            if ! grep -q 'useCallback' "$f"; then
              handlers=$(grep -c 'const handle' "$f")
              if [ "$handlers" -gt 0 ]; then
                echo "$f: $handlers handlers without useCallback"
              fi
            fi
          fi
        done
    note: |
      Without useCallback, handlers are recreated every render.
      This breaks React.memo and causes child re-renders.
    examples:
      bad:
        - |
          const handleClick = () => { ... };  // New function every render
          <Button onClick={handleClick} />
      good:
        - |
          const handleClick = useCallback(() => { ... }, [deps]);
          <Button onClick={handleClick} />

  # =========================================================================
  # GUIDANCE - Design patterns (not mechanically checked)
  # =========================================================================

  G1:
    title: Component Structure
    severity: GUIDANCE
    mechanical: false
    description: >
      Recommended structure for React components to improve consistency
      and readability across the codebase.
    note: |
      1. Imports (external, then internal)
      2. Constants
      3. Component function
         3a. Hooks (always at top, same order)
         3b. Derived state / memoized values
         3c. Callbacks (useCallback)
         3d. Effects (useEffect)
         3e. Early returns / guards
         3f. Render

  G2:
    title: Custom Hook Structure
    severity: GUIDANCE
    mechanical: false
    description: >
      Pattern for custom hooks that handle async operations with
      proper cleanup and loading/error states.
    note: |
      export function useProducts(categoryId) {
        const [products, setProducts] = useState([]);
        const [isLoading, setIsLoading] = useState(true);
        const [error, setError] = useState(null);

        useEffect(() => {
          let isMounted = true;  // Cleanup flag
          setIsLoading(true);
          setError(null);

          fetchProducts(categoryId)
            .then((data) => {
              if (isMounted) {
                setProducts(data);
                setIsLoading(false);
              }
            })
            .catch((err) => {
              if (isMounted) {
                setError(err);
                setIsLoading(false);
              }
            });

          return () => { isMounted = false; };  // Cleanup
        }, [categoryId]);

        return { products, isLoading, error };
      }

  G3:
    title: Form with useReducer
    severity: GUIDANCE
    mechanical: false
    description: >
      For complex forms, useReducer provides better state management
      than multiple useState calls.
    note: |
      const initialFormState = {
        values: { email: '', password: '' },
        errors: {},
        isSubmitting: false
      };

      function formReducer(state, action) {
        switch (action.type) {
          case 'SET_FIELD':
            return {
              ...state,
              values: { ...state.values, [action.field]: action.value },
              errors: { ...state.errors, [action.field]: null }
            };
          case 'SET_ERROR':
            return { ...state, errors: { ...state.errors, [action.field]: action.error } };
          case 'SUBMIT_START':
            return { ...state, isSubmitting: true };
          case 'SUBMIT_END':
            return { ...state, isSubmitting: false };
          default:
            return state;
        }
      }

# ===========================================================================
# INFO CHECKS - Statistics for reporting (not pass/fail)
# ===========================================================================

info:
  components:
    pattern: '^export (async )?function [A-Z]|^export const [A-Z].* = '
    flags: -lE
    label: "Components found"
    aggregate: count

  hooks_used:
    pattern: 'use[A-Z][a-zA-Z]+'
    flags: -ohE
    label: "Hooks used"
    aggregate: unique

  custom_hooks:
    pattern: '^export function use[A-Z]'
    flags: -lE
    label: "Custom hooks"
    aggregate: count

# ===========================================================================
# ANTI-PATTERNS - Quick reference table (documentation only)
# ===========================================================================

anti_patterns:
  - pattern: "<Comp style={{...}}/>"
    description: "New ref every render"
    fix: "Extract to const/useMemo"

  - pattern: "<Comp onClick={() => ...}/>"
    description: "New fn every render"
    fix: "useCallback"

  - pattern: "key={index}"
    description: "Breaks on reorder"
    fix: "Use stable ID"

  - pattern: "arr.push(); setArr(arr)"
    description: "Mutation not detected"
    fix: "setArr([...arr, new])"

  - pattern: "useEffect(() => {}, [])"
    description: "Missing deps"
    fix: "Add all deps"

  - pattern: "if (x) useState()"
    description: "Hook rules violation"
    fix: "Hooks at top level"

  - pattern: "export default"
    description: "Refactor issues"
    fix: "Named exports (except Next.js)"

  - pattern: "function Item({data})"
    description: "Generic naming"
    fix: "Domain-specific names"

  - pattern: "{loading && <Spin/>}"
    description: "Flash of content"
    fix: "Early return pattern"

