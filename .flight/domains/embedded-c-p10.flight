# embedded-c-p10.flight - Embedded C Power of 10 Domain
# Source: Migrated from embedded-c-p10.md and embedded-c-p10.validate.sh

domain: embedded-c-p10
version: 1.0.0
description: >
  Safety-critical embedded C following NASA JPL's "Power of 10" rules for
  reliable software. Reference: Gerard J. Holzmann, "The Power of 10: Rules
  for Developing Safety-Critical Code", IEEE Computer, 2006.

file_patterns:
  - "**/*.c"

exclude_patterns:
  - "**/node_modules/**"
  - "**/dist/**"
  - "**/build/**"
  - "**/.git/**"

suppression:
  comment: "flight:ok"
  guidance: |
    Add `/* flight:ok */` on the same line to suppress.
    Use sparingly. Safety-critical code rules should rarely be suppressed.
    Document why the suppression is acceptable.

# ===========================================================================
# RULES
# ===========================================================================
# ID format: {severity_prefix}{number}
#   N = NEVER (check - fails build)
#   G = GUIDANCE (not checked)
#
# Note: This domain has NO SHOULD rules. All mechanical checks are NEVER
# severity because this is safety-critical code.
# ===========================================================================

rules:

  # =========================================================================
  # NEVER - Control Flow Restrictions (validator will reject)
  # =========================================================================

  N1:
    title: No goto
    severity: NEVER
    mechanical: true
    description: >
      Never use goto. It creates unstructured control flow that is difficult
      to analyze and verify. Use structured control flow (if, while, for,
      switch) instead.
    check:
      type: grep
      pattern: 'goto '
      flags: -n
    examples:
      bad:
        - "goto cleanup;"
        - "goto error_handler;"
      good:
        - "return STATUS_ERROR;"
        - "if (error) { cleanup(); return STATUS_ERROR; }"

  N2:
    title: No setjmp/longjmp
    severity: NEVER
    mechanical: true
    description: >
      Never use setjmp or longjmp. They create non-local jumps that bypass
      normal control flow and make code impossible to analyze statically.
    check:
      type: grep
      pattern: 'setjmp\|longjmp'
      flags: -n
    examples:
      bad:
        - "if (setjmp(buf) == 0) { ... }"
        - "longjmp(buf, 1);"
      good:
        - "return STATUS_ERROR;"
        - "Use structured error handling with return codes"

  N3:
    title: No Dynamic Memory Allocation
    severity: NEVER
    mechanical: true
    description: >
      Never use malloc, free, calloc, or realloc. Dynamic memory allocation
      introduces unpredictable behavior, fragmentation, and potential for
      memory leaks. Use static allocation with fixed-size buffers.
    check:
      type: grep
      pattern: '\b(malloc|free|calloc|realloc)\b'
      flags: -En
    examples:
      bad:
        - "char *buf = malloc(size);"
        - "free(ptr);"
        - "ptr = realloc(ptr, new_size);"
      good:
        - "static char buffer[MAX_BUFFER_SIZE];"
        - "char local_buf[FIXED_SIZE];"

  N4:
    title: No Conditional Compilation
    severity: NEVER
    mechanical: true
    description: >
      Never use #ifdef or #if. Conditional compilation creates multiple
      code paths that may not all be tested. Use runtime configuration
      or compile separate variants.
    check:
      type: grep
      pattern: '^#ifdef\|^#if '
      flags: -n
    note: Only #include and #define constants are allowed.
    examples:
      bad:
        - "#ifdef DEBUG"
        - "#if FEATURE_ENABLED"
      good:
        - "#include <stdint.h>"
        - "#define MAX_ITEMS 100U"

  N5:
    title: No Double Pointer Dereference
    severity: NEVER
    mechanical: true
    description: >
      Never use double pointer dereference (**ptr). It indicates overly
      complex data structures. Flatten data structures or use single
      indirection with explicit indexing.
    check:
      type: grep
      pattern: '[^/]\*\*[a-zA-Z]'
      flags: -n
    examples:
      bad:
        - "**ptr = value;"
        - "result = **data;"
      good:
        - "*ptr = value;"
        - "array[index].field = value;"

  N6:
    title: No Chained Pointer Access
    severity: NEVER
    mechanical: true
    description: >
      Never chain pointer dereferences (->field->field). It indicates
      overly coupled data structures. Use local variables to break
      the chain.
    check:
      type: grep
      pattern: '->.*->'
      flags: -n
    examples:
      bad:
        - "value = ptr->inner->data;"
        - "ptr->next->prev = node;"
      good:
        - |
          inner_t *inner = ptr->inner;
          value = inner->data;

  N7:
    title: No Unbounded Loops
    severity: NEVER
    mechanical: true
    description: >
      Never use unbounded loops (while(1), while(true), for(;;)). All
      loops must have a fixed upper bound that can be statically verified.
    check:
      type: grep
      pattern: 'while\s*\(1\)|while\s*\(true\)|for\s*\(;;\)'
      flags: -En
    examples:
      bad:
        - "while (1) { ... }"
        - "while (true) { ... }"
        - "for (;;) { ... }"
      good:
        - "for (uint32_t i = 0U; i < MAX_ITERATIONS; i++) { ... }"
        - "while (count < MAX_COUNT) { ... count++; }"

  # =========================================================================
  # NEVER - Build Requirements (validator will reject)
  # =========================================================================

  N8:
    title: Compile Clean with Strict Warnings
    severity: NEVER
    mechanical: true
    description: >
      Code must compile without warnings using strict compiler flags:
      -Wall -Wextra -Werror -pedantic -std=c11. Any warning is an error.
    check:
      type: script
      code: |
        gcc -Wall -Wextra -Werror -pedantic -std=c11 -fsyntax-only "$@" 2>&1
    note: Requires gcc. Adjust for your toolchain if needed.
    examples:
      bad:
        - "// Code that produces any warning"
      good:
        - "// Code that compiles cleanly with all warnings enabled"

  N9:
    title: Functions Must Be 60 Lines or Less
    severity: NEVER
    mechanical: true
    description: >
      Every function must be 60 lines or less. This ensures functions
      fit on one screen and are easier to understand, test, and verify.
    check:
      type: script
      code: |
        awk '
        /^(status_t|static|void|int|uint[0-9]+_t|bool) [a-z_]+\(/ {
          start=NR; fname=$0; in_func=1
        }
        /^}$/ && in_func {
          len=NR-start
          if (len > 60) {
            gsub(/\(.*/, "", fname)
            gsub(/^.* /, "", fname)
            print fname": "len" lines"
          }
          in_func=0
        }' "$@"
    examples:
      bad:
        - "// Function with more than 60 lines"
      good:
        - "// Function with 60 lines or less"

  N10:
    title: Minimum 2 Assertions Per Function
    severity: NEVER
    mechanical: true
    description: >
      Every function must have at least 2 ASSERT() calls - typically
      one for preconditions (input validation) and one for postconditions
      (output validation).
    check:
      type: script
      code: |
        awk '
        /^(status_t|static|void|int|uint[0-9]+_t|bool) [a-z_]+\(/ {
          fname=$0; asserts=0; in_func=1
        }
        /ASSERT\(|assert\(/ && in_func { asserts++ }
        /^}$/ && in_func {
          if (asserts < 2) {
            gsub(/\(.*/, "", fname)
            gsub(/^.* /, "", fname)
            print fname": "asserts" asserts"
          }
          in_func=0
        }' "$@"
    examples:
      bad:
        - |
          status_t func(int *ptr) {
            // No assertions
            return STATUS_OK;
          }
      good:
        - |
          status_t func(int *ptr) {
            ASSERT(ptr != NULL);
            // implementation
            ASSERT(result == STATUS_OK || result == STATUS_ERROR);
            return result;
          }

  N11:
    title: Check or Cast All Return Values
    severity: NEVER
    mechanical: true
    description: >
      All function return values must be checked or explicitly cast to
      (void) if intentionally ignored. This applies especially to printf
      and fprintf.
    check:
      type: script
      code: |
        grep -n 'printf\|fprintf' "$@" 2>/dev/null | grep -v '(void)' | grep -v '= ' || true
    examples:
      bad:
        - 'printf("Hello");'
        - 'fprintf(fp, "data");'
      good:
        - '(void)printf("Hello");'
        - 'int ret = fprintf(fp, "data"); ASSERT(ret > 0);'

  # =========================================================================
  # GUIDANCE - Best practices (not mechanically checked)
  # =========================================================================

  G1:
    title: Simple Control Flow
    severity: GUIDANCE
    mechanical: false
    description: >
      Use only simple control flow constructs: if, else, for, while,
      do-while, switch with default. No goto, setjmp, longjmp.
    guidance: |
      Allowed control flow:
      - if / else if / else
      - for (with bounded iterations)
      - while (with bounded iterations)
      - do-while (with bounded iterations)
      - switch with default case

      Not allowed:
      - goto
      - setjmp / longjmp
      - Recursion

  G2:
    title: Fixed Loop Bounds Pattern
    severity: GUIDANCE
    mechanical: false
    description: >
      All loops must have a statically verifiable upper bound.
    guidance: |
      #define MAX_ITEMS 100U

      for (uint32_t i = 0U; i < MAX_ITEMS; i++) {
        // Loop body - guaranteed to terminate
      }

      // Counter variable must:
      // - Be initialized
      // - Have a constant upper bound
      // - Be incremented toward the bound

  G3:
    title: Static Memory Only
    severity: GUIDANCE
    mechanical: false
    description: >
      Use only static memory allocation. No heap allocation.
    guidance: |
      // Static allocation patterns:

      // 1. File-scope static buffer
      static uint8_t buffer[MAX_BUFFER_SIZE];

      // 2. Function-scope fixed buffer
      void func(void) {
        char local_buf[FIXED_SIZE];
        // ...
      }

      // 3. Struct with fixed-size arrays
      typedef struct {
        uint8_t data[MAX_DATA_SIZE];
        uint32_t length;
      } message_t;

  G4:
    title: Minimal Scope Principle
    severity: GUIDANCE
    mechanical: false
    description: >
      Declare variables at the smallest possible scope and initialize
      at declaration.
    guidance: |
      // BAD - declared far from use
      int i;
      // ... many lines ...
      for (i = 0; i < MAX; i++) { }

      // GOOD - declared at point of use
      for (int i = 0; i < MAX; i++) { }

      // GOOD - initialized at declaration
      uint32_t count = 0U;
      status_t result = STATUS_OK;

  G5:
    title: Limited Preprocessor Usage
    severity: GUIDANCE
    mechanical: false
    description: >
      Use preprocessor only for includes and constant definitions.
      No conditional compilation.
    guidance: |
      // Allowed:
      #include <stdint.h>
      #include <stdbool.h>
      #include "module.h"

      #define MAX_BUFFER_SIZE 1024U
      #define STATUS_OK 0

      // Not allowed:
      #ifdef DEBUG
      #if FEATURE_ENABLED
      #ifndef HEADER_H

  G6:
    title: Function Template
    severity: GUIDANCE
    mechanical: false
    description: >
      Standard function template with assertions and status return.
    guidance: |
      status_t func_name(const input_t *in, output_t *out)
      {
        // Precondition assertions
        ASSERT(in != NULL);
        ASSERT(out != NULL);

        status_t result = STATUS_OK;

        // Implementation
        // ...

        // Postcondition assertion
        ASSERT(result == STATUS_OK || result == STATUS_ERROR);
        return result;
      }

  G7:
    title: Status Codes Pattern
    severity: GUIDANCE
    mechanical: false
    description: >
      Standard status code enumeration for function return values.
    guidance: |
      typedef enum {
        STATUS_OK = 0,
        STATUS_ERROR = -1,
        STATUS_INVALID_PARAM = -2,
        STATUS_BUFFER_FULL = -3,
        STATUS_BUFFER_EMPTY = -4,
        STATUS_TIMEOUT = -5
      } status_t;

  G8:
    title: ASSERT Macro Pattern
    severity: GUIDANCE
    mechanical: false
    description: >
      Custom ASSERT macro that captures file, line, and expression.
    guidance: |
      #define ASSERT(expr) \
        do { \
          if (!(expr)) { \
            assert_failed(__FILE__, __LINE__, #expr); \
          } \
        } while (0)

      void assert_failed(const char *file, int line, const char *expr)
      {
        // Log or halt - implementation depends on target
        (void)fprintf(stderr, "ASSERT FAILED: %s:%d: %s\n", file, line, expr);
        abort();  // or enter safe state
      }

  G9:
    title: No Magic Numbers
    severity: GUIDANCE
    mechanical: false
    description: >
      All numeric constants must be named with #define or enum.
    guidance: |
      // BAD - magic numbers
      if (count > 100) { }
      buffer[42] = value;

      // GOOD - named constants
      #define MAX_COUNT 100U
      #define HEADER_OFFSET 42U

      if (count > MAX_COUNT) { }
      buffer[HEADER_OFFSET] = value;

  G10:
    title: No Recursion
    severity: GUIDANCE
    mechanical: false
    description: >
      Never use recursion. It makes stack usage unpredictable and
      can lead to stack overflow. Use iteration instead.
    guidance: |
      // BAD - recursive
      uint32_t factorial(uint32_t n) {
        if (n <= 1) return 1;
        return n * factorial(n - 1);  // Stack grows unpredictably
      }

      // GOOD - iterative
      uint32_t factorial(uint32_t n) {
        ASSERT(n <= MAX_FACTORIAL_INPUT);
        uint32_t result = 1U;
        for (uint32_t i = 2U; i <= n; i++) {
          result *= i;
        }
        return result;
      }

anti_patterns:
  - pattern: "goto"
    problem: "Unstructured control flow"
    fix: "Use structured control (if/while/for)"
  - pattern: "setjmp/longjmp"
    problem: "Non-local jumps bypass control flow"
    fix: "Use return codes"
  - pattern: "malloc/free"
    problem: "Unpredictable memory, fragmentation"
    fix: "Static allocation only"
  - pattern: "#ifdef/#if"
    problem: "Multiple untested code paths"
    fix: "Compile separate variants"
  - pattern: "**ptr"
    problem: "Overly complex data structures"
    fix: "Flatten structures"
  - pattern: "->->"
    problem: "Coupled data structures"
    fix: "Use local variables"
  - pattern: "while(1)"
    problem: "Unbounded loop"
    fix: "Use bounded loop with MAX"
  - pattern: "Magic numbers"
    problem: "Unclear intent"
    fix: "Named constants (#define)"
  - pattern: "Recursion"
    problem: "Unpredictable stack usage"
    fix: "Use iteration"
  - pattern: "Unchecked return"
    problem: "Silent failures"
    fix: "Check or cast to (void)"
