# embedded-c-p10.flight - Embedded C Power of 10 Domain
# Source: Migrated from embedded-c-p10.md and embedded-c-p10.validate.sh

domain: embedded-c-p10
version: 1.1.0
schema_version: 2
description: >
  Safety-critical embedded C following NASA JPL's "Power of 10" rules for
  reliable software. Reference: Gerard J. Holzmann, "The Power of 10: Rules
  for Developing Safety-Critical Code", IEEE Computer, 2006.

provenance:
  last_full_audit: "2026-01-16"
  audited_by: "flight-research"
  next_audit_due: "2026-07-16"

  sources_consulted:
    - url: "https://spinroot.com/gerard/pdf/P10.pdf"
      accessed: "2026-01-16"
      note: "Original Power of 10 paper by Gerard J. Holzmann, IEEE Computer 2006"
    - url: "https://www.state-machine.com/doc/AN_QL_Coding_Standard.pdf"
      accessed: "2026-01-16"
      note: "JPL Institutional Coding Standard for C - based on Power of 10"
    - url: "https://misra.org.uk/misra-c/"
      accessed: "2026-01-16"
      note: "MISRA C Guidelines - related automotive/safety-critical C standard"
    - url: "https://www.sei.cmu.edu/our-work/publications/cert-c-coding-standard/"
      accessed: "2026-01-16"
      note: "CERT C Coding Standard - secure coding guidelines"

  coverage:
    apis_covered:
      - "C11 language constructs"
      - "Memory allocation"
      - "Control flow"
      - "Preprocessor usage"
      - "Static analysis compatibility"
    known_gaps:
      - "Toolchain-specific warnings may vary"
      - "Embedded-specific runtime checks not covered"

file_patterns:
  - "**/*.c"

exclude_patterns:
  - "**/node_modules/**"
  - "**/dist/**"
  - "**/build/**"
  - "**/.git/**"

# ===========================================================================
# RULES
# ===========================================================================
# ID format: {severity_prefix}{number}
#   N = NEVER (check - fails build)
#   G = GUIDANCE (not checked)
#
# Note: This domain has NO SHOULD rules. All mechanical checks are NEVER
# severity because this is safety-critical code.
# ===========================================================================

rules:

  # =========================================================================
  # NEVER - Control Flow Restrictions (validator will reject)
  # =========================================================================

  N1:
    title: No goto
    severity: NEVER
    mechanical: true
    provenance:
      last_verified: "2026-01-16"
      confidence: high
      re_verify_after: "2027-01-16"
      sources:
        - url: "https://spinroot.com/gerard/pdf/P10.pdf"
          accessed: "2026-01-16"
          quote: "Rule 1: Restrict all code to very simple control flow constructs â€“ do not use goto statements"
    description: >
      Never use goto. It creates unstructured control flow that is difficult
      to analyze and verify. Use structured control flow (if, while, for,
      switch) instead.
    check:
      type: grep
      pattern: 'goto '
      flags: -n
    examples:
      bad:
        - "goto cleanup;"
        - "goto error_handler;"
      good:
        - "return STATUS_ERROR;"
        - "if (error) { cleanup(); return STATUS_ERROR; }"

  N2:
    title: No setjmp/longjmp
    severity: NEVER
    mechanical: true
    provenance:
      last_verified: "2026-01-16"
      confidence: high
      re_verify_after: "2027-01-16"
      sources:
        - url: "https://spinroot.com/gerard/pdf/P10.pdf"
          accessed: "2026-01-16"
          quote: "Rule 1: do not use setjmp or longjmp constructs"
    description: >
      Never use setjmp or longjmp. They create non-local jumps that bypass
      normal control flow and make code impossible to analyze statically.
    check:
      type: grep
      pattern: 'setjmp\|longjmp'
      flags: -n
    examples:
      bad:
        - "if (setjmp(buf) == 0) { ... }"
        - "longjmp(buf, 1);"
      good:
        - "return STATUS_ERROR;"
        - "Use structured error handling with return codes"

  N3:
    title: No Dynamic Memory Allocation
    severity: NEVER
    mechanical: true
    provenance:
      last_verified: "2026-01-16"
      confidence: high
      re_verify_after: "2027-01-16"
      sources:
        - url: "https://spinroot.com/gerard/pdf/P10.pdf"
          accessed: "2026-01-16"
          quote: "Rule 3: Do not use dynamic memory allocation after initialization"
    description: >
      Never use malloc, free, calloc, or realloc. Dynamic memory allocation
      introduces unpredictable behavior, fragmentation, and potential for
      memory leaks. Use static allocation with fixed-size buffers.
    check:
      type: ast
      query: |
        (call_expression
          function: (identifier) @violation
          (#match? @violation "^(malloc|free|calloc|realloc)$"))
    note: AST-based detection - only matches actual function calls, not comments or strings.
    examples:
      bad:
        - "char *buf = malloc(size);"
        - "free(ptr);"
        - "ptr = realloc(ptr, new_size);"
      good:
        - "static char buffer[MAX_BUFFER_SIZE];"
        - "char local_buf[FIXED_SIZE];"
        - "// Comment mentioning malloc is OK"

  N4:
    title: No Conditional Compilation
    severity: NEVER
    mechanical: true
    provenance:
      last_verified: "2026-01-16"
      confidence: high
      re_verify_after: "2027-01-16"
      sources:
        - url: "https://spinroot.com/gerard/pdf/P10.pdf"
          accessed: "2026-01-16"
          quote: "Rule 8: The use of the preprocessor must be limited to the inclusion of header files and simple macro definitions"
    description: >
      Never use #ifdef or #if. Conditional compilation creates multiple
      code paths that may not all be tested. Use runtime configuration
      or compile separate variants.
    check:
      type: grep
      pattern: '^#ifdef\|^#if '
      flags: -n
    note: Only #include and #define constants are allowed.
    examples:
      bad:
        - "#ifdef DEBUG"
        - "#if FEATURE_ENABLED"
      good:
        - "#include <stdint.h>"
        - "#define MAX_ITEMS 100U"

  N5:
    title: No Double Pointer Dereference
    severity: NEVER
    mechanical: true
    provenance:
      last_verified: "2026-01-16"
      confidence: high
      re_verify_after: "2027-01-16"
      sources:
        - url: "https://spinroot.com/gerard/pdf/P10.pdf"
          accessed: "2026-01-16"
          quote: "Rule 9: The use of pointers must be restricted. Specifically, no more than one level of dereferencing should be used"
    description: >
      Never use double pointer dereference (**ptr). It indicates overly
      complex data structures. Flatten data structures or use single
      indirection with explicit indexing.
    check:
      type: ast
      query: |
        (pointer_expression
          argument: (pointer_expression) @violation)
    note: |
      AST-based detection - only matches actual double dereferences like **ptr.
      Does NOT flag valid C patterns like output parameters (int **out_param).
    examples:
      bad:
        - "**ptr = value;"
        - "result = **data;"
      good:
        - "*ptr = value;"
        - "array[index].field = value;"
        - "void func(int **out_param) { ... }  // declarations are OK"

  N6:
    title: No Chained Pointer Access
    severity: NEVER
    mechanical: true
    provenance:
      last_verified: "2026-01-16"
      confidence: high
      re_verify_after: "2027-01-16"
      sources:
        - url: "https://spinroot.com/gerard/pdf/P10.pdf"
          accessed: "2026-01-16"
          quote: "Rule 9: no more than one level of dereferencing should be used"
    description: >
      Never chain pointer dereferences (->field->field). It indicates
      overly coupled data structures. Use local variables to break
      the chain.
    check:
      type: grep
      pattern: '->.*->'
      flags: -n
    examples:
      bad:
        - "value = ptr->inner->data;"
        - "ptr->next->prev = node;"
      good:
        - |
          inner_t *inner = ptr->inner;
          value = inner->data;

  N7:
    title: No Unbounded Loops
    severity: NEVER
    mechanical: true
    provenance:
      last_verified: "2026-01-16"
      confidence: high
      re_verify_after: "2027-01-16"
      sources:
        - url: "https://spinroot.com/gerard/pdf/P10.pdf"
          accessed: "2026-01-16"
          quote: "Rule 2: All loops must have a fixed upper-bound"
    description: >
      Never use unbounded loops (while(1), while(true), for(;;)). All
      loops must have a fixed upper bound that can be statically verified.
    check:
      type: grep
      pattern: 'while\s*\(1\)|while\s*\(true\)|for\s*\(;;\)'
      flags: -En
    examples:
      bad:
        - "while (1) { ... }"
        - "while (true) { ... }"
        - "for (;;) { ... }"
      good:
        - "for (uint32_t i = 0U; i < MAX_ITERATIONS; i++) { ... }"
        - "while (count < MAX_COUNT) { ... count++; }"

  # =========================================================================
  # NEVER - Build Requirements (validator will reject)
  # =========================================================================

  N8:
    title: Compile Clean with Strict Warnings
    severity: NEVER
    mechanical: false
    provenance:
      last_verified: "2026-01-16"
      confidence: high
      re_verify_after: "2027-01-16"
      sources:
        - url: "https://spinroot.com/gerard/pdf/P10.pdf"
          accessed: "2026-01-16"
          quote: "Rule 10: All code must be compiled, from the first day of development, with all compiler warnings enabled at the highest warning level available"
    description: >
      Code must compile without warnings using strict compiler flags:
      -Wall -Wextra -Werror -pedantic -std=c11. Any warning is an error.
    guidance: |
      This rule cannot be validated by Flight because:
      - Cross-compilation targets require specific toolchains (arm-none-eabi-gcc, etc.)
      - SDK headers may not be available on the host machine
      - Build systems vary per project

      Enforce this rule in your actual build system:
      ```makefile
      CFLAGS += -Wall -Wextra -Werror -pedantic -std=c11
      ```

      Or in CMake:
      ```cmake
      target_compile_options(${PROJECT_NAME} PRIVATE -Wall -Wextra -Werror -pedantic)
      ```
    examples:
      bad:
        - "// Code that produces any warning"
      good:
        - "// Code that compiles cleanly with all warnings enabled"

  N9:
    title: Functions Must Be 60 Lines or Less
    severity: NEVER
    mechanical: false
    provenance:
      last_verified: "2026-01-16"
      confidence: high
      re_verify_after: "2027-01-16"
      sources:
        - url: "https://spinroot.com/gerard/pdf/P10.pdf"
          accessed: "2026-01-16"
          quote: "Rule 4: No function should be longer than what can be printed on a single sheet of paper"
    description: >
      Every function must be 60 lines or less. This ensures functions
      fit on one screen and are easier to understand, test, and verify.
    examples:
      bad:
        - "// Function with more than 60 lines"
      good:
        - "// Function with 60 lines or less"

  N10:
    title: Minimum 2 Assertions Per Function
    severity: NEVER
    mechanical: false
    provenance:
      last_verified: "2026-01-16"
      confidence: high
      re_verify_after: "2027-01-16"
      sources:
        - url: "https://spinroot.com/gerard/pdf/P10.pdf"
          accessed: "2026-01-16"
          quote: "Rule 5: The code's assertion density should average to minimally two assertions per function"
    description: >
      Every function must have at least 2 ASSERT() calls - typically
      one for preconditions (input validation) and one for postconditions
      (output validation).
    examples:
      bad:
        - |
          status_t func(int *ptr) {
            // No assertions
            return STATUS_OK;
          }
      good:
        - |
          status_t func(int *ptr) {
            ASSERT(ptr != NULL);
            // implementation
            ASSERT(result == STATUS_OK || result == STATUS_ERROR);
            return result;
          }

  N11:
    title: Check or Cast All Return Values
    severity: NEVER
    mechanical: true
    provenance:
      last_verified: "2026-01-16"
      confidence: high
      re_verify_after: "2027-01-16"
      sources:
        - url: "https://spinroot.com/gerard/pdf/P10.pdf"
          accessed: "2026-01-16"
          quote: "Rule 6: Data objects must be declared at the smallest possible level of scope"
        - url: "https://www.sei.cmu.edu/our-work/publications/cert-c-coding-standard/"
          accessed: "2026-01-16"
          quote: "ERR33-C: Detect and handle standard library errors"
    description: >
      All function return values must be checked or explicitly cast to
      (void) if intentionally ignored. This applies especially to printf
      and fprintf.
    check:
      type: ast
      query: |
        (expression_statement
          (call_expression
            function: (identifier) @fn
            (#match? @fn "^(printf|fprintf|sprintf|snprintf)$"))) @violation
    note: |
      AST-based detection - catches printf/fprintf calls used as statements
      (return value discarded). Does NOT flag when cast to (void) or assigned.
    examples:
      bad:
        - 'printf("Hello");'
        - 'fprintf(fp, "data");'
      good:
        - '(void)printf("Hello");'
        - 'int ret = fprintf(fp, "data"); ASSERT(ret > 0);'
        - '// Comment mentioning printf is OK'

  # =========================================================================
  # GUIDANCE - Best practices (not mechanically checked)
  # =========================================================================

  G1:
    title: Simple Control Flow
    severity: GUIDANCE
    mechanical: false
    description: >
      Use only simple control flow constructs: if, else, for, while,
      do-while, switch with default. No goto, setjmp, longjmp.
    guidance: |
      Allowed control flow:
      - if / else if / else
      - for (with bounded iterations)
      - while (with bounded iterations)
      - do-while (with bounded iterations)
      - switch with default case

      Not allowed:
      - goto
      - setjmp / longjmp
      - Recursion

  G2:
    title: Fixed Loop Bounds Pattern
    severity: GUIDANCE
    mechanical: false
    description: >
      All loops must have a statically verifiable upper bound.
    guidance: |
      #define MAX_ITEMS 100U

      for (uint32_t i = 0U; i < MAX_ITEMS; i++) {
        // Loop body - guaranteed to terminate
      }

      // Counter variable must:
      // - Be initialized
      // - Have a constant upper bound
      // - Be incremented toward the bound

  G3:
    title: Static Memory Only
    severity: GUIDANCE
    mechanical: false
    description: >
      Use only static memory allocation. No heap allocation.
    guidance: |
      // Static allocation patterns:

      // 1. File-scope static buffer
      static uint8_t buffer[MAX_BUFFER_SIZE];

      // 2. Function-scope fixed buffer
      void func(void) {
        char local_buf[FIXED_SIZE];
        // ...
      }

      // 3. Struct with fixed-size arrays
      typedef struct {
        uint8_t data[MAX_DATA_SIZE];
        uint32_t length;
      } message_t;

  G4:
    title: Minimal Scope Principle
    severity: GUIDANCE
    mechanical: false
    description: >
      Declare variables at the smallest possible scope and initialize
      at declaration.
    guidance: |
      // BAD - declared far from use
      int i;
      // ... many lines ...
      for (i = 0; i < MAX; i++) { }

      // GOOD - declared at point of use
      for (int i = 0; i < MAX; i++) { }

      // GOOD - initialized at declaration
      uint32_t count = 0U;
      status_t result = STATUS_OK;

  G5:
    title: Limited Preprocessor Usage
    severity: GUIDANCE
    mechanical: false
    description: >
      Use preprocessor only for includes and constant definitions.
      No conditional compilation.
    guidance: |
      // Allowed:
      #include <stdint.h>
      #include <stdbool.h>
      #include "module.h"

      #define MAX_BUFFER_SIZE 1024U
      #define STATUS_OK 0

      // Not allowed:
      #ifdef DEBUG
      #if FEATURE_ENABLED
      #ifndef HEADER_H

  G6:
    title: Function Template
    severity: GUIDANCE
    mechanical: false
    description: >
      Standard function template with assertions and status return.
    guidance: |
      status_t func_name(const input_t *in, output_t *out)
      {
        // Precondition assertions
        ASSERT(in != NULL);
        ASSERT(out != NULL);

        status_t result = STATUS_OK;

        // Implementation
        // ...

        // Postcondition assertion
        ASSERT(result == STATUS_OK || result == STATUS_ERROR);
        return result;
      }

  G7:
    title: Status Codes Pattern
    severity: GUIDANCE
    mechanical: false
    description: >
      Standard status code enumeration for function return values.
    guidance: |
      typedef enum {
        STATUS_OK = 0,
        STATUS_ERROR = -1,
        STATUS_INVALID_PARAM = -2,
        STATUS_BUFFER_FULL = -3,
        STATUS_BUFFER_EMPTY = -4,
        STATUS_TIMEOUT = -5
      } status_t;

  G8:
    title: ASSERT Macro Pattern
    severity: GUIDANCE
    mechanical: false
    description: >
      Custom ASSERT macro that captures file, line, and expression.
    guidance: |
      #define ASSERT(expr) \
        do { \
          if (!(expr)) { \
            assert_failed(__FILE__, __LINE__, #expr); \
          } \
        } while (0)

      void assert_failed(const char *file, int line, const char *expr)
      {
        // Log or halt - implementation depends on target
        (void)fprintf(stderr, "ASSERT FAILED: %s:%d: %s\n", file, line, expr);
        abort();  // or enter safe state
      }

  G9:
    title: No Magic Numbers
    severity: GUIDANCE
    mechanical: false
    description: >
      All numeric constants must be named with #define or enum.
    guidance: |
      // BAD - magic numbers
      if (count > 100) { }
      buffer[42] = value;

      // GOOD - named constants
      #define MAX_COUNT 100U
      #define HEADER_OFFSET 42U

      if (count > MAX_COUNT) { }
      buffer[HEADER_OFFSET] = value;

  G10:
    title: No Recursion
    severity: GUIDANCE
    mechanical: false
    description: >
      Never use recursion. It makes stack usage unpredictable and
      can lead to stack overflow. Use iteration instead.
    guidance: |
      // BAD - recursive
      uint32_t factorial(uint32_t n) {
        if (n <= 1) return 1;
        return n * factorial(n - 1);  // Stack grows unpredictably
      }

      // GOOD - iterative
      uint32_t factorial(uint32_t n) {
        ASSERT(n <= MAX_FACTORIAL_INPUT);
        uint32_t result = 1U;
        for (uint32_t i = 2U; i <= n; i++) {
          result *= i;
        }
        return result;
      }

anti_patterns:
  - pattern: "goto"
    problem: "Unstructured control flow"
    fix: "Use structured control (if/while/for)"
  - pattern: "setjmp/longjmp"
    problem: "Non-local jumps bypass control flow"
    fix: "Use return codes"
  - pattern: "malloc/free"
    problem: "Unpredictable memory, fragmentation"
    fix: "Static allocation only"
  - pattern: "#ifdef/#if"
    problem: "Multiple untested code paths"
    fix: "Compile separate variants"
  - pattern: "**ptr"
    problem: "Overly complex data structures"
    fix: "Flatten structures"
  - pattern: "->->"
    problem: "Coupled data structures"
    fix: "Use local variables"
  - pattern: "while(1)"
    problem: "Unbounded loop"
    fix: "Use bounded loop with MAX"
  - pattern: "Magic numbers"
    problem: "Unclear intent"
    fix: "Named constants (#define)"
  - pattern: "Recursion"
    problem: "Unpredictable stack usage"
    fix: "Use iteration"
  - pattern: "Unchecked return"
    problem: "Silent failures"
    fix: "Check or cast to (void)"
