#!/bin/bash
# prisma.validate.sh - Prisma ORM patterns for TypeScript/Next
# Generated by flight-domain-compile from prisma.flight
set -euo pipefail

# Script location for sourcing helpers
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Default: common file patterns
DEFAULT_PATTERNS="**/*.ts **/*.tsx **/schema.prisma"
PASS=0
FAIL=0
WARN=0

red() { printf '\033[31m%s\033[0m\n' "$1"; }
green() { printf '\033[32m%s\033[0m\n' "$1"; }
yellow() { printf '\033[33m%s\033[0m\n' "$1"; }

check() {
    local name="$1"
    shift
    local result
    result=$("$@" 2>/dev/null) || true
    if [[ -z "$result" ]]; then
        green "✅ $name"
        ((PASS++)) || true
    else
        red "❌ $name"
        printf '%s\n' "$result" | head -10 | sed 's/^/   /'
        ((FAIL++)) || true
    fi
}

warn() {
    local name="$1"
    shift
    local result
    result=$("$@" 2>/dev/null) || true
    if [[ -z "$result" ]]; then
        green "✅ $name"
        ((PASS++)) || true
    else
        yellow "⚠️  $name"
        printf '%s\n' "$result" | head -5 | sed 's/^/   /'
        ((WARN++)) || true
    fi
}

printf '%s\n' "═══════════════════════════════════════════"
printf '%s\n' "  PRISMA Domain Validation"
printf '%s\n' "═══════════════════════════════════════════"
printf '\n'

# Source exclusions helper if available
if [[ -f "$SCRIPT_DIR/../exclusions.sh" ]]; then
    source "$SCRIPT_DIR/../exclusions.sh"
    FLIGHT_HAS_EXCLUSIONS=true
else
    FLIGHT_HAS_EXCLUSIONS=false
fi

# Handle arguments or use defaults
if [[ $# -gt 0 ]]; then
    FILES=("$@")
elif [[ "$FLIGHT_HAS_EXCLUSIONS" == true ]]; then
    # Use exclusions-aware file discovery
    mapfile -t FILES < <(flight_get_files "*.ts" "*.tsx" "schema.prisma")
else
    # Fallback: use find (works on bash 3.2+, no globstar needed)
    mapfile -t FILES < <(find . -type f \( -name "*.ts" -o -name "*.tsx" -o -name "schema.prisma" \) -not -path "*/node_modules/*" -not -path "*/.git/*" -not -path "*/dist/*" -not -path "*/build/*" 2>/dev/null | sort)
fi

if [[ ${#FILES[@]} -eq 0 ]]; then
    yellow "No files found matching default patterns"
    printf '%s\n' "  Patterns: **/*.ts **/*.tsx **/schema.prisma..."
    printf '\n'
    green "  RESULT: SKIP (no files)"
    exit 0
fi

printf 'Files: %d\n\n' "${#FILES[@]}"

printf '\n%s\n' "## NEVER Rules"

# N1: Queries Without orgId (Multi-tenant)
check "N1: Queries Without orgId (Multi-tenant)" \
    bash -c 'for f in "$@"; do
  # Skip test files and schema files
  if [[ "$f" == *".test."* ]] || [[ "$f" == *".spec."* ]] || [[ "$f" == *"schema.prisma"* ]]; then
    continue
  fi
  # Check server files that query data
  if [[ "$f" == *"/api/"* ]] || [[ "$f" == *"/actions/"* ]] || [[ "$f" == *".server."* ]]; then
    # If file has prisma queries (findMany, findFirst, findUnique, etc)
    if grep -qE "prisma\.[a-z]+\.(findMany|findFirst|findUnique|create|update|delete|upsert)" "$f" 2>/dev/null; then
      # Should have orgId in the file
      if ! grep -qE "orgId|organization_id|organizationId" "$f" 2>/dev/null; then
        if ! grep -q "flight:ok" "$f" 2>/dev/null; then
          echo "$f: Prisma query without orgId filter"
        fi
      fi
    fi
  fi
done' _ "${FILES[@]}"

# N2: $queryRawUnsafe with User Input
check "N2: \$queryRawUnsafe with User Input" \
    grep -En "\\\$queryRawUnsafe|\\\$executeRawUnsafe" "${FILES[@]}"

# N3: N+1 Query Pattern
check "N3: N+1 Query Pattern" \
    bash -c 'for f in "$@"; do
  # Skip test files
  if [[ "$f" == *".test."* ]] || [[ "$f" == *".spec."* ]]; then
    continue
  fi
  # Look for patterns like: for/forEach with prisma query inside
  # This is a heuristic check - looks for loops followed by prisma calls
  awk '"'"'
  /for\s*\(|forEach\s*\(|\.map\s*\(/ {
    in_loop = 1
    loop_line = NR
  }
  in_loop && /prisma\.[a-z]+\.(findMany|findFirst|findUnique)/ {
    if (NR - loop_line < 10) {
      print FILENAME":"NR": Potential N+1 query - prisma call inside loop"
    }
  }
  /^\s*\}/ && in_loop {
    in_loop = 0
  }
  '"'"' "$f" 2>/dev/null | grep -v '"'"'flight:ok'"'"'
done' _ "${FILES[@]}"

# N4: Unhandled Prisma Errors
check "N4: Unhandled Prisma Errors" \
    bash -c 'for f in "$@"; do
  # Skip test files
  if [[ "$f" == *".test."* ]] || [[ "$f" == *".spec."* ]]; then
    continue
  fi
  # Check files with prisma create/update/delete
  if grep -qE "prisma\.[a-z]+\.(create|update|delete|upsert)" "$f" 2>/dev/null; then
    # Should have PrismaClientKnownRequestError or error code handling
    if grep -qE "catch\s*\(" "$f" 2>/dev/null; then
      if ! grep -qE "PrismaClientKnownRequestError|e\.code|error\.code|P2002|P2025|P2003|P2014" "$f" 2>/dev/null; then
        if ! grep -q "flight:ok" "$f" 2>/dev/null; then
          echo "$f: Prisma mutation with generic error handling"
        fi
      fi
    fi
  fi
done' _ "${FILES[@]}"

# N5: New PrismaClient Per Request
check "N5: New PrismaClient Per Request" \
    bash -c 'for f in "$@"; do
  # Skip the singleton file itself (usually lib/prisma.ts or db.ts)
  if [[ "$f" == *"lib/prisma"* ]] || [[ "$f" == *"lib/db"* ]] || [[ "$f" == *"prisma/client"* ]]; then
    continue
  fi
  # Check for new PrismaClient() in request handlers
  if [[ "$f" == *"/api/"* ]] || [[ "$f" == *"/actions/"* ]] || [[ "$f" == *"route.ts"* ]]; then
    if grep -qE "new PrismaClient\(\)" "$f" 2>/dev/null; then
      if ! grep -q "flight:ok" "$f" 2>/dev/null; then
        grep -Hn "new PrismaClient()" "$f"
      fi
    fi
  fi
done' _ "${FILES[@]}"

# N7: Missing Unique Constraint Handling
check "N7: Missing Unique Constraint Handling" \
    bash -c 'for f in "$@"; do
  # Skip test files
  if [[ "$f" == *".test."* ]] || [[ "$f" == *".spec."* ]]; then
    continue
  fi
  # Check files with prisma.*.create
  if grep -qE "prisma\.[a-z]+\.create\s*\(" "$f" 2>/dev/null; then
    # Should have upsert, P2002 handling, or try-catch
    if ! grep -qE "upsert|P2002|catch|try" "$f" 2>/dev/null; then
      if ! grep -q "flight:ok" "$f" 2>/dev/null; then
        grep -Hn "\.create\s*(" "$f" | head -3
      fi
    fi
  fi
done' _ "${FILES[@]}"

printf '\n%s\n' "## MUST Rules"

# M4: Singleton Client Pattern
check "M4: Singleton Client Pattern" \
    bash -c '# Check if there'"'"'s a singleton pattern in the codebase
found_singleton=0
for f in "$@"; do
  if grep -qE "globalThis.*prisma|global.*prisma.*PrismaClient" "$f" 2>/dev/null; then
    found_singleton=1
    break
  fi
done
# Check if there are any prisma imports
has_prisma=0
for f in "$@"; do
  if grep -qE "@prisma/client|PrismaClient" "$f" 2>/dev/null; then
    has_prisma=1
    break
  fi
done
if [[ $has_prisma -eq 1 ]] && [[ $found_singleton -eq 0 ]]; then
  echo "No PrismaClient singleton pattern found (expected in lib/prisma.ts or similar)"
fi' _ "${FILES[@]}"

# M6: Include orgId in Schema
check "M6: Include orgId in Schema" \
    bash -c 'for f in "$@"; do
  if [[ "$f" == *"schema.prisma"* ]]; then
    # Find models that look like tenant data (not User, Organization, etc)
    # Check if they have orgId
    awk '"'"'
    /^model [A-Z]/ {
      model = $2
      in_model = 1
      has_orgid = 0
      # Skip system models
      if (model ~ /^(User|Organization|Account|Session|VerificationToken)$/) {
        in_model = 0
      }
    }
    in_model && /orgId|organizationId/ {
      has_orgid = 1
    }
    in_model && /^}/ {
      if (!has_orgid && model !~ /^(User|Organization|Account|Session|VerificationToken|Membership)$/) {
        print FILENAME": Model "model" may need orgId field for multi-tenant isolation"
      }
      in_model = 0
    }
    '"'"' "$f" 2>/dev/null | grep -v '"'"'flight:ok'"'"'
  fi
done' _ "${FILES[@]}"

printf '\n%s\n' "## Info"

PRISMA_IMPORTS=$( (grep -oE "from .@prisma/client" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  Prisma imports: %s\n' "$PRISMA_IMPORTS"

PRISMA_QUERIES=$( (grep -cE "prisma\.[a-z]+\.(findMany|findFirst|findUnique|create|update|delete)" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  Prisma queries: %s\n' "$PRISMA_QUERIES"

INCLUDE_USAGE=$( (grep -cE "include:\s*\{" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  include usage: %s\n' "$INCLUDE_USAGE"

RAW_QUERIES=$( (grep -cE "\$queryRaw|\$executeRaw" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  Raw queries: %s\n' "$RAW_QUERIES"

TRANSACTIONS=$( (grep -cE "\$transaction" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  Transactions: %s\n' "$TRANSACTIONS"

printf '\n%s\n' "═══════════════════════════════════════════"
printf '  PASS: %d  FAIL: %d  WARN: %d\n' "$PASS" "$FAIL" "$WARN"
if [[ $FAIL -eq 0 ]]; then
    green "  RESULT: PASS"
else
    red "  RESULT: FAIL"
fi
printf '%s\n' "═══════════════════════════════════════════"

exit "$FAIL"
