#!/bin/bash
# yaml.validate.sh - YAML syntax best practices and common footguns
# Generated by flight-compile from yaml.flight
set -euo pipefail

# Default: common file patterns
DEFAULT_PATTERNS="*.yaml *.yml"
PASS=0
FAIL=0
WARN=0

red() { printf '\033[31m%s\033[0m\n' "$1"; }
green() { printf '\033[32m%s\033[0m\n' "$1"; }
yellow() { printf '\033[33m%s\033[0m\n' "$1"; }

check() {
    local name="$1"
    shift
    local result
    result=$("$@" 2>/dev/null) || true
    if [[ -z "$result" ]]; then
        green "✅ $name"
        ((PASS++)) || true
    else
        red "❌ $name"
        printf '%s\n' "$result" | head -10 | sed 's/^/   /'
        ((FAIL++)) || true
    fi
}

warn() {
    local name="$1"
    shift
    local result
    result=$("$@" 2>/dev/null) || true
    if [[ -z "$result" ]]; then
        green "✅ $name"
        ((PASS++)) || true
    else
        yellow "⚠️  $name"
        printf '%s\n' "$result" | head -5 | sed 's/^/   /'
        ((WARN++)) || true
    fi
}

printf '%s\n' "═══════════════════════════════════════════"
printf '%s\n' "  YAML Domain Validation"
printf '%s\n' "═══════════════════════════════════════════"
printf '\n'

# Handle arguments or use defaults
if [[ $# -gt 0 ]]; then
    FILES=("$@")
else
    shopt -s nullglob globstar
    FILES=($DEFAULT_PATTERNS)
    shopt -u nullglob globstar
fi

if [[ ${#FILES[@]} -eq 0 ]]; then
    yellow "No files found matching default patterns"
    printf '%s\n' "  Patterns: *.yaml *.yml..."
    printf '\n'
    green "  RESULT: SKIP (no files)"
    exit 0
fi

printf 'Files: %d\n\n' "${#FILES[@]}"

printf '\n%s\n' "## NEVER Rules"

# N1: Tab Characters
check "N1: Tab Characters" \
    bash -c 'grep -n "^\\t" "$@" | grep -v "flight:ok"' _ "${FILES[@]}"

# N2: Duplicate Keys
check "N2: Duplicate Keys" \
    bash -c '# Check for duplicate keys at the same indentation level
awk '"'"'
/^[[:space:]]*[^#[:space:]][^:]*:/ {
  # Extract indentation and key
  match($0, /^[[:space:]]*/);
  indent = RLENGTH;
  key = $0;
  gsub(/^[[:space:]]*/, "", key);
  gsub(/:.*$/, "", key);

  # Create unique identifier for indent level + key
  id = indent ":" key;

  if (seen[id] && seen[id] == indent_context) {
    print FILENAME ":" NR ": duplicate key \"" key "\" at same level";
    found = 1;
  }
  seen[id] = indent_context;

  # Track context changes
  if (indent == 0) indent_context++;
}
END { exit found ? 1 : 0 }
'"'"' "$file"' _ "${FILES[@]}"

# N3: Unsafe YAML Load
check "N3: Unsafe YAML Load" \
    bash -c 'grep -Pn "yaml\\.load\\s*\\([^)]*\\)\\s*\$|yaml\\.load\\s*\\([^,)]+\\)(?!\\s*,\\s*Loader)" "$@" | grep -v "flight:ok"' _ "${FILES[@]}"

# N4: YAML Bomb (Billion Laughs)
check "N4: YAML Bomb (Billion Laughs)" \
    bash -c 'grep -n "&[a-zA-Z_][a-zA-Z0-9_]*\\s*\\[\\s*\\*[a-zA-Z_]" "$@" | grep -v "flight:ok"' _ "${FILES[@]}"

printf '\n%s\n' "## MUST Rules"

# M1: Unquoted Norway Problem
check "M1: Unquoted Norway Problem" \
    bash -c 'grep -En ":\\s+(no|NO|No|yes|YES|Yes|on|ON|On|off|OFF|Off)\\s*(#|\$)" "$@" | grep -v "flight:ok"' _ "${FILES[@]}"

# M2: Unquoted Sexagesimal Numbers
check "M2: Unquoted Sexagesimal Numbers" \
    bash -c 'grep -En ":\\s+[0-9]+:[0-9]+(:[0-9]+)?\\s*(#|\$)" "$@" | grep -v "flight:ok"' _ "${FILES[@]}"

# M3: Unquoted Octal Numbers
check "M3: Unquoted Octal Numbers" \
    bash -c 'grep -En ":\\s+0[0-7]{2,}\\s*(#|\$)" "$@" | grep -v "flight:ok"' _ "${FILES[@]}"

# M4: Version Number Coercion
check "M4: Version Number Coercion" \
    bash -c 'grep -Ein "version:\\s+[0-9]+\\.[0-9]+\\s*(#|\$)" "$@" | grep -v "flight:ok"' _ "${FILES[@]}"

# M5: Unquoted Scientific Notation
check "M5: Unquoted Scientific Notation" \
    bash -c 'grep -En ":\\s+[0-9]+[eE][0-9]+\\s*(#|\$)" "$@" | grep -v "flight:ok"' _ "${FILES[@]}"

# M6: Unquoted Special Strings
check "M6: Unquoted Special Strings" \
    bash -c 'grep -En ":\\s+(null|Null|NULL|~|true|True|TRUE|false|False|FALSE|\\.inf|\\.Inf|\\.INF|\\.nan|\\.NaN|\\.NAN)\\s*(#|\$)" "$@" | grep -v "flight:ok"' _ "${FILES[@]}"

# M7: Inconsistent Indentation
check "M7: Inconsistent Indentation" \
    bash -c '# Check for inconsistent indentation increments
awk '"'"'
BEGIN { base_indent = 0; last_indent = 0 }
/^[[:space:]]+[^#[:space:]]/ {
  match($0, /^[[:space:]]+/);
  indent = RLENGTH;

  if (base_indent == 0 && indent > 0) {
    base_indent = indent;
  } else if (indent > last_indent && base_indent > 0) {
    increment = indent - last_indent;
    if (increment != base_indent && increment > 0) {
      print FILENAME ":" NR ": inconsistent indent (expected " base_indent ", got " increment ")";
      found = 1;
    }
  }
  last_indent = indent;
}
/^[^[:space:]#]/ { last_indent = 0 }
END { exit found ? 1 : 0 }
'"'"' "$file"' _ "${FILES[@]}"

# M8: Trailing Whitespace in Multiline
check "M8: Trailing Whitespace in Multiline" \
    bash -c 'grep -n "[[:space:]]+\$" "$@" | grep -v "flight:ok"' _ "${FILES[@]}"

printf '\n%s\n' "## SHOULD Rules"

# S1: Prefer Explicit Document Start
warn "S1: Prefer Explicit Document Start" \
    bash -c '# Warn if file has multiple documents without ---
if grep -q '"'"'^---'"'"' "$file"; then
  exit 0  # Has document markers
fi
if grep -c '"'"'^\.\.\.$'"'"' "$file" > /dev/null 2>&1; then
  echo "$file:1: missing document start marker (---) in multi-doc file"
  exit 1
fi
exit 0' _ "${FILES[@]}"

# S2: Quote Strings Starting with Special Characters
warn "S2: Quote Strings Starting with Special Characters" \
    bash -c 'grep -En ":\\s+[@\`*&!|>{[%][^[:space:]]" "$@" | grep -v "flight:ok"' _ "${FILES[@]}"

# S3: Avoid Anchors for Simple Values
warn "S3: Avoid Anchors for Simple Values" \
    bash -c 'grep -n "&[a-zA-Z_][a-zA-Z0-9_]*\\s+[^[{]" "$@" | grep -v "flight:ok"' _ "${FILES[@]}"

# S4: Use Lowercase for Boolean Values
warn "S4: Use Lowercase for Boolean Values" \
    bash -c 'grep -En ":\\s+(True|TRUE|False|FALSE)\\s*(#|\$)" "$@" | grep -v "flight:ok"' _ "${FILES[@]}"

# S5: Quote Empty Strings
warn "S5: Quote Empty Strings" \
    bash -c 'grep -n "^[[:space:]]*[a-zA-Z_][a-zA-Z0-9_-]*:\\s*\$" "$@" | grep -v "flight:ok"' _ "${FILES[@]}"

# S6: Avoid Flow Style for Complex Structures
warn "S6: Avoid Flow Style for Complex Structures" \
    bash -c 'grep -n "\\{[^}]*\\{|\\[[^\\]]*\\[" "$@" | grep -v "flight:ok"' _ "${FILES[@]}"

printf '\n%s\n' "## Info"

ANCHOR_COUNT=$( (grep -cE "&[a-zA-Z_][a-zA-Z0-9_]*" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  Anchor definitions: %s\n' "$ANCHOR_COUNT"

ALIAS_COUNT=$( (grep -cE "\*[a-zA-Z_][a-zA-Z0-9_]*" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  Alias references: %s\n' "$ALIAS_COUNT"

MULTILINE_LITERAL=$( (grep -cE ":\s*\|" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  Literal blocks (|): %s\n' "$MULTILINE_LITERAL"

MULTILINE_FOLDED=$( (grep -cE ":\s*>" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  Folded blocks (>): %s\n' "$MULTILINE_FOLDED"

DOCUMENT_MARKERS=$( (grep -cE "^---" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  Document starts: %s\n' "$DOCUMENT_MARKERS"

COMMENT_LINES=$( (grep -cE "^\s*#" "${FILES[@]}" 2>/dev/null || true) | awk -F: '{s+=$NF}END{print s+0}')
printf 'ℹ️  Comment lines: %s\n' "$COMMENT_LINES"

printf '\n%s\n' "═══════════════════════════════════════════"
printf '  PASS: %d  FAIL: %d  WARN: %d\n' "$PASS" "$FAIL" "$WARN"
if [[ $FAIL -eq 0 ]]; then
    green "  RESULT: PASS"
else
    red "  RESULT: FAIL"
fi
printf '%s\n' "═══════════════════════════════════════════"

exit "$FAIL"
